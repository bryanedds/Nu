<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>FSharpx.Core</name></assembly>
<members>
<member name="T:FSharp.Control.Agent`1">
<summary>
 Type alias for F# mailbox processor type
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.Control.AsyncSeqInner`1">
<summary>
 The interanl type that represents a value returned as a result of
 evaluating a step of an asynchronous sequence
</summary>
</member>
<member name="T:FSharp.Control.AsyncSeq`1">
<summary>
 An asynchronous sequence represents a delayed computation that can be
 started to produce either Cons value consisting of the next element of the 
 sequence (head) together with the next asynchronous sequence (tail) or a 
 special value representing the end of the sequence (Nil)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.Control.AutoCancelAgent`1.remove_Error(Microsoft.FSharp.Control.FSharpHandler{System.Exception})">
<summary>
 Occurs when the execution of the agent results in an exception.
</summary>
</member>
<member name="P:FSharp.Control.AutoCancelAgent`1.Error">
<summary>
 Occurs when the execution of the agent results in an exception.
</summary>
</member>
<member name="P:FSharp.Control.AutoCancelAgent`1.CurrentQueueLength">
<summary>
 Returns the number of unprocessed messages in the message queue of the agent.
</summary>
</member>
<member name="M:FSharp.Control.AutoCancelAgent`1.add_Error(Microsoft.FSharp.Control.FSharpHandler{System.Exception})">
<summary>
 Occurs when the execution of the agent results in an exception.
</summary>
</member>
<member name="M:FSharp.Control.AutoCancelAgent`1.TryScan``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Control.FSharpAsync{``0}}},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Scans for a message by looking through messages in arrival order until &lt;c&gt;scanner&lt;/c&gt; 
 returns a Some value. Other messages remain in the queue.
</summary>
</member>
<member name="M:FSharp.Control.AutoCancelAgent`1.TryReceive(Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Waits for a message. This will consume the first message in arrival order.
</summary>
</member>
<member name="M:FSharp.Control.AutoCancelAgent`1.TryPostAndReply``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Control.FSharpAsyncReplyChannel{``0},`0},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Like PostAndReply, but returns None if no reply within the timeout period.
</summary>
</member>
<member name="M:FSharp.Control.AutoCancelAgent`1.Start(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Control.FSharpMailboxProcessor{`0},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}})">
<summary>
 Start a new disposable agent using the specified body function
 (the method creates a new cancellation token for the agent)
</summary>
</member>
<member name="M:FSharp.Control.AutoCancelAgent`1.Scan``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Control.FSharpAsync{``0}}},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Scans for a message by looking through messages in arrival order until &lt;c&gt;scanner&lt;/c&gt; 
 returns a Some value. Other messages remain in the queue.
</summary>
</member>
<member name="M:FSharp.Control.AutoCancelAgent`1.Receive(Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Waits for a message. This will consume the first message in arrival order.
</summary>
</member>
<member name="M:FSharp.Control.AutoCancelAgent`1.PostAndTryAsyncReply``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Control.FSharpAsyncReplyChannel{``0},`0},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Like PostAndAsyncReply, but returns None if no reply within the timeout period.
</summary>
</member>
<member name="M:FSharp.Control.AutoCancelAgent`1.PostAndReply``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Control.FSharpAsyncReplyChannel{``0},`0},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Posts a message to an agent and await a reply on the channel, synchronously.
</summary>
</member>
<member name="M:FSharp.Control.AutoCancelAgent`1.PostAndAsyncReply``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Control.FSharpAsyncReplyChannel{``0},`0},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Posts a message to an agent and await a reply on the channel, asynchronously.
</summary>
</member>
<member name="M:FSharp.Control.AutoCancelAgent`1.Post(`0)">
<summary>
 Posts a message to the message queue of the MailboxProcessor, asynchronously.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.Control.AutoCancelAgent`1">
<summary>
 Wrapper for the standard F# agent (MailboxProcessor) that
 supports stopping of the agent&apos;s body using the IDisposable 
 interface (the type automatically creates a cancellation token)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.Control.BatchProcessingAgent`1.remove_BatchProduced(Microsoft.FSharp.Control.FSharpHandler{`0[]})">
<summary>
 The event is triggered when a group of messages is collected. The
 group is not empty, but may not be of the specified maximal size
 (when the timeout elapses before enough messages is collected)
</summary>
</member>
<member name="P:FSharp.Control.BatchProcessingAgent`1.BatchProduced">
<summary>
 The event is triggered when a group of messages is collected. The
 group is not empty, but may not be of the specified maximal size
 (when the timeout elapses before enough messages is collected)
</summary>
</member>
<member name="M:FSharp.Control.BatchProcessingAgent`1.add_BatchProduced(Microsoft.FSharp.Control.FSharpHandler{`0[]})">
<summary>
 The event is triggered when a group of messages is collected. The
 group is not empty, but may not be of the specified maximal size
 (when the timeout elapses before enough messages is collected)
</summary>
</member>
<member name="M:FSharp.Control.BatchProcessingAgent`1.Enqueue(`0)">
<summary>
 Sends new message to the agent
</summary>
</member>
<member name="M:FSharp.Control.BatchProcessingAgent`1.System-IDisposable-Dispose">
<summary>
 Dispose
</summary>
</member>
<member name="">

</member>
<member name="T:FSharp.Control.BatchProcessingAgent`1">
<summary>
 Agent that can be used to implement batch processing. It creates groups
 of messages (added using the Enqueue method) and emits them using the 
 BatchProduced event. A group is produced when it reaches the maximal 
 size or after the timeout elapses.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharp.Control.BlockingQueueAgent`1.Count">
<summary>
 Gets the number of elements currently waiting in the queue.
</summary>
</member>
<member name="M:FSharp.Control.BlockingQueueAgent`1.Get(Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Synchronously gets item from the queue. If there are no items
 in the queue, the operation will block until items are added.
 This method blocks until value is available!
</summary>
</member>
<member name="M:FSharp.Control.BlockingQueueAgent`1.AsyncGet(Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Asynchronously gets item from the queue. If there are no items
 in the queue, the operation will block until items are added.
</summary>
</member>
<member name="M:FSharp.Control.BlockingQueueAgent`1.AsyncAdd(`0,Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Asynchronously adds item to the queue. The operation ends when
 there is a place for the item. If the queue is full, the operation
 will block until some items are removed.
</summary>
</member>
<member name="M:FSharp.Control.BlockingQueueAgent`1.Add(`0)">
<summary>
 Asynchronously adds item to the queue. The operation ends when
 there is a place for the item. If the queue is full, the operation
 will block until some items are removed. This overload does not
 signal the caller that the item has been added.
</summary>
</member>
<member name="">

</member>
<member name="T:FSharp.Control.BlockingQueueAgent`1">
<summary>
 Agent that implements an asynchronous queue with blocking put
 and blocking get operation (this implements the producer-consumer 
 concurrent programming pattern). The constructor takes the maximal
 size of the buffer.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharp.Control.CircularQueueAgent`1.Count">
<summary>
 Gets the number of elements currently waiting in the queue.
</summary>
</member>
<member name="M:FSharp.Control.CircularQueueAgent`1.Enqueue(`0[])">
<summary>
 Adds item to the queue. The operation ends when
 there is a place for the item. If the queue is full, the operation
 will block until some items are removed.
</summary>
</member>
<member name="M:FSharp.Control.CircularQueueAgent`1.Enqueue(System.ArraySegment{`0})">
<summary>
 Adds item to the queue. The operation ends when
 there is a place for the item. If the queue is full, the operation
 will block until some items are removed.
</summary>
</member>
<member name="M:FSharp.Control.CircularQueueAgent`1.Enqueue(`0[],System.Int32,System.Int32)">
<summary>
 Adds item to the queue. The operation ends when
 there is a place for the item. If the queue is full, the operation
 will block until some items are removed.
</summary>
</member>
<member name="M:FSharp.Control.CircularQueueAgent`1.Dequeue(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Synchronously gets item from the queue. If there are no items
 in the queue, the operation will block until items are added.
 This method blocks until value is available!
</summary>
</member>
<member name="M:FSharp.Control.CircularQueueAgent`1.AsyncEnqueue(`0[],Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Adds item to the queue. The operation ends when
 there is a place for the item. If the queue is full, the operation
 will block until some items are removed.
</summary>
</member>
<member name="M:FSharp.Control.CircularQueueAgent`1.AsyncEnqueue(System.ArraySegment{`0},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Adds item to the queue. The operation ends when
 there is a place for the item. If the queue is full, the operation
 will block until some items are removed.
</summary>
</member>
<member name="M:FSharp.Control.CircularQueueAgent`1.AsyncEnqueue(`0[],System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Adds item to the queue. The operation ends when
 there is a place for the item. If the queue is full, the operation
 will block until some items are removed.
</summary>
</member>
<member name="M:FSharp.Control.CircularQueueAgent`1.AsyncDequeue(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Asynchronously gets item from the queue. If there are no items
 in the queue, the operation will block until items are added.
</summary>
</member>
<member name="">

</member>
<member name="T:FSharp.Control.CircularQueueAgent`1">
<summary>
 Agent that implements an asynchronous circular buffer with blocking
 enqueue and blocking dequeue operation (this implements the producer-consumer 
 concurrent programming pattern). The constructor takes the maximal
 size of the buffer.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.Control.ConcurrentSetAgent`1.AsyncAdd(System.Object)">
<summary>
 Adds the specified element to the set and returns 
 &apos;false&apos; when it was already present in the set
</summary>
</member>
<member name="">

</member>
<member name="T:FSharp.Control.ConcurrentSetAgent`1">
<summary>
 Agent that implements a simple concurrent set. The agent exposes a 
 member that adds value to the set and returns whether the value
 was already present.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.Control.ObservableUpdate`1">
<summary>
 Union type that represents different messages that can be sent to the
 IObserver interface. The IObserver type is equivalent to a type that has
 just OnNext method that gets &apos;ObservableUpdate&apos; as an argument.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.Control.SlidingWindowAgent`1.remove_WindowProduced(Microsoft.FSharp.Control.FSharpHandler{`0[]})">
<summary>
 The event is triggered when a group of messages is collected. 
 The size of the group is exactly &apos;count&apos; and the values are
 returned in a fresh array.
</summary>
</member>
<member name="P:FSharp.Control.SlidingWindowAgent`1.WindowProduced">
<summary>
 The event is triggered when a group of messages is collected. 
 The size of the group is exactly &apos;count&apos; and the values are
 returned in a fresh array.
</summary>
</member>
<member name="M:FSharp.Control.SlidingWindowAgent`1.add_WindowProduced(Microsoft.FSharp.Control.FSharpHandler{`0[]})">
<summary>
 The event is triggered when a group of messages is collected. 
 The size of the group is exactly &apos;count&apos; and the values are
 returned in a fresh array.
</summary>
</member>
<member name="M:FSharp.Control.SlidingWindowAgent`1.Enqueue(`0)">
<summary>
 Sends new message to the agent
</summary>
</member>
<member name="">

</member>
<member name="T:FSharp.Control.SlidingWindowAgent`1">
<summary>
 Agent that implements the &quot;sliding window&quot; functionality. It collects
 messages added using the Enqueue method and emits them in overlapping 
 groups of the specified size. For example, given [1,2,3,4,5...] and a 
 size 3, the produced groups will be [1,2,3], [2,3,4], [3,4,5], ...
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.Control.AsyncExtensions.Async.TryAwaitTask.Static``1(System.Threading.Tasks.Task{``0},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
<summary>
 Starts a Task&lt;&apos;a&gt; with the timeout and cancellationToken and
 returns a Async&lt;a&apos; option&gt; containing the result.  If the Task does
 not complete in the timeout interval, or is faulted None is returned.
</summary>
</member>
<member name="M:FSharp.Control.AsyncExtensions.Async.StartDisposable.Static(Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit})">
<summary>
 Starts the specified operation using a new CancellationToken and returns
 IDisposable object that cancels the computation. This method can be used
 when implementing the Subscribe method of IObservable interface.
</summary>
</member>
<member name="M:FSharp.Control.AsyncExtensions.Async.Cache.Static``1(Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Creates an asynchronous workflow that runs the asynchronous workflow
 given as an argument at most once. When the returned workflow is 
 started for the second time, it reuses the result of the 
 previous execution.
</summary>
</member>
<member name="T:FSharp.Control.AsyncExtensions">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.Control.AsyncSeq.BufferMessage`1">
<summary>
 A helper type for implementation of buffering when converting 
 observable to an asynchronous sequence
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.Control.AsyncSeq.AsyncSeqBuilder.For``2(Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``1}}})">
<summary>
 Asynchronous for loop - for all elements from the input sequence,
 generate all elements produced by the body (asynchronously). See
 also the AsyncSeq.collect function.
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.AsyncSeqBuilder.For``2(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``1}}})">
<summary>
 For loop that iterates over a synchronous sequence (and generates
 all elements generated by the asynchronous body)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.Control.AsyncSeq.AsyncSeqBuilder">
<summary>
 Computation builder that allows creating of asynchronous 
 sequences using the &apos;asyncSeq { ... }&apos; syntax
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.skip``1(System.Int32,Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Skips the first N elements of an asynchronous sequence and
 then returns the rest of the sequence unmodified.
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.take``1(System.Int32,Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Returns the first N elements of an asynchronous sequence
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.skipWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Skips elements from an asynchronous sequence while the specified 
 predicate holds and then returns the rest of the sequence. The 
 predicate is evaluated asynchronously.
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.takeWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Returns elements from an asynchronous sequence while the specified 
 predicate holds. The predicate is evaluated synchronously.
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.skipWhileAsync``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Skips elements from an asynchronous sequence while the specified 
 predicate holds and then returns the rest of the sequence. The 
 predicate is evaluated asynchronously.
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.takeWhileAsync``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Returns elements from an asynchronous sequence while the specified 
 predicate holds. The predicate is evaluated asynchronously.
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.zip``2(Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}},Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``1}})">
<summary>
 Combines two asynchronous sequences into a sequence of pairs. 
 The values from sequences are retrieved in parallel. 
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.cache``1(Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Create a new asynchronous sequence that caches all elements of the 
 sequence specified as the input. When accessing the resulting sequence
 multiple times, the input will still be evaluated only once
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.toBlockingSeq``1(Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Converts asynchronous sequence to a synchronous blocking sequence.
 The elements of the asynchronous sequence are consumed lazily.
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.toObservable``1(Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Converts asynchronous sequence to an IObservable&lt;_&gt;. When the client subscribes
 to the observable, a new copy of asynchronous sequence is started and is 
 sequentially iterated over (at the maximal possible speed). Disposing of the 
 observer cancels the iteration over asynchronous sequence. 
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.ofObservable``1(System.IObservable{``0})">
<summary>
 Converts observable to an asynchronous sequence. Values that are produced
 by the observable while the asynchronous sequence is blocked are discarded
 (this function doesn&apos;t guarantee that asynchronou ssequence will return 
 all values produced by the observable)
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.ofObservableBuffered``1(System.IObservable{``0})">
<summary>
 Converts observable to an asynchronous sequence. Values that are produced
 by the observable while the asynchronous sequence is blocked are stored to 
 an unbounded buffer and are returned as next elements of the async sequence.
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.ofObservableUsingAgent``1(System.IObservable{``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Control.FSharpMailboxProcessor{FSharp.Control.AsyncSeq.BufferMessage{FSharp.Control.ObservableUpdate{``0}}},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}})">
<summary>
 Converts observable to an asynchronous sequence using an agent with
 a body specified as the argument. The returnd async sequence repeatedly 
 sends &apos;Get&apos; message to the agent to get the next element. The observable
 sends &apos;Put&apos; message to the agent (as new inputs are generated).
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates an asynchronous sequence that lazily takes element from an
 input synchronous sequence and returns them one-by-one.
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Same as AsyncSeq.filterAsync, but the specified predicate is synchronous
 and processes the input element immediately.
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.choose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Same as AsyncSeq.chooseAsync, but the specified function is synchronous
 and processes the input element immediately.
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.iter``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Same as AsyncSeq.iterAsync, but the specified function is synchronous
 and performs the side-effect immediately.
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Same as AsyncSeq.mapAsync, but the specified function is synchronous
 and returns the result of projection immediately.
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.scan``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``1}})">
<summary>
 Same as AsyncSeq.scanAsync, but the specified function is synchronous
 and returns the result of aggregation immediately.
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``1}})">
<summary>
 Same as AsyncSeq.foldAsync, but the specified function is synchronous
 and returns the result of aggregation immediately.
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.foldAsync``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``0}}},``0,Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``1}})">
<summary>
 Aggregates the elements of the input asynchronous sequence using the
 specified &apos;aggregation&apos; function. The result is an asynchronous 
 workflow that returns the final result.

 The aggregation function is asynchronous (and the input sequence will
 be asked for the next element after the processing of an element completes).
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.pairwise``1(Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Returns an asynchronous sequence that returns pairs containing an element
 from the input sequence and its predecessor. Empty sequence is returned for
 singleton input sequence.
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.iterAsync``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Iterates over the input sequence and calls the specified function for
 every value (to perform some side-effect asynchronously).

 The specified function is asynchronous (and the input sequence will
 be asked for the next element after the processing of an element completes).
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.scanAsync``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``0}}},``0,Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``1}})">
<summary>
 Aggregates the elements of the input asynchronous sequence using the
 specified &apos;aggregation&apos; function. The result is an asynchronous 
 sequence of intermediate aggregation result.

 The aggregation function is asynchronous (and the input sequence will
 be asked for the next element after the processing of an element completes).
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.firstOrDefault``1(``0,Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Asynchronously returns the first element that was generated by the
 given asynchronous sequence (or the specified default value).
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.lastOrDefault``1(``0,Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Asynchronously returns the last element that was generated by the
 given asynchronous sequence (or the specified default value).
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.filterAsync``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Builds a new asynchronous sequence whose elements are those from the
 input sequence for which the specified function returned true.

 The specified function is asynchronous (and the input sequence will
 be asked for the next element after the processing of an element completes).
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.chooseAsync``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``1}}},Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Asynchronously iterates over the input sequence and generates &apos;x&apos; for 
 every input element for which the specified asynchronous function 
 returned &apos;Some(x)&apos; 

 The specified function is asynchronous (and the input sequence will
 be asked for the next element after the processing of an element completes).
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.mapAsync``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Builds a new asynchronous sequence whose elements are generated by 
 applying the specified function to all elements of the input sequence.

 The specified function is asynchronous (and the input sequence will
 be asked for the next element after the processing of an element completes).
</summary>
</member>
<member name="">

</member>
<member name="M:FSharp.Control.AsyncSeq.collect``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``1}}},Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Creates an asynchronou sequence that iterates over the given input sequence.
 For every input element, it calls the the specified function and iterates
 over all elements generated by that asynchronous sequence.
 This is the &apos;bind&apos; operation of the computation expression (exposed using
 the &apos;for&apos; keyword in asyncSeq computation).
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.tryFinally``1(Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Implements the &apos;TryFinally&apos; functionality for computation builder
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.tryWith``1(Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}},Microsoft.FSharp.Core.FSharpFunc{System.Exception,Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}}})">
<summary>
 Implements the &apos;TryWith&apos; functionality for computation builder
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.tryNext``1(Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Tries to get the next element of an asynchronous sequence
 and returns either the value or an exception
</summary>
</member>
<member name="P:FSharp.Control.AsyncSeq.asyncSeq">
<summary>
 Builds an asynchronou sequence using the computation builder syntax
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.append``1(Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}},Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Yields all elements of the first asynchronous sequence and then 
 all elements of the second asynchronous sequence.
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.singleton``1(``0)">
<summary>
 Creates an asynchronous sequence that generates a single element and then ends
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.empty``1">
<summary>
 Creates an empty asynchronou sequence that immediately ends
</summary>
</member>
<member name="T:FSharp.Control.AsyncSeq">
<summary>
 Module with helper functions for working with asynchronous sequences
</summary>
</member>
<member name="">

</member>
<member name="P:FSharp.Control.AsyncSeqExtensions.asyncSeq">
<summary>
 Builds an asynchronou sequence using the computation builder syntax
</summary>
</member>
<member name="T:FSharp.Control.AsyncSeqExtensions">

</member>
<member name="">

</member>
<member name="T:FSharp.Control.BufferAgent">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.Control.Observable.Async.AwaitObservable.Static``4(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3})">
<summary>
 Creates an asynchronous workflow that will be resumed when the 
 first of the specified four observables produces a value. The 
 workflow will return a Choice value that can be used to identify
 the observable that produced the value.
</summary>
</member>
<member name="M:FSharp.Control.Observable.Async.AwaitObservable.Static``3(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2})">
<summary>
 Creates an asynchronous workflow that will be resumed when the 
 first of the specified three observables produces a value. The 
 workflow will return a Choice value that can be used to identify
 the observable that produced the value.
</summary>
</member>
<member name="M:FSharp.Control.Observable.Async.AwaitObservable.Static``2(System.IObservable{``0},System.IObservable{``1})">
<summary>
 Creates an asynchronous workflow that will be resumed when the 
 first of the specified two observables produces a value. The 
 workflow will return a Choice value that can be used to identify
 the observable that produced the value.
</summary>
</member>
<member name="M:FSharp.Control.Observable.Async.AwaitObservable.Static``1(System.IObservable{``0})">
<summary>
 Creates an asynchronous workflow that will be resumed when the 
 specified observables produces a value. The workflow will return 
 the value produced by the observable.
</summary>
</member>
<member name="M:FSharp.Control.Observable.Async.GuardedAwaitObservable.Static``1(System.IObservable{``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Behaves like AwaitObservable, but calls the specified guarding function
 after a subscriber is registered with the observable.
</summary>
</member>
<member name="M:FSharp.Control.Observable.synchronize``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.Unit},``0})">
<summary>
 Helper that can be used for writing CPS-style code that resumes
 on the same thread where the operation was started.
</summary>
</member>
<member name="M:FSharp.Control.Observable.delay``1(System.Int32,System.IObservable{``0})">
<summary>
 Delay execution of Observer function
</summary>
</member>
<member name="M:FSharp.Control.Observable.invoke``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.Unit},System.IObservable{``0})">
<summary>
 Invoke Observer function through specified function
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.Control.Observable.asUpdates``1(System.IObservable{``0})">
<summary>
 Turns observable into an observable that only calls OnNext method of the
 observer, but gives it a discriminated union that represents different
 kinds of events (error, next, completed)
</summary>
</member>
<member name="M:FSharp.Control.Observable.guard``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit},System.IObservable{``0})">
<summary>
 Creates an observable that calls the specified function (each time)
 after an observer is attached to the observable. This is useful to 
 make sure that events triggered by the function are handled. 
</summary>
</member>
<member name="M:FSharp.Control.Observable.windowed``1(System.Int32,System.IObservable{``0})">
<summary>
 Returns an observable that yields sliding windows of 
 containing elements drawn from the input observable. 
 Each window is returned as a fresh array.
</summary>
</member>
<member name="T:FSharp.Control.Observable">

</member>
<member name="M:FSharp.Control.Seq.ofAsyncSeq``1(Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Converts asynchronous sequence to a synchronous blocking sequence.
 The elements of the asynchronous sequence are consumed lazily.
</summary>
</member>
<member name="T:FSharp.Control.Seq">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.IO.IOExtensions.Stream.AsyncWriteSeq(System.IO.Stream,Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{System.Byte[]}})">
<summary>
 Asynchronously writes all data specified by the 
 given asynchronous sequence to the stream.
</summary>
</member>
<member name="M:FSharp.IO.IOExtensions.Stream.AsyncReadSeq(System.IO.Stream,Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Asynchronously reads the stream in chunks of a specified size
 and returns the result as an asynchronous sequence.
</summary>
</member>
<member name="T:FSharp.IO.IOExtensions">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Cont`2">
<summary>
 The continuation monad.
 The algorithm is from Wes Dyer http://blogs.msdn.com/b/wesdyer/archive/2008/01/11/the-marvels-of-monads.aspx.
 The builder approach is from Matthew Podwysocki&apos;s excellent Creating Extended Builders series http://codebetter.com/blogs/matthew.podwysocki/archive/2010/01/18/much-ado-about-monads-creating-extended-builders.aspx.
 Current implementation from Matt&apos;s gist at https://gist.github.com/628956
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Coroutine">
<summary>
 The coroutine type from http://fssnip.net/7M
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Enumeratee`3">
<summary>
 An enumeratee is an enumerator that produces an iteratee using another iteratee as input.
 Enumeratees can be used for tasks such as encoding or encrypting data.
</summary>
</member>
<member name="T:FSharpx.Enumerator`2">
<summary>
 An enumerator generates a stream of data and feeds an iteratee, returning a new iteratee.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.FSharpAsyncEx.Protect``1(Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Encapsulates any possible exceptions during bind in a Choice
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.FSharpAsyncEx.IgnoreResult``1(Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Ignores (discards) the result of the async computation
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.FSharpChoice.Value``2(Microsoft.FSharp.Core.FSharpChoice{``0,``1})">
<summary>
 If Choice is 1Of2, return its value.
 Otherwise throw ArgumentException.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.FSharpChoice.Cast``1(System.Object)">
<summary>
 Attempts to cast an object.
 Stores the cast value in 1Of2 if successful, otherwise stores the exception in 2Of2
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.FSharpFunc.FromFunc``3(System.Func{``0,``1,``2})">
<summary>
 Convert a Func into an F# function
</summary>
</member>
<member name="M:FSharpx.FSharpFunc.FromFunc``2(System.Func{``0,``1})">
<summary>
 Convert a Func into an F# function
</summary>
</member>
<member name="M:FSharpx.FSharpFunc.FromFunc``1(System.Func{``0})">
<summary>
 Convert a Func into an F# function
</summary>
</member>
<member name="M:FSharpx.FSharpFunc.FromAction``3(System.Action{``0,``1,``2})">
<summary>
 Convert an Action into an F# function returning unit
</summary>
</member>
<member name="M:FSharpx.FSharpFunc.FromAction``2(System.Action{``0,``1})">
<summary>
 Convert an Action into an F# function returning unit
</summary>
</member>
<member name="M:FSharpx.FSharpFunc.FromAction``1(System.Action{``0})">
<summary>
 Convert an Action into an F# function returning unit
</summary>
</member>
<member name="M:FSharpx.FSharpFunc.FromAction(System.Action)">
<summary>
 Convert an Action into an F# function returning unit
</summary>
</member>
<member name="T:FSharpx.FSharpFunc">
 <summary>
 Conversion functions from Action/Func to FSharpFunc
 We need these because FuncConvert often makes C# type inference fail.
 </summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.FSharpOption.Where``1(Microsoft.FSharp.Core.FSharpOption{``0},System.Predicate{``0})">
<summary>
 Applies a predicate to the option. If the predicate returns true, returns Some x, otherwise None.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.FSharpOption.ToFSharpList``1(Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Converts the option to a list of length 0 or 1
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.FSharpOption.ToArray``1(Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Converts the option to an array of length 0 or 1
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.FSharpOption.SelectMany``3(Microsoft.FSharp.Core.FSharpOption{``0},System.Func{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Func{``0,``1,``2})">
<summary>
 Invokes a function on an optional value that itself yields an option,
 and then applies a mapping function
</summary>
</member>
<member name="M:FSharpx.FSharpOption.SelectMany``2(Microsoft.FSharp.Core.FSharpOption{``0},System.Func{``0,Microsoft.FSharp.Core.FSharpOption{``1}})">
<summary>
 Invokes a function on an optional value that itself yields an option
</summary>
</member>
<member name="M:FSharpx.FSharpOption.Select``2(Microsoft.FSharp.Core.FSharpOption{``0},System.Func{``0,``1})">
<summary>
 Transforms an option value by using a specified mapping function
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.FSharpOption.OrElse``1(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Gets the option if Some x, otherwise the supplied default value.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.FSharpOption.Aggregate``2(Microsoft.FSharp.Core.FSharpOption{``0},``1,System.Func{``1,``0,``1})">
 <summary>
 Evaluates the equivalent of <see cref="System.Linq.Enumerable.Aggregate"/> for an option
 </summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Funcs.Untuple``4(System.Action{System.Tuple{``0,``1,``2,``3}})">
<summary>
 Converts an action taking a 4-tuple into an action with 4 parameters
</summary>
</member>
<member name="M:FSharpx.Funcs.Untuple``3(System.Action{System.Tuple{``0,``1,``2}})">
<summary>
 /// Converts an action taking a 3-tuple into an action with 3 parameters
</summary>
</member>
<member name="M:FSharpx.Funcs.Untuple``2(System.Action{System.Tuple{``0,``1}})">
<summary>
 Converts an action taking a 2-tuple into an action with 2 parameters
</summary>
</member>
<member name="M:FSharpx.Funcs.Tuple``4(System.Action{``0,``1,``2,``3})">
<summary>
 Converts an action with 4 arguments into an action taking a 4-tuple
</summary>
</member>
<member name="M:FSharpx.Funcs.Tuple``3(System.Action{``0,``1,``2})">
<summary>
 Converts an action with 3 arguments into an action taking a 3-tuple
</summary>
</member>
<member name="M:FSharpx.Funcs.Tuple``2(System.Action{``0,``1})">
<summary>
 Converts an action with 2 arguments into an action taking a 2-tuple
</summary>
</member>
<member name="M:FSharpx.Funcs.ToFunc``3(System.Action{``0,``1,``2})">
<summary>
 Converts an action to a function returning Unit
</summary>
</member>
<member name="M:FSharpx.Funcs.ToFunc``2(System.Action{``0,``1})">
<summary>
 Converts an action to a function returning Unit
</summary>
</member>
<member name="M:FSharpx.Funcs.ToFunc``1(System.Action{``0})">
<summary>
 Converts an action to a function returning Unit
</summary>
</member>
<member name="M:FSharpx.Funcs.ToFunc(System.Action)">
<summary>
 Converts an action to a function returning Unit
</summary>
</member>
<member name="M:FSharpx.Funcs.Curry``4(System.Func{``0,``1,``2,``3})">
<summary>
 Converts an uncurried function to a curried function
</summary>
</member>
<member name="M:FSharpx.Funcs.Curry``3(System.Func{``0,``1,``2})">
<summary>
 Converts an uncurried function to a curried function
</summary>
</member>
<member name="M:FSharpx.Funcs.Compose``3(System.Func{``0,``1},System.Func{``2,``0})">
<summary>
 Composes two functions.
 Mathematically: f . g
</summary>
</member>
<member name="M:FSharpx.Funcs.AndThen``3(System.Func{``0,``1},System.Func{``1,``2})">
<summary>
 Composes two functions (forward composition).
 Mathematically: g . f
</summary>
</member>
<member name="T:FSharpx.Funcs">
<summary>
 Extensions around Actions and Funcs
</summary>
</member>
<member name="M:FSharpx.ISemigroup`1.Combine(`0,`0)">
 <summary>
 Associative operation
 </summary>
</member>
<member name="T:FSharpx.ISemigroup`1">
<summary>
 Semigroup (set with associative binary operation)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Iteratee`2">
<summary>
 The iteratee is a stream consumer that will consume a stream of data until either 
 it receives an EOF or meets its own requirements for consuming data. The iteratee
 will return Continue whenever it is ready to receive the next chunk. An iteratee
 is fed data by an Enumerator, which generates a Stream. 
</summary>
</member>
<member name="M:FSharpx.L.F``3(System.Func{``0,``1,``2})">
<summary>
 Helps the C# compiler with Func type inference.
</summary>
</member>
<member name="M:FSharpx.L.F``2(System.Func{``0,``1})">
<summary>
 Helps the C# compiler with Func type inference.
</summary>
</member>
<member name="M:FSharpx.L.F``1(System.Func{``0})">
<summary>
 Helps the C# compiler with Func type inference.
</summary>
</member>
<member name="T:FSharpx.L">
<summary>
 Helps the C# compiler with Func type inference.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Monoid`1.Zero">
 <summary>
 Identity
 </summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Monoid`1.Concat(System.Collections.Generic.IEnumerable{`0})">
<summary>
 Fold a list using this monoid
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Monoid`1.Combine(`0,`0)">
<summary>
 Associative operation
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.Monoid`1">
<summary>
 Monoid (associative binary operation with identity)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Stream`1">
<summary>
 A stream of chunks of data generated by an Enumerator.
 The stream can be composed of chunks of &apos;T, empty blocks indicating a wait, or an EOF marker.
 Be aware that when using #seq&lt;_&gt; types, you will need to check for both Seq.empty ([]) and Empty.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Async.op_LessEqualsLess``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Async.op_GreaterEqualsGreater``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``2}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Async.op_GreaterGreaterDot``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Control.FSharpAsync{``1})">
<summary>
 Sequentially compose two async actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.Async.op_LessMultiply``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Control.FSharpAsync{``1})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Async.op_MultiplyGreater``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Control.FSharpAsync{``1})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Async.op_LessBangGreater``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Infix map
</summary>
</member>
<member name="M:FSharpx.Async.lift2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Control.FSharpAsync{``1})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Async.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Transforms an async value by using a specified mapping function.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Async.pipe``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Flipped map
</summary>
</member>
<member name="M:FSharpx.Async.ap``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpFunc{``0,``1}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Async.op_LessMultiplyGreater``2(Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpFunc{``0,``1}},Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Async.op_EqualsLessLess``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Flipped &gt;&gt;=
</summary>
</member>
<member name="M:FSharpx.Async.op_GreaterGreaterEquals``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
<summary>
 Sequentially compose two actions, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:FSharpx.Async.returnM``1(``0)">
<summary>
 Inject a value into the async type
</summary>
</member>
<member name="M:FSharpx.Async.bind``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Sequentially compose two actions, passing any value produced by the second as an argument to the first.
</summary>
</member>
<member name="T:FSharpx.Async">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Choice.ofOption``2(``0,Microsoft.FSharp.Core.FSharpOption{``1})">
<summary>
 If Some value, returns Choice1Of2 value. Otherwise, returns the supplied default value.
</summary>
</member>
<member name="M:FSharpx.Choice.toOption``2">
<summary>
 If Choice is 1Of2, returns Some value. Otherwise, returns None.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Choice.mapSecond``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Transforms a Choice&apos;s second value by using a specified mapping function.
</summary>
</member>
<member name="M:FSharpx.Choice.choice``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``1},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Maps both parts of a Choice.
 Applies the first function if Choice is 1Of2.
 Otherwise applies the second function
</summary>
</member>
<member name="M:FSharpx.Choice.bimap``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Maps both parts of a Choice.
 Applies the first function if Choice is 1Of2.
 Otherwise applies the second function
</summary>
</member>
<member name="M:FSharpx.Choice.op_LessEqualsLess``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Choice.op_GreaterEqualsGreater``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpChoice{``3,``2}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Choice.op_GreaterGreaterDot``3(Microsoft.FSharp.Core.FSharpChoice{``0,``1},Microsoft.FSharp.Core.FSharpChoice{``2,``1})">
<summary>
 Sequentially compose two either actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.Choice.op_EqualsLessLess``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Flipped &gt;&gt;=
</summary>
</member>
<member name="M:FSharpx.Choice.op_GreaterGreaterEquals``3(Microsoft.FSharp.Core.FSharpChoice{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``2,``1}})">
<summary>
 Sequentially compose two actions, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:FSharpx.Choice.bind``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Monadic bind
</summary>
</member>
<member name="M:FSharpx.Choice.op_LessMultiply``3(Microsoft.FSharp.Core.FSharpChoice{``0,``1},Microsoft.FSharp.Core.FSharpChoice{``2,``1})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Choice.op_MultiplyGreater``3(Microsoft.FSharp.Core.FSharpChoice{``0,``1},Microsoft.FSharp.Core.FSharpChoice{``2,``1})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Choice.lift2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpChoice{``0,``3},Microsoft.FSharp.Core.FSharpChoice{``1,``3})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Choice.op_LessBangGreater``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Infix map
</summary>
</member>
<member name="M:FSharpx.Choice.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Transforms a Choice&apos;s first value by using a specified mapping function.
</summary>
</member>
<member name="M:FSharpx.Choice.op_LessMultiplyGreater``3(Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Choice.ap``3(Microsoft.FSharp.Core.FSharpChoice{``0,``1},Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Core.FSharpFunc{``0,``2},``1})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Choice.cast``1(System.Object)">
<summary>
 Attempts to cast an object.
 Stores the cast value in 1Of2 if successful, otherwise stores the exception in 2Of2
</summary>
</member>
<member name="M:FSharpx.Choice.protect``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0)">
<summary>
 Wraps a function, encapsulates any exception thrown within to a Choice
</summary>
</member>
<member name="M:FSharpx.Choice.get``2(Microsoft.FSharp.Core.FSharpChoice{``0,``1})">
<summary>
 If Choice is 1Of2, return its value.
 Otherwise throw ArgumentException.
</summary>
</member>
<member name="M:FSharpx.Choice.returnM``2(``0)">
<summary>
 Inject a value into the Choice type
</summary>
</member>
<member name="T:FSharpx.Choice">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.ByteString.GetHashCode">
<summary>
 Gets the hash code for the byte string.
</summary>
</member>
<member name="M:FSharpx.Collections.ByteString.System-Collections-Generic-IEnumerable`1-GetEnumerator">
<summary>
 Gets an enumerator for the bytes stored in the byte string.
</summary>
</member>
<member name="M:FSharpx.Collections.ByteString.System-Collections-Generic-IEnumerable`1-GetEnumerator">
<summary>
 Gets an enumerator for the bytes stored in the byte string.
</summary>
</member>
<member name="M:FSharpx.Collections.ByteString.GetEnumerator">
<summary>
 Gets an enumerator for the bytes stored in the byte string.
</summary>
</member>
<member name="M:FSharpx.Collections.ByteString.Equals(System.Object)">
<summary>
 Compares two objects for equality. When both are byte strings, structural equality is used.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.ByteString.Compare(FSharpx.Collections.ByteString,FSharpx.Collections.ByteString)">
<summary>
 Compares two byte strings based on their structure.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.ByteString">
<summary>
 An ArraySegment with structural comparison and equality.
</summary>
</member>
<member name="P:FSharpx.Collections.DList`1.Uncons">
<summary>
O(log n). Returns the first element and tail.
</summary>
</member>
<member name="P:FSharpx.Collections.DList`1.TryUncons">
<summary>
O((log n). Returns option first element and tail.
</summary>
</member>
<member name="P:FSharpx.Collections.DList`1.TryTail">
<summary>
O(log n). Returns option DList of the elements trailing the first element.
</summary>
</member>
<member name="P:FSharpx.Collections.DList`1.TryHead">
<summary>
O(log n). Returns option first element
</summary>
</member>
<member name="P:FSharpx.Collections.DList`1.Tail">
<summary>
O(log n). Returns a new DList of the elements trailing the first element.
</summary>
</member>
<member name="P:FSharpx.Collections.DList`1.Length">
<summary>
O(1). Returns the count of elememts.
</summary>
</member>
<member name="P:FSharpx.Collections.DList`1.IsEmpty">
<summary>
O(1). Returns true if the DList has no elements.
</summary>
</member>
<member name="P:FSharpx.Collections.DList`1.Head">
<summary>
O(log n). Returns the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.DList`1.Cons(`0)">
<summary>
O(1). Returns a new DList with the element added to the front.
</summary>
</member>
<member name="M:FSharpx.Collections.DList`1.Conj(`0)">
<summary>
O(1). Returns a new DList with the element added to the end.
</summary>
</member>
<member name="T:FSharpx.Collections.DList`1">
<summary>
 DList is an ordered linear structure implementing the List signature (head, tail, cons), 
 end-insertion (conj), and O(1) append. Ordering is by insertion history.
 DList is an implementation of John Hughes&apos; append list.
 See http://dl.acm.org/citation.cfm?id=8475 for more information.
 An example can be found at http://stackoverflow.com/questions/5324623/functional-o1-append-and-on-iteration-from-first-element-list-data-structure/5327209#5327209
 List-like structure naming semantics: http://jackfoxy.com/semantics-and-list-like-data-structures
</summary>
</member>
<member name="P:FSharpx.Collections.Deque`1.Uncons">
<summary>
O(1) amortized, O(n), worst case. Returns the first element and tail.
</summary>
</member>
<member name="P:FSharpx.Collections.Deque`1.Unconj">
<summary>
O(1) amortized, O(n), worst case. Returns init and the last element.
</summary>
</member>
<member name="P:FSharpx.Collections.Deque`1.TryUncons">
<summary>
O(1) amortized, O(n), worst case. Returns option first element and tail.
</summary>
</member>
<member name="P:FSharpx.Collections.Deque`1.TryUnconj">
<summary>
O(1) amortized, O(n), worst case. Returns option init and the last element.
</summary>
</member>
<member name="P:FSharpx.Collections.Deque`1.TryTail">
<summary>
O(1) amortized, O(n), worst case. Returns option deque of the elements trailing the first element.
</summary>
</member>
<member name="P:FSharpx.Collections.Deque`1.TryLast">
<summary>
O(1) amortized, O(n), worst case. Returns option last element.
</summary>
</member>
<member name="P:FSharpx.Collections.Deque`1.TryInitial">
<summary>
O(1) amortized, O(n), worst case. Returns a new deque of the elements before the last element.
</summary>
</member>
<member name="P:FSharpx.Collections.Deque`1.TryHead">
<summary>
O(1) amortized, O(n), worst case. Returns option first element.
</summary>
</member>
<member name="P:FSharpx.Collections.Deque`1.Tail">
<summary>
O(1) amortized, O(n), worst case. Returns a new deque of the elements trailing the first element.
</summary>
</member>
<member name="P:FSharpx.Collections.Deque`1.Rev">
<summary>
O(1). Returns deque reversed.
</summary>
</member>
<member name="P:FSharpx.Collections.Deque`1.Length">
<summary>
O(1). Returns the count of elememts.
</summary>
</member>
<member name="P:FSharpx.Collections.Deque`1.Last">
<summary>
O(1) amortized, O(n), worst case. Returns the last element.
</summary>
</member>
<member name="P:FSharpx.Collections.Deque`1.IsEmpty">
<summary>
O(1). Returns true if the deque has no elements.
</summary>
</member>
<member name="P:FSharpx.Collections.Deque`1.Initial">
<summary>
O(1) amortized, O(n), worst case. Returns a new deque of the elements before the last element.
</summary>
</member>
<member name="P:FSharpx.Collections.Deque`1.Head">
<summary>
O(1) amortized, O(n), worst case. Returns the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Deque`1.Cons(`0)">
<summary>
O(1). Returns a new deque with the element added to the beginning.
</summary>
</member>
<member name="M:FSharpx.Collections.Deque`1.Conj(`0)">
<summary>
O(1). Returns a new deque with the element added to the end.
</summary>
</member>
<member name="T:FSharpx.Collections.Deque`1">
<summary>
 Double-ended queue is an ordered linear linear structure implementing the signature of List
 (head, tail, cons) as well as the mirror-image Vector signature (last, initial, conj). &quot;head&quot; inspects 
 the first or left-most element in the structure, while &quot;last&quot; inspects the last or 
 right-most element. &quot;rev&quot; (reverse) has time complexity O(1). Ordering is by insertion history.
</summary>
</member>
<member name="P:FSharpx.Collections.Heap`1.TryHead">
<summary>
O(1) worst case. Returns option first min or max element.
</summary>
</member>
<member name="P:FSharpx.Collections.Heap`1.Length">
<summary>
O(n). Returns the count of elememts.
</summary>
</member>
<member name="P:FSharpx.Collections.Heap`1.IsEmpty">
<summary>
O(1). Returns true if the heap has no elements.
</summary>
</member>
<member name="P:FSharpx.Collections.Heap`1.IsDescending">
<summary>
O(1). Returns true if the heap has max element at head.
</summary>
</member>
<member name="P:FSharpx.Collections.Heap`1.Head">
<summary>
O(1) worst case. Returns the min or max element.
</summary>
</member>
<member name="M:FSharpx.Collections.Heap`1.Uncons">
<summary>
O(log n) amortized time. Returns the head element and tail.
</summary>
</member>
<member name="M:FSharpx.Collections.Heap`1.TryUncons">
<summary>
O(log n) amortized time. Returns option head element and tail.
</summary>
</member>
<member name="M:FSharpx.Collections.Heap`1.TryTail">
<summary>
O(log n) amortized time. Returns option heap of the elements trailing the head.
</summary>
</member>
<member name="M:FSharpx.Collections.Heap`1.TryMerge(FSharpx.Collections.Heap{`0})">
<summary>
O(log n) amortized time. Returns heap option from merging two heaps.
</summary>
</member>
<member name="M:FSharpx.Collections.Heap`1.Tail">
<summary>
O(log n) amortized time. Returns a new heap of the elements trailing the head.
</summary>
</member>
<member name="M:FSharpx.Collections.Heap`1.Rev">
<summary>
O(n). Returns heap reversed.
</summary>
</member>
<member name="M:FSharpx.Collections.Heap`1.Merge(FSharpx.Collections.Heap{`0})">
<summary>
O(log n) amortized time. Returns heap from merging two heaps, both must have same descending.
</summary>
</member>
<member name="M:FSharpx.Collections.Heap`1.Insert(`0)">
<summary>
O(log n) amortized time. Returns a new heap with the element inserted.
</summary>
</member>
<member name="T:FSharpx.Collections.Heap`1">
<summary>
 Heap is an ordered linear structure where the ordering is either ascending or descending. 
 &quot;head&quot; inspects the first element in the ordering, &quot;tail&quot; takes the remaining structure 
 after head, and &quot;insert&quot; places elements within the ordering. PriorityQueue is available 
 as an alternate interface.
 According to Okasaki the time complexity of the heap functions in this Heap implementation 
 (based on the &quot;pairing&quot; heap) have &quot;resisted&quot; time complexity analysis. 
</summary>
</member>
<member name="P:FSharpx.Collections.LazyList`1.Uncons">
<summary>
O(1). Returns tuple of head element and tail of the list.
</summary>
</member>
<member name="P:FSharpx.Collections.LazyList`1.TryUncons">
<summary>
O(1). Returns option tuple of head element and tail of the list.
</summary>
</member>
<member name="P:FSharpx.Collections.LazyList`1.TryTail">
<summary>
O(1). Return option the list corresponding to the remaining items in the sequence.  
 Forces the evaluation of the first cell of the list if it is not already evaluated.
</summary>
</member>
<member name="P:FSharpx.Collections.LazyList`1.TryHead">
<summary>
O(1). Return option the first element of the list.  Forces the evaluation of
 the first cell of the list if it is not already evaluated.
</summary>
</member>
<member name="P:FSharpx.Collections.LazyList`1.Tail">
<summary>
O(1). Return the list corresponding to the remaining items in the sequence.  
 Forces the evaluation of the first cell of the list if it is not already evaluated.
</summary>
</member>
<member name="P:FSharpx.Collections.LazyList`1.IsEmpty">
<summary>
O(1). Test if a list is empty.  Forces the evaluation of
 the first element of the stream if it is not already evaluated.
</summary>
</member>
<member name="P:FSharpx.Collections.LazyList`1.Head">
<summary>
O(1). Return the first element of the list.  Forces the evaluation of
 the first cell of the list if it is not already evaluated.
</summary>
</member>
<member name="M:FSharpx.Collections.LazyList`1.Length">
<summary>
O(n). Return the length of the list
</summary>
</member>
<member name="T:FSharpx.Collections.LazyList`1">
<summary>
 LazyLists are possibly-infinite, cached sequences.  See also IEnumerable/Seq for
 uncached sequences. LazyLists normally involve delayed computations without 
 side-effects.  The results of these computations are cached and evaluations will be 
 performed only once for each element of the lazy list.  In contrast, for sequences 
 (IEnumerable) recomputation happens each time an enumerator is created and the sequence 
 traversed.

 LazyLists can represent cached, potentially-infinite computations.  Because they are 
 cached they may cause memory leaks if some active code or data structure maintains a 
 live reference to the head of an infinite or very large lazy list while iterating it, 
 or if a reference is maintained after the list is no longer required.

 Lazy lists may be matched using the LazyList.Cons and LazyList.Nil active patterns. 
 These may force the computation of elements of the list.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Queue`1.Uncons">
<summary>
O(1) amortized, O(n) worst-case. Returns the first element and tail.
</summary>
</member>
<member name="P:FSharpx.Collections.Queue`1.TryUncons">
<summary>
O(1) amortized, O(n) worst-case. Returns option first element and tail.
</summary>
</member>
<member name="P:FSharpx.Collections.Queue`1.TryTail">
<summary>
O(1) amortized, O(n) worst-case. Returns option queue of the elements trailing the first element.
</summary>
</member>
<member name="P:FSharpx.Collections.Queue`1.TryHead">
<summary>
O(1). Returns option first element
</summary>
</member>
<member name="P:FSharpx.Collections.Queue`1.Tail">
<summary>
O(1) amortized, O(n) worst-case. Returns a new queue of the elements trailing the first element. (Dequeue)
</summary>
</member>
<member name="P:FSharpx.Collections.Queue`1.Length">
<summary>
O(1). Returns the count of elememts.
</summary>
</member>
<member name="P:FSharpx.Collections.Queue`1.IsEmpty">
<summary>
O(1). Returns true if the queue has no elements.
</summary>
</member>
<member name="P:FSharpx.Collections.Queue`1.Head">
<summary>
O(1). Returns the first element. (Peek)
</summary>
</member>
<member name="M:FSharpx.Collections.Queue`1.Rev">
<summary>
O(n). Returns queue reversed.
</summary>
</member>
<member name="M:FSharpx.Collections.Queue`1.Conj(`0)">
<summary>
O(1). Returns a new queue with the element added to the end. (Enqueue)
</summary>
</member>
<member name="T:FSharpx.Collections.Queue`1">
<summary>
 Queue is an ordered linear data structure where elements are added at the end (right) 
 and inspected and removed at the beginning (left). Ordering is by insertion history. 
 The qualities of the Queue structure make elements first in, first out (fifo).
 &quot;head&quot; inspects the first or left-most element in the structure, while &quot;conj&quot; 
 inserts an element at the end, or right of the structure.
 Purely functional (immutable) Queue based on Okasaki&apos;s batched queue. 
 Value and function naming standard based on consistent List-like naming: http://jackfoxy.com/semantics-and-list-like-data-structures
 Original F# implementation http://lepensemoi.free.fr/index.php/2009/12/10/batched-queue
</summary>
</member>
<member name="P:FSharpx.Collections.RandomAccessList`1.Uncons">
<summary>
 O(1). Returns tuple last element and random access list without last item  
</summary>
</member>
<member name="P:FSharpx.Collections.RandomAccessList`1.TryUncons">
<summary>
 O(1). Returns option tuple last element and random access list without last item  
</summary>
</member>
<member name="P:FSharpx.Collections.RandomAccessList`1.TryTail">
<summary>
 O(n). Returns option random access list without the last item.
</summary>
</member>
<member name="P:FSharpx.Collections.RandomAccessList`1.TryHead">
<summary>
 O(1). Returns option last element in the random access list.
</summary>
</member>
<member name="P:FSharpx.Collections.RandomAccessList`1.Tail">
<summary>
 O(n). Returns a new random access list without the last item. If the collection is empty it throws an exception.
</summary>
</member>
<member name="P:FSharpx.Collections.RandomAccessList`1.Length">
<summary>
 O(1). Returns the number of items in the random access list.
</summary>
</member>
<member name="P:FSharpx.Collections.RandomAccessList`1.Item(System.Int32)">
<summary>
 O(log32n). Returns random access list element at the index.
</summary>
</member>
<member name="P:FSharpx.Collections.RandomAccessList`1.IsEmpty">
<summary>
 O(1). Returns true if the random access list has no elements.
</summary>
</member>
<member name="P:FSharpx.Collections.RandomAccessList`1.Head">
<summary>
 O(1). Returns the last element in the random access list. If the random access list is empty it throws an exception.
</summary>
</member>
<member name="M:FSharpx.Collections.RandomAccessList`1.Update(System.Int32,`0)">
<summary>
 O(log32n). Returns a new random access list that contains the given value at the index.
</summary>
</member>
<member name="M:FSharpx.Collections.RandomAccessList`1.TryUpdate(System.Int32,`0)">
<summary>
 O(log32n). Returns option random access list that contains the given value at the index.
</summary>
</member>
<member name="M:FSharpx.Collections.RandomAccessList`1.Rev">
<summary>
O(n). Returns random access list reversed.
</summary>
</member>
<member name="M:FSharpx.Collections.RandomAccessList`1.Cons(`0)">
<summary>
 O(1). Returns a new random access list with the element added at the end.
</summary>
</member>
<member name="T:FSharpx.Collections.RandomAccessList`1">
<summary>
 RandomAccessList is an ordered linear structure implementing the List signature 
 (head, tail, cons), as well as inspection (lookup) and update (returning a new 
 immutable instance) of any element in the structure by index. Ordering is by insertion history.
 Adapted from Steffen Forkmann&apos;s F# implementation of Clojure Vector..
</summary>
</member>
<member name="P:FSharpx.Collections.Vector`1.Unconj">
<summary>
 O(1). Returns tuple last element and vector without last item  
</summary>
</member>
<member name="P:FSharpx.Collections.Vector`1.TryUnconj">
<summary>
 O(1). Returns option tuple last element and vector without last item  
</summary>
</member>
<member name="P:FSharpx.Collections.Vector`1.TryLast">
<summary>
 O(1). Returns option last element in the vector.
</summary>
</member>
<member name="P:FSharpx.Collections.Vector`1.TryInitial">
<summary>
 O(n). Returns option vector without the last item.
</summary>
</member>
<member name="P:FSharpx.Collections.Vector`1.Length">
<summary>
 O(1). Returns the number of items in the vector.
</summary>
</member>
<member name="P:FSharpx.Collections.Vector`1.Last">
<summary>
 O(1). Returns the last element in the vector. If the vector is empty it throws an exception.
</summary>
</member>
<member name="P:FSharpx.Collections.Vector`1.Item(System.Int32)">
<summary>
 O(log32n). Returns vector element at the index.
</summary>
</member>
<member name="P:FSharpx.Collections.Vector`1.IsEmpty">
<summary>
 O(1). Returns true if the vector has no elements.
</summary>
</member>
<member name="P:FSharpx.Collections.Vector`1.Initial">
<summary>
 O(n). Returns a new vector without the last item. If the collection is empty it throws an exception.
</summary>
</member>
<member name="M:FSharpx.Collections.Vector`1.Update(System.Int32,`0)">
<summary>
 O(log32n). Returns a new vector that contains the given value at the index.
</summary>
</member>
<member name="M:FSharpx.Collections.Vector`1.TryUpdate(System.Int32,`0)">
<summary>
 O(log32n). Returns option vector that contains the given value at the index.
</summary>
</member>
<member name="M:FSharpx.Collections.Vector`1.Rev">
<summary>
O(n). Returns random access list reversed.
</summary>
</member>
<member name="M:FSharpx.Collections.Vector`1.Conj(`0)">
<summary>
 O(1). Returns a new vector with the element added at the end.
</summary>
</member>
<member name="T:FSharpx.Collections.Vector`1">
<summary>
 Vector is an ordered linear structure implementing the inverse of the List signature, 
 (last, initial, conj) in place of (head, tail, cons). Indexed lookup or update 
 (returning a new immutable instance of Vector) of any element is O(log32n). Length is O(1). 
 Ordering is by insertion history.
 Original F# adaptation from the clojure implementation by Steffen Forkmann.
</summary>
</member>
<member name="M:FSharpx.Collections.ArrayModule.centralMovingAverageOfOption``1(System.Int32,Microsoft.FSharp.Core.FSharpOption{``0}[])">
<summary>
 Calculates the central moving average for the array of optional elements using n
 elements either side of the point where the mean is being calculated. If any of
 the optional elements in the averaging window are None then the average itself
 is None.
</summary>
</member>
<member name="M:FSharpx.Collections.ArrayModule.centralMovingAverage``1(System.Int32,``0[])">
<summary>
 Calculates the central moving average for the array using n elements either side
 of the point where the mean is being calculated.
</summary>
</member>
<member name="M:FSharpx.Collections.ArrayModule.centeredWindow``1(System.Int32,``0[])">
<summary>
 Returns an array of sliding windows of data drawn from the source array.
 Each window contains the n elements surrounding the current element.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.ArrayModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.ByteStringModule.append(FSharpx.Collections.ByteString,FSharpx.Collections.ByteString)">
<summary>
 append uses Buffer.BlockCopy for efficient array operations.
 Please note that a new array is created and both arrays are copied in,
 disregarding any additional bytes in the original, underlying arrays.
</summary>
</member>
<member name="M:FSharpx.Collections.ByteStringModule.cons(System.Byte,FSharpx.Collections.ByteString)">
<summary>
 cons uses Buffer.SetByte and Buffer.BlockCopy for efficient array operations.
 Please note that a new array is created and both the head and tail are copied in,
 disregarding any additional bytes in the original tail array.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.ByteStringModule.|BS|(FSharpx.Collections.ByteString)">
<summary>
 An active pattern for conveniently retrieving the properties of a ByteString.
</summary>
</member>
<member name="T:FSharpx.Collections.ByteStringModule">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.DListModule.toSeq``1(FSharpx.Collections.DList{``0})">
<summary>
O(n). Returns a seq of the DList elements.
</summary>
</member>
<member name="M:FSharpx.Collections.DListModule.toList``1(FSharpx.Collections.DList{``0})">
<summary>
O(n). Returns a list of the DList elements.
</summary>
</member>
<member name="M:FSharpx.Collections.DListModule.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
O(n). Returns a DList of the seq.
</summary>
</member>
<member name="M:FSharpx.Collections.DListModule.tryUncons``1(FSharpx.Collections.DList{``0})">
<summary>
O(log n). Returns option first element and tail.
</summary>
</member>
<member name="M:FSharpx.Collections.DListModule.uncons``1(FSharpx.Collections.DList{``0})">
<summary>
O(log n). Returns the first element and tail.
</summary>
</member>
<member name="M:FSharpx.Collections.DListModule.tryTail``1(FSharpx.Collections.DList{``0})">
<summary>
O(log n). Returns option DList of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.DListModule.tail``1(FSharpx.Collections.DList{``0})">
<summary>
O(log n). Returns a new DList of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.DListModule.conj``1(``0,FSharpx.Collections.DList{``0})">
<summary>
O(1). Returns a new DList with the element added to the end.
</summary>
</member>
<member name="M:FSharpx.Collections.DListModule.singleton``1(``0)">
<summary>
O(1). Returns DList of one elements.
</summary>
</member>
<member name="M:FSharpx.Collections.DListModule.length``1(FSharpx.Collections.DList{``0})">
<summary>
O(1). Returns the count of elememts.
</summary>
</member>
<member name="M:FSharpx.Collections.DListModule.isEmpty``1(FSharpx.Collections.DList{``0})">
<summary>
O(1). Returns true if the DList has no elements.
</summary>
</member>
<member name="M:FSharpx.Collections.DListModule.tryHead``1(FSharpx.Collections.DList{``0})">
<summary>
O(log n). Returns option first element.
</summary>
</member>
<member name="M:FSharpx.Collections.DListModule.head``1(FSharpx.Collections.DList{``0})">
<summary>
O(log n). Returns the first element.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.DListModule.foldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},FSharpx.Collections.DList{``0},``1)">
<summary>
O(n). Fold walks the DList using constant stack space. Implementation is from Norman Ramsey.
 See http://stackoverflow.com/questions/5324623/functional-o1-append-and-on-iteration-from-first-element-list-data-structure/5334068#5334068
</summary>
</member>
<member name="M:FSharpx.Collections.DListModule.empty``1">
<summary>
O(1). Returns DList of no elements.
</summary>
</member>
<member name="M:FSharpx.Collections.DListModule.cons``1(``0,FSharpx.Collections.DList{``0})">
<summary>
O(1). Returns a new DList with the element added to the beginning.
</summary>
</member>
<member name="M:FSharpx.Collections.DListModule.append``1(FSharpx.Collections.DList{``0},FSharpx.Collections.DList{``0})">
<summary>
O(1). Returns a new DList of two lists.
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.DListModule">

</member>
<member name="M:FSharpx.Collections.DequeModule.tryUncons``1(FSharpx.Collections.Deque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns option first element and tail.
</summary>
</member>
<member name="M:FSharpx.Collections.DequeModule.toSeq``1(FSharpx.Collections.Deque{``0})">
<summary>
O(n). Returns a seq of the deque elements.
</summary>
</member>
<member name="M:FSharpx.Collections.DequeModule.uncons``1(FSharpx.Collections.Deque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns the first element and tail.
</summary>
</member>
<member name="M:FSharpx.Collections.DequeModule.tryUnconj``1(FSharpx.Collections.Deque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns option init and the last element.
</summary>
</member>
<member name="M:FSharpx.Collections.DequeModule.unconj``1(FSharpx.Collections.Deque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns init and the last element.
</summary>
</member>
<member name="M:FSharpx.Collections.DequeModule.tryTail``1(FSharpx.Collections.Deque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns option deque of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.DequeModule.tail``1(FSharpx.Collections.Deque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns a new deque of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.DequeModule.singleton``1(``0)">
<summary>
O(1). Returns a deque of one element.
</summary>
</member>
<member name="M:FSharpx.Collections.DequeModule.rev``1(FSharpx.Collections.Deque{``0})">
<summary>
O(1). Returns deque reversed.
</summary>
</member>
<member name="M:FSharpx.Collections.DequeModule.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
O(n), worst case. Returns a deque of the seq.
</summary>
</member>
<member name="M:FSharpx.Collections.DequeModule.ofList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
O(n), worst case. Returns a deque of the list.
</summary>
</member>
<member name="M:FSharpx.Collections.DequeModule.ofCatLists``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
O(n), worst case. Returns a deque of the two lists concatenated.
</summary>
</member>
<member name="M:FSharpx.Collections.DequeModule.length``1(FSharpx.Collections.Deque{``0})">
<summary>
O(1). Returns the count of elememts.
</summary>
</member>
<member name="M:FSharpx.Collections.DequeModule.tryLast``1(FSharpx.Collections.Deque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns option last element.
</summary>
</member>
<member name="M:FSharpx.Collections.DequeModule.last``1(FSharpx.Collections.Deque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns the last element.
</summary>
</member>
<member name="M:FSharpx.Collections.DequeModule.isEmpty``1(FSharpx.Collections.Deque{``0})">
<summary>
O(1). Returns true if the deque has no elements.
</summary>
</member>
<member name="M:FSharpx.Collections.DequeModule.tryInitial``1(FSharpx.Collections.Deque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns option deque of the elements before the last element.
</summary>
</member>
<member name="M:FSharpx.Collections.DequeModule.initial``1(FSharpx.Collections.Deque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns a new deque of the elements before the last element.
</summary>
</member>
<member name="M:FSharpx.Collections.DequeModule.tryHead``1(FSharpx.Collections.Deque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns option first element.
</summary>
</member>
<member name="M:FSharpx.Collections.DequeModule.head``1(FSharpx.Collections.Deque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.DequeModule.foldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},FSharpx.Collections.Deque{``0},``1)">
<summary>
 O(n). Applies a function to each element of the deque, threading an accumulator argument through the computation, right to left
</summary>
</member>
<member name="M:FSharpx.Collections.DequeModule.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,FSharpx.Collections.Deque{``1})">
<summary>
 O(n). Applies a function to each element of the deque, threading an accumulator argument through the computation, left to right
</summary>
</member>
<member name="M:FSharpx.Collections.DequeModule.empty``1">
<summary>
O(1). Returns deque of no elements.
</summary>
</member>
<member name="M:FSharpx.Collections.DequeModule.cons``1(``0,FSharpx.Collections.Deque{``0})">
<summary>
O(1). Returns a new deque with the element added to the beginning.
</summary>
</member>
<member name="M:FSharpx.Collections.DequeModule.conj``1(``0,FSharpx.Collections.Deque{``0})">
<summary>
O(1). Returns a new deque with the element added to the end.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.DequeModule">

</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.DictionaryModule">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.HeapModule.tryUncons``1(FSharpx.Collections.Heap{``0})">
<summary>
O(log n) amortized time. Returns option head element and tail.
</summary>
</member>
<member name="M:FSharpx.Collections.HeapModule.uncons``1(FSharpx.Collections.Heap{``0})">
<summary>
O(log n) amortized time. Returns the head element and tail.
</summary>
</member>
<member name="M:FSharpx.Collections.HeapModule.tryTail``1(FSharpx.Collections.Heap{``0})">
<summary>
O(log n) amortized time. Returns option heap of the elements trailing the head.
</summary>
</member>
<member name="M:FSharpx.Collections.HeapModule.tail``1(FSharpx.Collections.Heap{``0})">
<summary>
O(log n) amortized time. Returns a new heap of the elements trailing the head.
</summary>
</member>
<member name="M:FSharpx.Collections.HeapModule.rev``1(FSharpx.Collections.Heap{``0})">
<summary>
O(n). Returns heap reversed.
</summary>
</member>
<member name="M:FSharpx.Collections.HeapModule.ofSeq``1(System.Boolean,System.Collections.Generic.IEnumerable{``0})">
<summary>
O(n). Returns heap from the sequence.
</summary>
</member>
<member name="M:FSharpx.Collections.HeapModule.tryMerge``1(FSharpx.Collections.Heap{``0},FSharpx.Collections.Heap{``0})">
<summary>
O(log n) amortized time. Returns heap option from merging two heaps.
</summary>
</member>
<member name="M:FSharpx.Collections.HeapModule.merge``1(FSharpx.Collections.Heap{``0},FSharpx.Collections.Heap{``0})">
<summary>
O(log n) amortized time. Returns heap from merging two heaps, both must have same descending.
</summary>
</member>
<member name="M:FSharpx.Collections.HeapModule.length``1(FSharpx.Collections.Heap{``0})">
<summary>
O(n). Returns the count of elememts.
</summary>
</member>
<member name="M:FSharpx.Collections.HeapModule.isDescending``1(FSharpx.Collections.Heap{``0})">
<summary>
O(1). Returns true if the heap has max element at head.
</summary>
</member>
<member name="M:FSharpx.Collections.HeapModule.isEmpty``1(FSharpx.Collections.Heap{``0})">
<summary>
O(1). Returns true if the heap has no elements.
</summary>
</member>
<member name="M:FSharpx.Collections.HeapModule.insert``1(``0,FSharpx.Collections.Heap{``0})">
<summary>
O(log n) amortized time. Returns a new heap with the element inserted.
</summary>
</member>
<member name="M:FSharpx.Collections.HeapModule.tryHead``1(FSharpx.Collections.Heap{``0})">
<summary>
O(1) worst case. Returns option first min or max element.
</summary>
</member>
<member name="M:FSharpx.Collections.HeapModule.head``1(FSharpx.Collections.Heap{``0})">
<summary>
O(1) worst case. Returns the min or max element.
</summary>
</member>
<member name="M:FSharpx.Collections.HeapModule.empty``1(System.Boolean)">
<summary>
O(1). Returns a empty heap.
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.HeapModule">

</member>
<member name="P:FSharpx.Collections.IPriorityQueue.IPriorityQueue`1.TryPeek">
<summary>
O(1). Returns option first element.
</summary>
</member>
<member name="P:FSharpx.Collections.IPriorityQueue.IPriorityQueue`1.Peek">
<summary>
O(1). Returns the first element.
</summary>
</member>
<member name="P:FSharpx.Collections.IPriorityQueue.IPriorityQueue`1.IsEmpty">
<summary>
O(1). Returns true if the queue has no elements.
</summary>
</member>
<member name="M:FSharpx.Collections.IPriorityQueue.IPriorityQueue`1.TryPop">
<summary>
O(log n) amortized time. Returns the option first element and tail.
</summary>
</member>
<member name="M:FSharpx.Collections.IPriorityQueue.IPriorityQueue`1.Pop">
<summary>
O(log n) amortized time. Returns the first element and tail.
</summary>
</member>
<member name="M:FSharpx.Collections.IPriorityQueue.IPriorityQueue`1.Insert(`0)">
<summary>
O(log n) amortized time. Returns a new queue with the element added to the end.
</summary>
</member>
<member name="T:FSharpx.Collections.IPriorityQueue.IPriorityQueue`1">
<summary>
 Priority queue is like a queue or stack data structure, but with an ascending or descending 
 ordering of the elements. Depending on the ordering peek retrieves either the highest or lowest 
 ordered element in the queue.
</summary>
</member>
<member name="T:FSharpx.Collections.IPriorityQueue">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.LazyListModule.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
O(1). Build a new collection from the given enumerable object
</summary>
</member>
<member name="M:FSharpx.Collections.LazyListModule.toSeq``1(FSharpx.Collections.LazyList{``0})">
<summary>
O(n). Return a view of the collection as an enumerable object
</summary>
</member>
<member name="M:FSharpx.Collections.LazyListModule.toList``1(FSharpx.Collections.LazyList{``0})">
<summary>
O(n). Build a non-lazy list from the given collection. This function will eagerly evaluate all of the 
 list (and thus may not terminate). 
</summary>
</member>
<member name="M:FSharpx.Collections.LazyListModule.ofList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
O(1). Build a collection from the given list. This function will eagerly evaluate all of the 
 list (and thus may not terminate). 
</summary>
</member>
<member name="M:FSharpx.Collections.LazyListModule.toArray``1(FSharpx.Collections.LazyList{``0})">
<summary>
O(n). Build an array from the given collection
</summary>
</member>
<member name="M:FSharpx.Collections.LazyListModule.ofArray``1(``0[])">
<summary>
O(1). Build a collection from the given array. This function will eagerly evaluate all of the 
 list (and thus may not terminate). 
</summary>
</member>
<member name="M:FSharpx.Collections.LazyListModule.map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},FSharpx.Collections.LazyList{``0},FSharpx.Collections.LazyList{``1})">
<summary>
O(1). Build a new collection whose elements are the results of applying the given function
 to the corresponding elements of the two collections pairwise.
</summary>
</member>
<member name="M:FSharpx.Collections.LazyListModule.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharpx.Collections.LazyList{``0})">
<summary>
O(1). Build a new collection whose elements are the results of applying the given function
 to each of the elements of the collection.
</summary>
</member>
<member name="M:FSharpx.Collections.LazyListModule.scan``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,FSharpx.Collections.LazyList{``1})">
<summary>
O(1). Return a new list consisting of the results of applying the given accumulating function
 to successive elements of the list
</summary>
</member>
<member name="M:FSharpx.Collections.LazyListModule.iter``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},FSharpx.Collections.LazyList{``0})">
<summary>
O(n). Apply the given function to each element of the collection. 
</summary>
</member>
<member name="M:FSharpx.Collections.LazyListModule.filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},FSharpx.Collections.LazyList{``0})">
<summary>
O(1). Return a new collection which on consumption will consist of only the elements of the collection
 for which the given predicate returns &quot;true&quot;
</summary>
</member>
<member name="M:FSharpx.Collections.LazyListModule.concat``1(FSharpx.Collections.LazyList{FSharpx.Collections.LazyList{``0}})">
<summary>
O(1). Return the list which contains on demand the list of elements of the list of lazy lists.
</summary>
</member>
<member name="M:FSharpx.Collections.LazyListModule.zip``2(FSharpx.Collections.LazyList{``0},FSharpx.Collections.LazyList{``1})">
<summary>
O(1). Return the list which contains on demand the pair of elements of the first and second list
</summary>
</member>
<member name="M:FSharpx.Collections.LazyListModule.append``1(FSharpx.Collections.LazyList{``0},FSharpx.Collections.LazyList{``0})">
<summary>
O(1). Return the list which contains on demand the elements of the first list followed
 by the elements of the second list
</summary>
</member>
<member name="M:FSharpx.Collections.LazyListModule.unfold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{System.Tuple{``1,``0}}},``0)">
<summary>
O(1). Return a list that contains the elements returned by the given computation.
 The given computation is not executed until the first element on the list is
 consumed.  The given argument is passed to the computation.  Subsequent elements
 in the list are generated by again applying the residual &apos;b to the computation.
</summary>
</member>
<member name="M:FSharpx.Collections.LazyListModule.delayed``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,FSharpx.Collections.LazyList{``0}})">
<summary>
O(1). Return a list that is in effect the list returned by the given computation.
 The given computation is not executed until the first element on the list is
 consumed.
</summary>
</member>
<member name="M:FSharpx.Collections.LazyListModule.repeat``1(``0)">
<summary>
O(1). Return the list which on consumption will consist of an infinite sequence of 
 the given item
</summary>
</member>
<member name="M:FSharpx.Collections.LazyListModule.consDelayed``1(``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,FSharpx.Collections.LazyList{``0}})">
<summary>
O(1). Return a new list which on consumption contains the given item 
 followed by the list returned by the given computation.  The 
</summary>
</member>
<member name="M:FSharpx.Collections.LazyListModule.cons``1(``0,FSharpx.Collections.LazyList{``0})">
<summary>
O(1). Return a new list which contains the given item followed by the
 given list.
</summary>
</member>
<member name="M:FSharpx.Collections.LazyListModule.length``1(FSharpx.Collections.LazyList{``0})">
<summary>
O(n). Return the length of the list
</summary>
</member>
<member name="M:FSharpx.Collections.LazyListModule.empty``1">
<summary>
O(1). Evaluates to the list that contains no items
</summary>
</member>
<member name="M:FSharpx.Collections.LazyListModule.find``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},FSharpx.Collections.LazyList{``0})">
<summary>
O(n), worst case. Return the first element for which the given function returns &lt;c&gt;true&lt;/c&gt;.
 Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if no such element exists.
</summary>
</member>
<member name="M:FSharpx.Collections.LazyListModule.tryFind``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},FSharpx.Collections.LazyList{``0})">
<summary>
O(n), worst case. Apply the given function to successive elements of the list, returning the first
 result where function returns &lt;c&gt;Some(x)&lt;/c&gt; for some x. If the function never returns
 true, &apos;None&apos; is returned.
</summary>
</member>
<member name="M:FSharpx.Collections.LazyListModule.mapAccum``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``0,``2}}},``0,FSharpx.Collections.LazyList{``1})">
<summary>
O(n). Behaves like a combination of map and fold; 
 it applies a function to each element of a list, 
 passing an accumulating parameter from left to right, 
 and returning a final value of this accumulator together with the new list.
</summary>
</member>
<member name="M:FSharpx.Collections.LazyListModule.trySkip``1(System.Int32,FSharpx.Collections.LazyList{``0})">
<summary>
O(n), where n is count. Return option the list which skips the first &apos;n&apos; elements of 
 the input list.  
</summary>
</member>
<member name="M:FSharpx.Collections.LazyListModule.skip``1(System.Int32,FSharpx.Collections.LazyList{``0})">
<summary>
O(n), where n is count. Return the list which on consumption will skip the first &apos;n&apos; elements of 
 the input list.  
</summary>
</member>
<member name="M:FSharpx.Collections.LazyListModule.tryTake``1(System.Int32,FSharpx.Collections.LazyList{``0})">
<summary>
O(n), where n is count. Return the list which on consumption will consist of at most &apos;n&apos; elements of 
 the input list.  
</summary>
</member>
<member name="M:FSharpx.Collections.LazyListModule.take``1(System.Int32,FSharpx.Collections.LazyList{``0})">
<summary>
O(n), where n is count. Return the list which on consumption will consist of at most &apos;n&apos; elements of 
 the input list.  
</summary>
</member>
<member name="M:FSharpx.Collections.LazyListModule.tryUncons``1(FSharpx.Collections.LazyList{``0})">
<summary>
O(1). Returns option tuple of head element and tail of the list.
</summary>
</member>
<member name="M:FSharpx.Collections.LazyListModule.uncons``1(FSharpx.Collections.LazyList{``0})">
<summary>
O(1). Returns tuple of head element and tail of the list.
</summary>
</member>
<member name="M:FSharpx.Collections.LazyListModule.tryTail``1(FSharpx.Collections.LazyList{``0})">
<summary>
O(1). Return option the list corresponding to the remaining items in the sequence.  
 Forces the evaluation of the first cell of the list if it is not already evaluated.
</summary>
</member>
<member name="M:FSharpx.Collections.LazyListModule.tail``1(FSharpx.Collections.LazyList{``0})">
<summary>
O(1). Return the list corresponding to the remaining items in the sequence.  
 Forces the evaluation of the first cell of the list if it is not already evaluated.
</summary>
</member>
<member name="M:FSharpx.Collections.LazyListModule.tryHead``1(FSharpx.Collections.LazyList{``0})">
<summary>
O(1). Return option the first element of the list.  Forces the evaluation of
 the first cell of the list if it is not already evaluated.
</summary>
</member>
<member name="M:FSharpx.Collections.LazyListModule.head``1(FSharpx.Collections.LazyList{``0})">
<summary>
O(1). Return the first element of the list.  Forces the evaluation of
 the first cell of the list if it is not already evaluated.
</summary>
</member>
<member name="M:FSharpx.Collections.LazyListModule.isEmpty``1(FSharpx.Collections.LazyList{``0})">
<summary>
O(1). Test if a list is empty.  Forces the evaluation of
 the first element of the stream if it is not already evaluated.
</summary>
</member>
<member name="T:FSharpx.Collections.LazyListModule">

</member>
<member name="M:FSharpx.Collections.List.monoid``1">
<summary>
 List monoid
</summary>
</member>
<member name="M:FSharpx.Collections.List.merge``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Merges two sequences by the default comparer for &apos;T
</summary>
</member>
<member name="M:FSharpx.Collections.List.mergeBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Merges to sequences using the given function to transform the elements for comparision
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.List.mapAccum``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``0,``2}}},``0,Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Behaves like a combination of map and fold; 
 it applies a function to each element of a list, 
 passing an accumulating parameter from left to right, 
 and returning a final value of this accumulator together with the new list.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.List.cons``1(``0,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Curried cons
</summary>
</member>
<member name="T:FSharpx.Collections.List">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Map.keys``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Retrieves the keys from a Map    
</summary>
</member>
<member name="M:FSharpx.Collections.Map.values``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Retrieves the values from a Map
</summary>
</member>
<member name="M:FSharpx.Collections.Map.removeMany``2(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Allows to remove many keys from a Map
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Map.union``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Combines the two Maps into a single Map
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Map.updateWith``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``0}},``1,Microsoft.FSharp.Collections.FSharpMap{``1,``0})">
 <summary>
 <code>update f k map</code> updates the value <code>x</code> at key <code>k</code> (if it is in the map). 
 If <code>f x</code> is <code>None</code>, the element is deleted. 
 If it is <code>Some y</code>, the key is bound to the new value <code>y</code>.
 </summary>
</member>
<member name="M:FSharpx.Collections.Map.insertWith``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``1,``0,Microsoft.FSharp.Collections.FSharpMap{``1,``0})">
 <summary>
 <code>insertWith f key value mp</code> will insert the pair <code>(key, value)</code> into <code>mp</code> if <code>key</code> does not exist in the map. 
 If the key does exist, the function will insert <code>f new_value old_value</code>.
 </summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.Map">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.NameValueCollectionModule.ofSeq(System.Collections.Generic.IEnumerable{System.Tuple{System.String,System.String}})">
 <summary>
 Creates a <see cref="NameValueCollection"/> from a list of key-value pairs
 </summary>
 <param name="l"></param>
</member>
<member name="M:FSharpx.Collections.NameValueCollectionModule.toList(System.Collections.Specialized.NameValueCollection)">
 <summary>
 Returns a <see cref="NameValueCollection"/> as a list of key-value pairs.
 Note that keys may be duplicated.
 </summary>
 <param name="a"></param>
</member>
<member name="M:FSharpx.Collections.NameValueCollectionModule.ToEnumerable(System.Collections.Specialized.NameValueCollection)">
 <summary>
 Returns a <see cref="NameValueCollection"/> as a sequence of key-value pairs.
 Note that keys may be duplicated.
 </summary>
 <param name="a"></param>
</member>
<member name="M:FSharpx.Collections.NameValueCollectionModule.ToArray(System.Collections.Specialized.NameValueCollection)">
 <summary>
 Returns a <see cref="NameValueCollection"/> as an array of key-value pairs.
 Note that keys may be duplicated.
 </summary>
 <param name="a"></param>
</member>
<member name="M:FSharpx.Collections.NameValueCollectionModule.add(System.String,System.String,System.Collections.Specialized.NameValueCollection)">
<summary>
 Adds an element to a copy of an existing NameValueCollection
</summary>
</member>
<member name="M:FSharpx.Collections.NameValueCollectionModule.addInPlace(System.Collections.Specialized.NameValueCollection,System.String,System.String)">
 <summary>
 In-place add of a key-value pair to a <see cref="NameValueCollection"/>
 </summary>
 <param name="x"></param>
 <param name="a"></param>
 <param name="b"></param>
</member>
<member name="M:FSharpx.Collections.NameValueCollectionModule.Concat(System.Collections.Specialized.NameValueCollection,System.Collections.Specialized.NameValueCollection)">
 <summary>
 Returns a new <see cref="NameValueCollection"/> with the concatenation of two <see cref="NameValueCollection"/>s
 </summary>
 <param name="a"></param>
 <param name="b"></param>
</member>
<member name="T:FSharpx.Collections.NameValueCollectionModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.NonEmptyList">

</member>
<member name="M:FSharpx.Collections.PriorityQueue.pop``1(FSharpx.Collections.IPriorityQueue.IPriorityQueue{``0})">
<summary>
O(log n) amortized time. Returns the first element and tail.
</summary>
</member>
<member name="M:FSharpx.Collections.PriorityQueue.tryPop``1(FSharpx.Collections.IPriorityQueue.IPriorityQueue{``0})">
<summary>
O(log n) amortized time. Returns the option first element and tail.
</summary>
</member>
<member name="M:FSharpx.Collections.PriorityQueue.peek``1(FSharpx.Collections.IPriorityQueue.IPriorityQueue{``0})">
<summary>
O(1). Returns the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.PriorityQueue.tryPeek``1(FSharpx.Collections.IPriorityQueue.IPriorityQueue{``0})">
<summary>
O(1). Returns option first element.
</summary>
</member>
<member name="M:FSharpx.Collections.PriorityQueue.insert``1(``0,FSharpx.Collections.IPriorityQueue.IPriorityQueue{``0})">
<summary>
O(log n) amortized time. Returns a new queue with the element added to the end.
</summary>
</member>
<member name="M:FSharpx.Collections.PriorityQueue.isEmpty``1(FSharpx.Collections.IPriorityQueue.IPriorityQueue{``0})">
<summary>
O(1). Returns true if the queue has no elements.
</summary>
</member>
<member name="M:FSharpx.Collections.PriorityQueue.empty``1(System.Boolean)">
<summary>
O(1). Returns a empty queue, with indicated ordering.
</summary>
</member>
<member name="T:FSharpx.Collections.PriorityQueue">

</member>
<member name="M:FSharpx.Collections.QueueModule.tryUncons``1(FSharpx.Collections.Queue{``0})">
<summary>
O(1) amortized, O(n) worst-case. Returns option first element and tail.
</summary>
</member>
<member name="M:FSharpx.Collections.QueueModule.uncons``1(FSharpx.Collections.Queue{``0})">
<summary>
O(1) amortized, O(n) worst-case. Returns the first element and tail.
</summary>
</member>
<member name="M:FSharpx.Collections.QueueModule.tryTail``1(FSharpx.Collections.Queue{``0})">
<summary>
O(1) amortized, O(n) worst-case. Returns option queue of the elements trailing the first element
</summary>
</member>
<member name="M:FSharpx.Collections.QueueModule.tail``1(FSharpx.Collections.Queue{``0})">
<summary>
O(1) amortized, O(n) worst-case. Returns a new queue of the elements trailing the first element. (dequeue)
</summary>
</member>
<member name="M:FSharpx.Collections.QueueModule.rev``1(FSharpx.Collections.Queue{``0})">
<summary>
O(n). Returns queue reversed.
</summary>
</member>
<member name="M:FSharpx.Collections.QueueModule.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
O(n). Returns a queue of the seq.
</summary>
</member>
<member name="M:FSharpx.Collections.QueueModule.ofList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
O(1). Returns a queue of the list
</summary>
</member>
<member name="M:FSharpx.Collections.QueueModule.length``1(FSharpx.Collections.Queue{``0})">
<summary>
O(1). Returns the count of elememts.
</summary>
</member>
<member name="M:FSharpx.Collections.QueueModule.isEmpty``1(FSharpx.Collections.Queue{``0})">
<summary>
O(1). Returns true if the queue has no elements.
</summary>
</member>
<member name="M:FSharpx.Collections.QueueModule.tryHead``1(FSharpx.Collections.Queue{``0})">
<summary>
O(1). Returns option first element.
</summary>
</member>
<member name="M:FSharpx.Collections.QueueModule.head``1(FSharpx.Collections.Queue{``0})">
<summary>
O(1). Returns the first element. (peek)
</summary>
</member>
<member name="M:FSharpx.Collections.QueueModule.foldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},FSharpx.Collections.Queue{``0},``1)">
<summary>
O(n). Applies a function to each element of the queue, threading an accumulator argument through the computation, right to left.
</summary>
</member>
<member name="M:FSharpx.Collections.QueueModule.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,FSharpx.Collections.Queue{``1})">
<summary>
O(n). Applies a function to each element of the queue, threading an accumulator argument through the computation, left to right.
</summary>
</member>
<member name="M:FSharpx.Collections.QueueModule.empty``1">
<summary>
O(1). Returns queue of no elements.
</summary>
</member>
<member name="M:FSharpx.Collections.QueueModule.conj``1(``0,FSharpx.Collections.Queue{``0})">
<summary>
O(1). Returns a new queue with the element added to the end. (enqueue)
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.QueueModule">

</member>
<member name="M:FSharpx.Collections.RandomAccessListModule.tryUpdate``1(System.Int32,``0,FSharpx.Collections.RandomAccessList{``0})">
<summary>
 O(log32n). Returns option random access list that contains the given value at the index. 
</summary>
</member>
<member name="M:FSharpx.Collections.RandomAccessListModule.update``1(System.Int32,``0,FSharpx.Collections.RandomAccessList{``0})">
<summary>
 O(log32n). Returns a new random access list that contains the given value at the index. 
</summary>
</member>
<member name="M:FSharpx.Collections.RandomAccessListModule.tryUncons``1(FSharpx.Collections.RandomAccessList{``0})">
<summary>
 O(1). Returns option tuple last element and random access list without last item  
</summary>
</member>
<member name="M:FSharpx.Collections.RandomAccessListModule.uncons``1(FSharpx.Collections.RandomAccessList{``0})">
<summary>
 O(1). Returns tuple last element and random access list without last item
</summary>
</member>
<member name="M:FSharpx.Collections.RandomAccessListModule.tryTail``1(FSharpx.Collections.RandomAccessList{``0})">
<summary>
 O(n). Returns option random access list without the last item.
</summary>
</member>
<member name="M:FSharpx.Collections.RandomAccessListModule.tail``1(FSharpx.Collections.RandomAccessList{``0})">
<summary>
 O(n). Returns a new random access list without the last item. If the collection is empty it throws an exception.
</summary>
</member>
<member name="M:FSharpx.Collections.RandomAccessListModule.rev``1(FSharpx.Collections.RandomAccessList{``0})">
<summary>
O(n). Returns new random access list reversed.
</summary>
</member>
<member name="M:FSharpx.Collections.RandomAccessListModule.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 O(n). Returns a random access list of the seq.
</summary>
</member>
<member name="M:FSharpx.Collections.RandomAccessListModule.tryNth``1(System.Int32,FSharpx.Collections.RandomAccessList{``0})">
<summary>
 O(log32n). Returns option value at the index. 
</summary>
</member>
<member name="M:FSharpx.Collections.RandomAccessListModule.nth``1(System.Int32,FSharpx.Collections.RandomAccessList{``0})">
<summary>
 O(log32n). Returns the value at the index.
</summary>
</member>
<member name="M:FSharpx.Collections.RandomAccessListModule.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharpx.Collections.RandomAccessList{``0})">
<summary>
 O(n). Returns a random access list whose elements are the results of applying the supplied function to each of the elements of a supplied random access list.
</summary>
</member>
<member name="M:FSharpx.Collections.RandomAccessListModule.length``1(FSharpx.Collections.RandomAccessList{``0})">
<summary>
 O(1). Returns the number of items in the random access list.
</summary>
</member>
<member name="M:FSharpx.Collections.RandomAccessListModule.tryHead``1(FSharpx.Collections.RandomAccessList{``0})">
<summary>
 O(1). Returns option last element in the random access list.
</summary>
</member>
<member name="M:FSharpx.Collections.RandomAccessListModule.head``1(FSharpx.Collections.RandomAccessList{``0})">
<summary>
 O(1). Returns the last element in the random access list. If the random access list is empty it throws an exception.
</summary>
</member>
<member name="M:FSharpx.Collections.RandomAccessListModule.isEmpty``1(FSharpx.Collections.RandomAccessList{``0})">
<summary>
 O(1). Returns true if the random access list has no elements.
</summary>
</member>
<member name="M:FSharpx.Collections.RandomAccessListModule.init``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
<summary>
 O(n). Returns a random access list of the supplied length using the supplied function operating on the index. 
</summary>
</member>
<member name="M:FSharpx.Collections.RandomAccessListModule.foldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},FSharpx.Collections.RandomAccessList{``0},``1)">
<summary>
 O(n). Returns a state from the supplied state and a function operating from right to left.
</summary>
</member>
<member name="M:FSharpx.Collections.RandomAccessListModule.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,FSharpx.Collections.RandomAccessList{``1})">
<summary>
 O(n). Returns a state from the supplied state and a function operating from left to right.
</summary>
</member>
<member name="M:FSharpx.Collections.RandomAccessListModule.empty``1">
<summary>
O(1). Returns random access list of no elements.
</summary>
</member>
<member name="M:FSharpx.Collections.RandomAccessListModule.cons``1(``0,FSharpx.Collections.RandomAccessList{``0})">
<summary>
 O(1). Returns a new random access list with the element added at the end.   
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.RandomAccessListModule">

</member>
<member name="M:FSharpx.Collections.Seq.page``1(System.Int32,System.Int32,System.Collections.Generic.IEnumerable{``0})">
<summary>
 Pages the underlying sequence
</summary>
</member>
<member name="M:FSharpx.Collections.Seq.grow``1(System.Int32)">
<summary>
 Replicates each element in the seq n-times
</summary>
</member>
<member name="M:FSharpx.Collections.Seq.combine``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
<summary>
 Creates a new collection whose elements are the results of applying the given function to the corresponding pairs of elements from the two sequences. 
 Unlike Seq.map2, if one input sequence is shorter than the other then the remaining elements of the longer sequence are not ignored, they are yielded at the end of the resulting sequence.
</summary>
</member>
<member name="M:FSharpx.Collections.Seq.contract``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
<summary>
 Contracts a seq selecting every n values
</summary>
</member>
<member name="M:FSharpx.Collections.Seq.repeat``1(``0)">
<summary>
 Creates an infinite sequence of the given value
</summary>
</member>
<member name="M:FSharpx.Collections.Seq.skipNoFail``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
<summary>
 The same as Seq.skip except it returns empty if the sequence is empty or does not have enough elements.
 Alias for Enumerable.Skip
</summary>
</member>
<member name="M:FSharpx.Collections.Seq.tryNth``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
<summary>
 The same as Seq.nth except returns None if the sequence is empty or does not have enough elements
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Seq.tryHead``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 A safe version of seq head
</summary>
</member>
<member name="M:FSharpx.Collections.Seq.asCircularWithBreak``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates a infinite sequences of the given values returning None everytime the given seq is exhausted
</summary>
</member>
<member name="M:FSharpx.Collections.Seq.asCircularOnLoop``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates a infinite sequences of the given values, executing the given function everytime the given seq is exhausted
</summary>
</member>
<member name="M:FSharpx.Collections.Seq.asCircular``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates a infinite sequences of the given values
</summary>
</member>
<member name="M:FSharpx.Collections.Seq.ofStreamByChunk(System.Int32,System.IO.Stream)">
<summary>
 Converts a stream into a seq of byte[] where the array is of the length given
 Note: the last chunk maybe less than the given chunk size
</summary>
</member>
<member name="M:FSharpx.Collections.Seq.ofStreamByByte(System.IO.Stream)">
<summary>
 Converts a Stream into a sequence of bytes
</summary>
</member>
<member name="M:FSharpx.Collections.Seq.ofStreamReader(System.IO.StreamReader)">
<summary>
 Converts a streamReader into a seq yielding on each line
</summary>
</member>
<member name="M:FSharpx.Collections.Seq.splitAt``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
<summary>
 Splits a sequences at the given index
</summary>
</member>
<member name="M:FSharpx.Collections.Seq.tryAverage``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 The same as Seq.average except will return None if the seq is empty
</summary>
</member>
<member name="M:FSharpx.Collections.Seq.iterBreak``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Will iterate the current sequence until the given predicate is statisfied
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Seq.tryFindWithIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Returns the first element (with its index) for which the given function returns true.
 Return None if no such element exists.
 </summary>
 <param name="pred">Predicate</param>
 <param name="l">Sequence</param>
</member>
<member name="M:FSharpx.Collections.Seq.index``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Adds an index to a sequence
 </summary>
 <param name="a"></param>
</member>
<member name="T:FSharpx.Collections.Seq">

</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.Set">

</member>
<member name="M:FSharpx.Collections.VectorModule.windowSeq``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
<summary>
 O(n). Returns a vector of vectors of given length from the seq. Result may be a jagged vector.
</summary>
</member>
<member name="M:FSharpx.Collections.VectorModule.tryUpdateNth``1(System.Int32,System.Int32,``0,FSharpx.Collections.Vector{FSharpx.Collections.Vector{``0}})">
<summary>
 O(log32(m,n)). Returns option vector that contains the given value at the indices. 
</summary>
</member>
<member name="M:FSharpx.Collections.VectorModule.tryUpdate``1(System.Int32,``0,FSharpx.Collections.Vector{``0})">
<summary>
 O(log32n). Returns option vector that contains the given value at the index. 
</summary>
</member>
<member name="M:FSharpx.Collections.VectorModule.updateNth``1(System.Int32,System.Int32,``0,FSharpx.Collections.Vector{FSharpx.Collections.Vector{``0}})">
<summary>
 O(log32(m,n)). Returns a new vector of vectors that contains the given value at the indices. 
</summary>
</member>
<member name="M:FSharpx.Collections.VectorModule.update``1(System.Int32,``0,FSharpx.Collections.Vector{``0})">
<summary>
 O(log32n). Returns a new vector that contains the given value at the index. 
</summary>
</member>
<member name="M:FSharpx.Collections.VectorModule.tryUnconj``1(FSharpx.Collections.Vector{``0})">
<summary>
 O(1). Returns option tuple last element and vector without last item  
</summary>
</member>
<member name="M:FSharpx.Collections.VectorModule.unconj``1(FSharpx.Collections.Vector{``0})">
<summary>
 O(1). Returns tuple last element and vector without last item
</summary>
</member>
<member name="M:FSharpx.Collections.VectorModule.singleton``1(``0)">
<summary>
 O(1). Returns a new vector of one element.   
</summary>
</member>
<member name="M:FSharpx.Collections.VectorModule.rev``1(FSharpx.Collections.Vector{``0})">
<summary>
O(n). Returns vector reversed.
</summary>
</member>
<member name="M:FSharpx.Collections.VectorModule.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 O(n). Returns a vector of the seq.
</summary>
</member>
<member name="M:FSharpx.Collections.VectorModule.tryNthNth``1(System.Int32,System.Int32,FSharpx.Collections.Vector{FSharpx.Collections.Vector{``0}})">
<summary>
 O(log32(m,n)). Returns option value at the indices. 
</summary>
</member>
<member name="M:FSharpx.Collections.VectorModule.tryNth``1(System.Int32,FSharpx.Collections.Vector{``0})">
<summary>
 O(log32n). Returns option value at the index. 
</summary>
</member>
<member name="M:FSharpx.Collections.VectorModule.nthNth``1(System.Int32,System.Int32,FSharpx.Collections.Vector{FSharpx.Collections.Vector{``0}})">
<summary>
 O(log32(m,n)). Returns the value at the  outer index, inner index. If either index is out of bounds it throws an exception.
</summary>
</member>
<member name="M:FSharpx.Collections.VectorModule.nth``1(System.Int32,FSharpx.Collections.Vector{``0})">
<summary>
 O(log32n). Returns the value at the index. If the index is out of bounds it throws an exception.
</summary>
</member>
<member name="M:FSharpx.Collections.VectorModule.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharpx.Collections.Vector{``0})">
<summary>
 O(n). Returns a vector whose elements are the results of applying the supplied function to each of the elements of a supplied vector.
</summary>
</member>
<member name="M:FSharpx.Collections.VectorModule.length``1(FSharpx.Collections.Vector{``0})">
<summary>
 O(1). Returns the number of items in the vector.
</summary>
</member>
<member name="M:FSharpx.Collections.VectorModule.tryLast``1(FSharpx.Collections.Vector{``0})">
<summary>
 O(1). Returns option last element in the vector.
</summary>
</member>
<member name="M:FSharpx.Collections.VectorModule.last``1(FSharpx.Collections.Vector{``0})">
<summary>
 O(1). Returns the last element in the vector. If the vector is empty it throws an exception.
</summary>
</member>
<member name="M:FSharpx.Collections.VectorModule.isEmpty``1(FSharpx.Collections.Vector{``0})">
<summary>
 O(1). Returns true if the vector has no elements.
</summary>
</member>
<member name="M:FSharpx.Collections.VectorModule.tryInitial``1(FSharpx.Collections.Vector{``0})">
<summary>
 O(n). Returns option vector without the last item.
</summary>
</member>
<member name="M:FSharpx.Collections.VectorModule.initial``1(FSharpx.Collections.Vector{``0})">
<summary>
 O(n). Returns a new vector without the last item. If the collection is empty it throws an exception.
</summary>
</member>
<member name="M:FSharpx.Collections.VectorModule.init``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
<summary>
 O(n). Returns a vector of the supplied length using the supplied function operating on the index. 
</summary>
</member>
<member name="M:FSharpx.Collections.VectorModule.foldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},FSharpx.Collections.Vector{``0},``1)">
<summary>
 O(n). Returns a state from the supplied state and a function operating from right to left.
</summary>
</member>
<member name="M:FSharpx.Collections.VectorModule.flatten``1(FSharpx.Collections.Vector{FSharpx.Collections.Vector{``0}})">
<summary>
 O(m,n). Returns a seq from a vector of vectors.
</summary>
</member>
<member name="M:FSharpx.Collections.VectorModule.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,FSharpx.Collections.Vector{``1})">
<summary>
 O(n). Returns a state from the supplied state and a function operating from left to right.
</summary>
</member>
<member name="M:FSharpx.Collections.VectorModule.empty``1">
<summary>
O(1). Returns vector of no elements.
</summary>
</member>
<member name="M:FSharpx.Collections.VectorModule.conj``1(``0,FSharpx.Collections.Vector{``0})">
<summary>
 O(1). Returns a new vector with the element added at the end.   
</summary>
</member>
<member name="M:FSharpx.Collections.VectorModule.append``1(FSharpx.Collections.Vector{``0},FSharpx.Collections.Vector{``0})">
<summary>
 O(n). Returns a new vector with the elements of the second vector added at the end.
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.VectorModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.ContinuationModule.op_LessEqualsLess``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``1,``2},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``2},``2}}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.ContinuationModule.op_GreaterEqualsGreater``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``1,``2},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``2},``2}}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``3,``2},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``2},``2}}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.ContinuationModule.op_GreaterGreaterDot``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``1},``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``1},``1}})">
<summary>
 Sequentially compose two continuation actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.ContinuationModule.op_LessMultiply``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``1},``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``1},``1}})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.ContinuationModule.op_MultiplyGreater``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``1},``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``1},``1}})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.ContinuationModule.lift2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``3},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``3},``3}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``1,``3},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``3},``3}})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.ContinuationModule.op_LessBangGreater``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``2},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``2},``2}})">
<summary>
 Infix map
</summary>
</member>
<member name="M:FSharpx.ContinuationModule.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``2},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``2},``2}})">
<summary>
 Transforms a Cont value by using a specified mapping function.
</summary>
</member>
<member name="M:FSharpx.ContinuationModule.ap``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``1},``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``2},``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``1},``1}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.ContinuationModule.op_LessMultiplyGreater``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``2},``2}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``2},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``2},``2}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.ContinuationModule.op_EqualsLessLess``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``1,``2},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``2},``2}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``2},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``2},``2}})">
<summary>
 Flipped &gt;&gt;=
</summary>
</member>
<member name="M:FSharpx.ContinuationModule.op_GreaterGreaterEquals``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``1},``1}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``1},``1}}})">
<summary>
 Sequentially compose two actions, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:FSharpx.ContinuationModule.returnM``2(``0)">
<summary>
 Inject a value into the Cont type
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.ContinuationModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Core.AssemblyInfo">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.AltBinRndAccList`1.Uncons">
<summary>
O(log n). Returns the first element and tail.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.AltBinRndAccList`1.TryUncons">
<summary>
O(log n). Returns the option first element and tail.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.AltBinRndAccList`1.TryGetTail">
<summary>
O(log n). Returns a option random access list of the elements trailing the first element.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.AltBinRndAccList`1.Tail">
<summary>
O(log n). Returns a new random access list of the elements trailing the first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.AltBinRndAccList`1.IsEmpty">
<summary>
O(1). Returns true if the random access list has no elements.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.AltBinRndAccList`1.Head">
<summary>
O(log n). Returns the first element.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.AltBinRndAccList`1.Update(System.Int32,`0)">
<summary>
O(log n). Returns random access list with element updated by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.AltBinRndAccList`1.TryUpdate(System.Int32,`0)">
<summary>
O(log n). Returns option random access list with element updated by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.AltBinRndAccList`1.TryRemove(System.Int32)">
<summary>
O(n). Returns option random access list with element removed by index.
</summary>
</member>
<member name="M:FSharpx.DataStructures.AltBinRndAccList`1.TryLookup(System.Int32)">
<summary>
O(log n). Returns option element by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.AltBinRndAccList`1.TryGetHead">
<summary>
O(log n). Returns option first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.AltBinRndAccList`1.Rev">
<summary>
O(n). Returns random access list reversed.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.AltBinRndAccList`1.Remove(System.Int32)">
<summary>
O(n). Returns random access list with element removed by index.
</summary>
</member>
<member name="M:FSharpx.DataStructures.AltBinRndAccList`1.Lookup(System.Int32)">
<summary>
O(log n). Returns element by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.AltBinRndAccList`1.Length">
<summary>
O(log n). Returns the count of elememts.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.AltBinRndAccList`1.Cons(`0)">
<summary>
O(log n). Returns a new random access list with the element added to the beginning.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BankersDeque`1.Unsnoc">
<summary>
O(1), amortized. Returns init and the last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BankersDeque`1.Uncons">
<summary>
O(1), amortized. Returns the first element and tail.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BankersDeque`1.TryUnsnoc">
<summary>
O(1), amortized. Returns option init and the last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BankersDeque`1.TryUncons">
<summary>
O(1), amortized. Returns option first element and tail.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BankersDeque`1.TryGetTail">
<summary>
O(1), amortized. Returns option deque of the elements trailing the first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BankersDeque`1.TryGetLast">
<summary>
O(1), amortized. Returns option last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BankersDeque`1.TryGetInit">
<summary>
O(1), amortized. Returns option deque of the elements before the last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BankersDeque`1.TryGetHead">
<summary>
O(1), amortized. Returns option first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BankersDeque`1.Tail">
<summary>
O(1), amortized. Returns a new deque of the elements trailing the first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BankersDeque`1.Rev">
<summary>
O(1). Returns deque reversed.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BankersDeque`1.Length">
<summary>
O(1). Returns the count of elememts.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BankersDeque`1.Last">
<summary>
O(1), amortized. Returns the last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BankersDeque`1.IsEmpty">
<summary>
O(1). Returns true if the deque has no elements.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BankersDeque`1.Init">
<summary>
O(1), amortized. Returns a new deque of the elements before the last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BankersDeque`1.Head">
<summary>
O(1), amortized. Returns the first element.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.BankersDeque`1.Update(System.Int32,`0)">
<summary>
O(n), worst case. Returns deque with element updated by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.BankersDeque`1.TryUpdate(System.Int32,`0)">
<summary>
O(n), worst case. Returns option deque with element updated by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.BankersDeque`1.TryRemove(System.Int32)">
<summary>
O(n), worst case. Returns option deque with element removed by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.BankersDeque`1.TryLookup(System.Int32)">
<summary>
O(n), worst case. Returns option element by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.BankersDeque`1.Snoc(`0)">
<summary>
O(1), amortized. Returns a new deque with the element added to the end.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.BankersDeque`1.Remove(System.Int32)">
<summary>
O(n), worst case. Returns deque with element removed by index.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.BankersDeque`1.Lookup(System.Int32)">
<summary>
O(n), worst case. Returns element by index.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.BankersDeque`1.Cons(`0)">
<summary>
O(1), amortized. Returns a new deque with the element added to the beginning.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BankersQueue`1.Uncons">
<summary>
O(1), amortized. Returns the first element and tail.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BankersQueue`1.TryUncons">
<summary>
O(1), amortized. Returns option first element and tail.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BankersQueue`1.TryGetTail">
<summary>
O(1), amortized. Returns option queue of the elements trailing the first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BankersQueue`1.TryGetHead">
<summary>
O(1), amortized. Returns option first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BankersQueue`1.Tail">
<summary>
O(1), amortized. Returns a new queue of the elements trailing the first element.
</summary>
</member>
<member name="P:FSharpx.DataStructures.BankersQueue`1.Rev">
<summary>
O(1). Returns queue reversed
</summary>
</member>
<member name="P:FSharpx.DataStructures.BankersQueue`1.Length">
<summary>
O(1). Returns the count of elememts.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BankersQueue`1.IsEmpty">
<summary>
O(1). Returns true if the queue has no elements.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BankersQueue`1.Head">
<summary>
O(1), amortized. Returns the first element.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.BankersQueue`1.Snoc(`0)">
<summary>
O(1), amortized. Returns a new queue with the element added to the end.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BatchedDeque`1.Unsnoc">
<summary>
O(1) amortized, O(n), worst case. Returns init and the last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BatchedDeque`1.Uncons">
<summary>
O(1) amortized, O(n), worst case. Returns the first element and tail.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BatchedDeque`1.TryUnsnoc">
<summary>
O(1) amortized, O(n), worst case. Returns option init and the last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BatchedDeque`1.TryUncons">
<summary>
O(1) amortized, O(n), worst case. Returns option first element and tail.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BatchedDeque`1.TryGetTail">
<summary>
O(1) amortized, O(n), worst case. Returns option deque of the elements trailing the first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BatchedDeque`1.TryGetLast">
<summary>
O(1) amortized, O(n), worst case. Returns option last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BatchedDeque`1.TryGetInit">
<summary>
O(1) amortized, O(n), worst case. Returns a new deque of the elements before the last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BatchedDeque`1.TryGetHead">
<summary>
O(1) amortized, O(n), worst case. Returns option first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BatchedDeque`1.Tail">
<summary>
O(1) amortized, O(n), worst case. Returns a new deque of the elements trailing the first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BatchedDeque`1.Rev">
<summary>
O(1). Returns deque reversed.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BatchedDeque`1.Length">
<summary>
O(1). Returns the count of elememts.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BatchedDeque`1.Last">
<summary>
O(1) amortized, O(n), worst case. Returns the last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BatchedDeque`1.IsEmpty">
<summary>
O(1). Returns true if the deque has no elements.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BatchedDeque`1.Init">
<summary>
O(1) amortized, O(n), worst case. Returns a new deque of the elements before the last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BatchedDeque`1.Head">
<summary>
O(1) amortized, O(n), worst case. Returns the first element.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.BatchedDeque`1.Update(System.Int32,`0)">
<summary>
O(n), worst case. Returns deque with element updated by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.BatchedDeque`1.TryUpdate(System.Int32,`0)">
<summary>
O(n), worst case. Returns option deque with element updated by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.BatchedDeque`1.TryRemove(System.Int32)">
<summary>
O(n), worst case. Returns option deque with element removed by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.BatchedDeque`1.TryLookup(System.Int32)">
<summary>
O(n), worst case. Returns option element by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.BatchedDeque`1.Snoc(`0)">
<summary>
O(1). Returns a new deque with the element added to the end.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.BatchedDeque`1.Remove(System.Int32)">
<summary>
O(n), worst case. Returns deque with element removed by index.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.BatchedDeque`1.Lookup(System.Int32)">
<summary>
O(n), worst case. Returns element by index.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.BatchedDeque`1.Cons(`0)">
<summary>
O(1). Returns a new deque with the element added to the beginning.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BatchedQueue`1.Uncons">
<summary>
returns the first element and tail
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BatchedQueue`1.TryUncons">
<summary>
returns option first element and tail
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BatchedQueue`1.TryGetTail">
<summary>
returns option queue of the elements trailing the first element
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BatchedQueue`1.TryGetHead">
<summary>
returns option first element
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BatchedQueue`1.Tail">
<summary>
returns a new queue of the elements trailing the first element
</summary>
</member>
<member name="P:FSharpx.DataStructures.BatchedQueue`1.Rev">
<summary>
returns queue reversed
</summary>
</member>
<member name="P:FSharpx.DataStructures.BatchedQueue`1.Length">
<summary>
returns the count of elememts
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BatchedQueue`1.IsEmpty">
<summary>
returns true if the queue has no elements
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BatchedQueue`1.Head">
<summary>
returns the first element
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.BatchedQueue`1.Snoc(`0)">
<summary>
returns a new queue with the element added to the end
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BinaryRandomAccessList`1.Uncons">
<summary>
O(log n), worst case. Returns the first element and tail.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BinaryRandomAccessList`1.TryUncons">
<summary>
O(log n), worst case. Returns the option first element and tail.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BinaryRandomAccessList`1.TryGetTail">
<summary>
O(log n), worst case. Returns a option random access list of the elements trailing the first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BinaryRandomAccessList`1.TryGetHead">
<summary>
O(log n), worst case. Returns option first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BinaryRandomAccessList`1.Tail">
<summary>
O(log n), worst case. Returns a new random access list of the elements trailing the first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BinaryRandomAccessList`1.IsEmpty">
<summary>
O(1). Returns true if the random access list has no elements.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BinaryRandomAccessList`1.Head">
<summary>
O(log n), worst case. Returns the first element.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.BinaryRandomAccessList`1.Update(System.Int32,`0)">
<summary>
O(log n), worst case. Returns random access list with element updated by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.BinaryRandomAccessList`1.TryUpdate(System.Int32,`0)">
<summary>
O(log n), worst case. Returns option random access list with element updated by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.BinaryRandomAccessList`1.TryLookup(System.Int32)">
<summary>
O(log n), worst case. Returns option element by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.BinaryRandomAccessList`1.Rev">
<summary>
O(n). Returns random access list reversed.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.BinaryRandomAccessList`1.Lookup(System.Int32)">
<summary>
O(log n), worst case. Returns element by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.BinaryRandomAccessList`1.Length">
<summary>
O(log n). Returns the count of elememts.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.BinaryRandomAccessList`1.Cons(`0)">
<summary>
O(log n), worst case. Returns a new random access list with the element added to the beginning.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BinomialHeap`1.IsEmpty">
<summary>
O(1). Returns true if the heap has no elements.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.BinomialHeap`1.IsDescending">
<summary>
O(1). Returns true if the heap has max element at head.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.BinomialHeap`1.Uncons">
<summary>
O(log n). Returns the head element and tail.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.BinomialHeap`1.TryUncons">
<summary>
O(log n). Returns option head element and tail.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.BinomialHeap`1.TryMerge(FSharpx.DataStructures.BinomialHeap{`0})">
<summary>
O(log n). Returns heap option from merging two heaps.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.BinomialHeap`1.TryGetTail">
<summary>
O(log n). Returns option heap of the elements trailing the head.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.BinomialHeap`1.TryGetHead">
<summary>
O(log n). Returns option first min or max element.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.BinomialHeap`1.Tail">
<summary>
O(log n). Returns a new heap of the elements trailing the head.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.BinomialHeap`1.Merge(FSharpx.DataStructures.BinomialHeap{`0})">
<summary>
O(log n). Returns heap from merging two heaps, both must have same isDescending.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.BinomialHeap`1.Length">
<summary>
O(log n). Returns the count of elememts.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.BinomialHeap`1.Insert(`0)">
<summary>
O(log n). Returns a new heap with the element inserted.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.BinomialHeap`1.Head">
<summary>
O(log n). Returns the min or max element.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.DList`1.snoc(`0)">
<summary>
O(1). Returns a new DList with the element added to the end.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.DList`1.Tail">
<summary>
O(log n). Returns a new DList of the elements trailing the first element.
</summary>
</member>
<member name="P:FSharpx.DataStructures.DList`1.Length">
<summary>
O(1). Returns the count of elememts.
</summary>
</member>
<member name="P:FSharpx.DataStructures.DList`1.IsEmpty">
<summary>
O(1). Returns true if the DList has no elements.
</summary>
</member>
<member name="P:FSharpx.DataStructures.DList`1.Head">
<summary>
O(log n). Returns the first element.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.DataStructures.DList`1">
<summary>
 The DList is an implementation of John Hughes&apos; append list.
 See http://dl.acm.org/citation.cfm?id=8475 for more information.
 This implementation adds an additional parameter to allow a more
 efficient calculation of the list length.
 Note that an alternate form would represent the DList as:
 type DList&lt;&apos;a&gt; = DList of (&apos;a list -&gt; &apos;a list)
 An example can be found at http://stackoverflow.com/questions/5324623/functional-o1-append-and-on-iteration-from-first-element-list-data-structure/5327209#5327209
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.Deque`1.Unsnoc">
<summary>
O(1) amortized, O(n), worst case. Returns init and the last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.Deque`1.Uncons">
<summary>
O(1) amortized, O(n), worst case. Returns the first element and tail.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.Deque`1.TryUnsnoc">
<summary>
O(1) amortized, O(n), worst case. Returns option init and the last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.Deque`1.TryUncons">
<summary>
O(1) amortized, O(n), worst case. Returns option first element and tail.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.Deque`1.TryGetTail">
<summary>
O(1) amortized, O(n), worst case. Returns option deque of the elements trailing the first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.Deque`1.TryGetLast">
<summary>
O(1) amortized, O(n), worst case. Returns option last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.Deque`1.TryGetInit">
<summary>
O(1) amortized, O(n), worst case. Returns option deque of the elements before the last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.Deque`1.TryGetHead">
<summary>
O(1) amortized, O(n), worst case. Returns option first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.Deque`1.Tail">
<summary>
O(1) amortized, O(n), worst case. Returns a new deque of the elements trailing the first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.Deque`1.Rev">
<summary>
O(1). Returns deque reversed.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.Deque`1.Length">
<summary>
O(1). Returns the count of elememts.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.Deque`1.Last">
<summary>
O(1) amortized, O(n), worst case. Returns the last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.Deque`1.IsEmpty">
<summary>
O(1). Returns true if the deque has no elements.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.Deque`1.Init">
<summary>
O(1) amortized, O(n), worst case. Returns a new deque of the elements before the last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.Deque`1.Head">
<summary>
O(1) amortized, O(n), worst case. Returns the first element.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.Deque`1.Update(System.Int32,`0)">
<summary>
O(n), worst case. Returns deque with element updated by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.Deque`1.TryUpdate(System.Int32,`0)">
<summary>
O(n), worst case. Returns option deque with element updated by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.Deque`1.TryRemove(System.Int32)">
<summary>
O(n), worst case. Returns option deque with element removed by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.Deque`1.TryLookup(System.Int32)">
<summary>
O(n), worst case. Returns option element by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.Deque`1.Snoc(`0)">
<summary>
O(1) amortized, O(n), worst case. Returns a new deque with the element added to the end.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.Deque`1.Remove(System.Int32)">
<summary>
O(n), worst case. Returns deque with element removed by index.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.Deque`1.Lookup(System.Int32)">
<summary>
O(n), worst case. Returns element by index.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.Deque`1.Cons(`0)">
<summary>
O(1) amortized, O(n), worst case. Returns a new deque with the element added to the beginning.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.HoodMelvilleQueue`1.Uncons">
<summary>
returns the first element and tail
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.HoodMelvilleQueue`1.TryUncons">
<summary>
returns option first element and tail
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.HoodMelvilleQueue`1.TryGetTail">
<summary>
returns option queue of the elements trailing the first element
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.HoodMelvilleQueue`1.TryGetHead">
<summary>
returns option first element
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.HoodMelvilleQueue`1.Tail">
<summary>
returns a new queue of the elements trailing the first element
</summary>
</member>
<member name="P:FSharpx.DataStructures.HoodMelvilleQueue`1.Length">
<summary>
returns the count of elememts
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.HoodMelvilleQueue`1.IsEmpty">
<summary>
returns true if the queue has no elements
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.HoodMelvilleQueue`1.Head">
<summary>
returns the first element
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.HoodMelvilleQueue`1.Snoc(`0)">
<summary>
returns a new queue with the element added to the end
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.LeftistHeap`1.TryGetHead">
<summary>
O(1). Returns option first min or max element.
</summary>
</member>
<member name="P:FSharpx.DataStructures.LeftistHeap`1.Length">
<summary>
O(1). Returns the count of elememts.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.LeftistHeap`1.IsEmpty">
<summary>
O(1). Returns true if the heap has no elements.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.LeftistHeap`1.IsDescending">
<summary>
O(1). Returns true if the heap has max element at head.
</summary>
</member>
<member name="P:FSharpx.DataStructures.LeftistHeap`1.Head">
<summary>
O(1). Returns the min or max element.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.LeftistHeap`1.Uncons">
<summary>
O(log n). Returns the head element and tail.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.LeftistHeap`1.TryUncons">
<summary>
O(log n). Returns option head element and tail.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.LeftistHeap`1.TryMerge(FSharpx.DataStructures.LeftistHeap{`0})">
<summary>
O(log n). Returns heap option from merging two heaps
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.LeftistHeap`1.TryGetTail">
<summary>
O(log n). Returns option heap of the elements trailing the head.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.LeftistHeap`1.Tail">
<summary>
O(log n) Returns a new heap of the elements trailing the head.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.LeftistHeap`1.Merge(FSharpx.DataStructures.LeftistHeap{`0})">
<summary>
O(log n). Returns heap from merging two heaps, both must have same isDescending.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.LeftistHeap`1.Insert(`0)">
<summary>
O(log n). Returns a new heap with the element inserted.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.PairingHeap`1.IsEmpty">
<summary>
O(1) Returns true if the heap has no elements.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.PairingHeap`1.IsDescending">
<summary>
O(1). Returns true if the heap has max element at head.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.PairingHeap`1.Uncons">
<summary>
O(log n) amortized time. Returns the head element and tail.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.PairingHeap`1.TryUncons">
<summary>
O(log n) amortized time. Returns option head element and tail.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.PairingHeap`1.TryMerge(FSharpx.DataStructures.PairingHeap{`0})">
<summary>
O(log n) amortized time. Returns heap option from merging two heaps.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.PairingHeap`1.TryGetTail">
<summary>
O(log n) amortized time. Returns option heap of the elements trailing the head.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.PairingHeap`1.TryGetHead">
<summary>
O(1) worst case. Returns option first min or max element.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.PairingHeap`1.Tail">
<summary>
O(log n) amortized time. Returns a new heap of the elements trailing the head.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.PairingHeap`1.Merge(FSharpx.DataStructures.PairingHeap{`0})">
<summary>
O(log n) amortized time. Returns heap from merging two heaps, both must have same descending.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.PairingHeap`1.Length">
<summary>
O(n). Returns the count of elememts.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.PairingHeap`1.Insert(`0)">
<summary>
O(log n) amortized time. Returns a new heap with the element inserted.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.PairingHeap`1.Head">
<summary>
O(1) worst case. Returns the min or max element.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.DataStructures.PairingHeap`1">
<summary>
 PairingHeap performs extremely well in practice, however (according to Okasaki) it should be avoided for applications taking advantage of persistence.
 Also according to Okasaki the time complexity of the heap functions in the PairingHeap implementation have &quot;resisted&quot; time complexity analysis. 
 ofSeq: superior performance; insert: superior performance; tail: superior performance
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.PhysicistQueue`1.Uncons">
<summary>
O(1), amortized. Returns the first element and tail.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.PhysicistQueue`1.TryUncons">
<summary>
O(1), amortized. Returns option first element and tail.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.PhysicistQueue`1.TryGetTail">
<summary>
O(1), amortized. Returns option queue of the elements trailing the first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.PhysicistQueue`1.TryGetHead">
<summary>
O(1), amortized. Returns option first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.PhysicistQueue`1.Tail">
<summary>
O(1), amortized. Returns a new queue of the elements trailing the first element.
</summary>
</member>
<member name="P:FSharpx.DataStructures.PhysicistQueue`1.Rev">
<summary>
O(1). Returns queue reversed.
</summary>
</member>
<member name="P:FSharpx.DataStructures.PhysicistQueue`1.Length">
<summary>
O(1). Returns the count of elememts.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.PhysicistQueue`1.IsEmpty">
<summary>
O(1). Returns true if the queue has no elements.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.PhysicistQueue`1.Head">
<summary>
O(1), amortized. Returns the first element.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.PhysicistQueue`1.Snoc(`0)">
<summary>
O(1), amortized. Returns a new queue with the element added to the end.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.RealTimeDeque`1.Unsnoc">
<summary>
O(1), worst case. Returns init and the last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.RealTimeDeque`1.Uncons">
<summary>
O(1), worst case. Returns the first element and tail
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.RealTimeDeque`1.TryUnsnoc">
<summary>
O(1), worst case. Returns option init and the last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.RealTimeDeque`1.TryUncons">
<summary>
O(1), worst case. Returns option first element and tail.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.RealTimeDeque`1.TryGetTail">
<summary>
O(1), worst case. Returns option deque of the elements trailing the first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.RealTimeDeque`1.TryGetLast">
<summary>
O(1), worst case. Returns option last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.RealTimeDeque`1.TryGetInit">
<summary>
O(1), worst case. Returns option deque of the elements before the last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.RealTimeDeque`1.TryGetHead">
<summary>
O(1), worst case. Returns option first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.RealTimeDeque`1.Tail">
<summary>
O(1), worst case. Returns a new deque of the elements trailing the first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.RealTimeDeque`1.Rev">
<summary>
O(1). Returns deque reversed.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.RealTimeDeque`1.Length">
<summary>
O(1). Returns the count of elememts.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.RealTimeDeque`1.Last">
<summary>
O(1), worst case. Returns the last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.RealTimeDeque`1.IsEmpty">
<summary>
O(1). Returns true if the deque has no elements.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.RealTimeDeque`1.Init">
<summary>
O(1), worst case. Returns a new deque of the elements before the last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.RealTimeDeque`1.Head">
<summary>
O(1), worst case. Returns the first element.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque`1.Update(System.Int32,`0)">
<summary>
O(n/2), worst case. Returns deque with element updated by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque`1.TryUpdate(System.Int32,`0)">
<summary>
O(n/2), worst case. Returns option deque with element updated by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque`1.TryRemove(System.Int32)">
<summary>
O(n/2), worst case. Returns option deque with element removed by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque`1.TryLookup(System.Int32)">
<summary>
O(n/2), worst case. Returns option element by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque`1.Snoc(`0)">
<summary>
O(1), worst case. Returns a new deque with the element added to the end.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque`1.Remove(System.Int32)">
<summary>
O(n/2), worst case. Returns deque with element removed by index.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque`1.Lookup(System.Int32)">
<summary>
O(n/2), worst case. Returns element by index.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque`1.Cons(`0)">
<summary>
O(1), worst case. Returns a new deque with the element added to the beginning.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.RingBuffer`1.TryAdvance(System.Int32)">
<summary>
 Tries to advance the position of the RingBuffer by the offset.
 Returns None if offset is negative, otherwise Some containing 
 the position of the RingBuffer.    
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.RingBuffer`1.Advance(System.Int32)">
<summary>
 Advances the position of the RingBuffer by the offset.
 Returns the position of the RingBuffer. Throws an ArgumentException if
 the offset is negative.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.DataStructures.RoseTree`1">
<summary>
 Multi-way tree, also known as rose tree.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.SkewBinaryRandomAccessList`1.Uncons">
<summary>
O(1), worst case. Returns the first element and tail.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.SkewBinaryRandomAccessList`1.TryUncons">
<summary>
O(1), worst case. Returns the option first element and tail.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.SkewBinaryRandomAccessList`1.TryGetTail">
<summary>
O(1), worst case. Returns a option random access list of the elements trailing the first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.SkewBinaryRandomAccessList`1.TryGetHead">
<summary>
O(1), worst case. Returns option first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.SkewBinaryRandomAccessList`1.Tail">
<summary>
O(1), worst case. Returns a new random access list of the elements trailing the first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.SkewBinaryRandomAccessList`1.IsEmpty">
<summary>
O(1). Returns true if the random access list has no elements.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.SkewBinaryRandomAccessList`1.Head">
<summary>
O(1), worst case. Returns the first element.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.SkewBinaryRandomAccessList`1.Update(System.Int32,`0)">
<summary>
O(log n), worst case. Returns random access list with element updated by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.SkewBinaryRandomAccessList`1.TryUpdate(System.Int32,`0)">
<summary>
O(log n), worst case. Returns option random access list with element updated by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.SkewBinaryRandomAccessList`1.TryLookup(System.Int32)">
<summary>
O(log n), worst case. Returns option element by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.SkewBinaryRandomAccessList`1.Rev">
<summary>
O(n). Returns random access list reversed.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.SkewBinaryRandomAccessList`1.Lookup(System.Int32)">
<summary>
O(log n), worst case. Returns element by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.SkewBinaryRandomAccessList`1.Length">
<summary>
O(log n) Returns the count of elememts.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.SkewBinaryRandomAccessList`1.Cons(`0)">
<summary>
O(1), worst case. Returns a new random access list with the element added to the beginning.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.Timeseries`1.TryAdvance(System.DateTimeOffset)">
<summary>
 Tries to advance the start date of the Timeseries to toDate.
 Returns None if toDate is before the start date of the Timeseries, 
 otherwise Some containing the start date of the Timeseries.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.Timeseries`1.Advance(System.DateTimeOffset)">
<summary>
 Advances the start date of the Timeseries to toDate. Throws an 
 ArgumentException if toDate is before the Timeseries start date.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.AltBinaryRandomAccessListModule.tryUpdate``1(System.Int32,``0,FSharpx.DataStructures.AltBinRndAccList{``0})">
<summary>
O(log n). Returns option random access list with element updated by index.
</summary>
</member>
<member name="M:FSharpx.DataStructures.AltBinaryRandomAccessListModule.update``1(System.Int32,``0,FSharpx.DataStructures.AltBinRndAccList{``0})">
<summary>
O(log n). Returns random access list with element updated by index.
</summary>
</member>
<member name="M:FSharpx.DataStructures.AltBinaryRandomAccessListModule.tryUncons``1(FSharpx.DataStructures.AltBinRndAccList{``0})">
<summary>
O(log n). Returns the option first element and tail.
</summary>
</member>
<member name="M:FSharpx.DataStructures.AltBinaryRandomAccessListModule.uncons``1(FSharpx.DataStructures.AltBinRndAccList{``0})">
<summary>
O(log n). Returns the first element and tail.
</summary>
</member>
<member name="M:FSharpx.DataStructures.AltBinaryRandomAccessListModule.tryGetTail``1(FSharpx.DataStructures.AltBinRndAccList{``0})">
<summary>
O(log n). Returns a option random access list of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.AltBinaryRandomAccessListModule.tail``1(FSharpx.DataStructures.AltBinRndAccList{``0})">
<summary>
O(log n). Returns a new random access list of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.AltBinaryRandomAccessListModule.rev``1(FSharpx.DataStructures.AltBinRndAccList{``0})">
<summary>
O(n). Returns random access list reversed.
</summary>
</member>
<member name="M:FSharpx.DataStructures.AltBinaryRandomAccessListModule.tryRemove``1(System.Int32,FSharpx.DataStructures.AltBinRndAccList{``0})">
<summary>
O(n). Returns option random access list with element removed by index.
</summary>
</member>
<member name="M:FSharpx.DataStructures.AltBinaryRandomAccessListModule.remove``1(System.Int32,FSharpx.DataStructures.AltBinRndAccList{``0})">
<summary>
O(n). Returns random access list with element removed by index.
</summary>
</member>
<member name="M:FSharpx.DataStructures.AltBinaryRandomAccessListModule.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
O(n). Returns random access list from the sequence.
</summary>
</member>
<member name="M:FSharpx.DataStructures.AltBinaryRandomAccessListModule.tryLookup``1(System.Int32,FSharpx.DataStructures.AltBinRndAccList{``0})">
<summary>
O(log n). Returns option element by index.
</summary>
</member>
<member name="M:FSharpx.DataStructures.AltBinaryRandomAccessListModule.lookup``1(System.Int32,FSharpx.DataStructures.AltBinRndAccList{``0})">
<summary>
O(log n). Returns element by index.
</summary>
</member>
<member name="M:FSharpx.DataStructures.AltBinaryRandomAccessListModule.length``1(FSharpx.DataStructures.AltBinRndAccList{``0})">
<summary>
O(log n). Returns the count of elememts.
</summary>
</member>
<member name="M:FSharpx.DataStructures.AltBinaryRandomAccessListModule.isEmpty``1(FSharpx.DataStructures.AltBinRndAccList{``0})">
<summary>
O(1). Returns true if the random access list has no elements.
</summary>
</member>
<member name="M:FSharpx.DataStructures.AltBinaryRandomAccessListModule.tryGetHead``1(FSharpx.DataStructures.AltBinRndAccList{``0})">
<summary>
O(log n). Returns option first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.AltBinaryRandomAccessListModule.empty``1">
<summary>
O(1). Returns a empty random access list.
</summary>
</member>
<member name="M:FSharpx.DataStructures.AltBinaryRandomAccessListModule.head``1(FSharpx.DataStructures.AltBinRndAccList{``0})">
<summary>
O(log n). Returns the first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.AltBinaryRandomAccessListModule.cons``1(``0,FSharpx.DataStructures.AltBinRndAccList{``0})">
<summary>
O(log n). Returns a new random access list with the element added to the beginning.
</summary>
</member>
<member name="M:FSharpx.DataStructures.AltBinaryRandomAccessListModule.append``1(FSharpx.DataStructures.AltBinRndAccList{``0},FSharpx.DataStructures.AltBinRndAccList{``0})">
<summary>
O(xs). Returns random access list from elements of 2 random access lists concatenated.
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.DataStructures.AltBinaryRandomAccessListModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.DataStructures.BKTree">

</member>
<member name="M:FSharpx.DataStructures.BankersDequeModule.tryUpdate``1(System.Int32,``0,FSharpx.DataStructures.BankersDeque{``0})">
<summary>
O(n), worst case. Returns option deque with element updated by index.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersDequeModule.update``1(System.Int32,``0,FSharpx.DataStructures.BankersDeque{``0})">
<summary>
O(n), worst case. Returns deque with element updated by index.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersDequeModule.tryUnsnoc``1(FSharpx.DataStructures.BankersDeque{``0})">
<summary>
O(1), amortized. Returns option init and the last element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersDequeModule.unsnoc``1(FSharpx.DataStructures.BankersDeque{``0})">
<summary>
O(1), amortized. Returns init and the last element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersDequeModule.tryUncons``1(FSharpx.DataStructures.BankersDeque{``0})">
<summary>
O(1), amortized. Returns option first element and tail.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersDequeModule.uncons``1(FSharpx.DataStructures.BankersDeque{``0})">
<summary>
O(1), amortized. Returns the first element and tail.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersDequeModule.tryGetTail``1(FSharpx.DataStructures.BankersDeque{``0})">
<summary>
O(1), amortized. Returns option deque of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersDequeModule.tail``1(FSharpx.DataStructures.BankersDeque{``0})">
<summary>
O(1), amortized. Returns a new deque of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersDequeModule.snoc``1(``0,FSharpx.DataStructures.BankersDeque{``0})">
<summary>
O(1), amortized. Returns a new deque with the element added to the end.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersDequeModule.singletonC``1(System.Int32,``0)">
<summary>
O(1). Returns a deque of one element, c is front-back stream ratio constant, should be at least 2.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersDequeModule.singleton``1(``0)">
<summary>
O(1). Returns a deque of one element, front-back stream ratio constant defaulted to 2.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersDequeModule.rev``1(FSharpx.DataStructures.BankersDeque{``0})">
<summary>
O(1). Returns deque reversed.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersDequeModule.tryRemove``1(System.Int32,FSharpx.DataStructures.BankersDeque{``0})">
<summary>
O(n), worst case. Returns option deque with element removed by index.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersDequeModule.remove``1(System.Int32,FSharpx.DataStructures.BankersDeque{``0})">
<summary>
O(n), worst case. Returns deque with element removed by index.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersDequeModule.ofSeqC``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
<summary>
O(1). Returns a deque of the seq, c is front-back stream ratio constant, should be at least 2.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersDequeModule.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
O(1). Returns a deque of the seq, front-back stream ratio constant defaulted to 2.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersDequeModule.ofCatSeqsC``1(System.Int32,System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
<summary>
O(ys). Returns a deque of the two seqs concatenated, c is front-back stream ratio constant, should be at least 2.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersDequeModule.ofCatSeqs``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
<summary>
O(ys). Returns a deque of the two seqs concatenated, front-back stream ratio constant defaulted to 2.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersDequeModule.ofCatListsC``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
O(ys-xs). Returns a deque of the two lists concatenated, c is front-back stream ration constant, should be at least 2.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersDequeModule.ofCatLists``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
O(ys-xs). Returns a deque of the two lists concatenated, front-back stream ratio constant defaulted to 2.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersDequeModule.tryLookup``1(System.Int32,FSharpx.DataStructures.BankersDeque{``0})">
<summary>
O(n), worst case. Returns option element by index.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersDequeModule.lookup``1(System.Int32,FSharpx.DataStructures.BankersDeque{``0})">
<summary>
O(n), worst case. Returns element by index.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersDequeModule.length``1(FSharpx.DataStructures.BankersDeque{``0})">
<summary>
O(1). Returns the count of elememts.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersDequeModule.tryGetLast``1(FSharpx.DataStructures.BankersDeque{``0})">
<summary>
O(1), amortized. Returns option last element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersDequeModule.last``1(FSharpx.DataStructures.BankersDeque{``0})">
<summary>
O(1), amortized. Returns the last element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersDequeModule.isEmpty``1(FSharpx.DataStructures.BankersDeque{``0})">
<summary>
O(1). Returns true if the deque has no elements.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersDequeModule.tryGetInit``1(FSharpx.DataStructures.BankersDeque{``0})">
<summary>
O(1), amortized. Returns option deque of the elements before the last element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersDequeModule.init``1(FSharpx.DataStructures.BankersDeque{``0})">
<summary>
O(1), amortized. Returns a new deque of the elements before the last element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersDequeModule.tryGetHead``1(FSharpx.DataStructures.BankersDeque{``0})">
<summary>
O(1), amortized. Returns option first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersDequeModule.head``1(FSharpx.DataStructures.BankersDeque{``0})">
<summary>
O(1), amortized. Returns the first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersDequeModule.empty``1(System.Int32)">
<summary>
O(1). Returns deque of no elements, c is front-back stream ration constant, should be at least 2.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersDequeModule.cons``1(``0,FSharpx.DataStructures.BankersDeque{``0})">
<summary>
O(1), amortized. Returns a new deque with the element added to the beginning.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersDequeModule.appendC``1(System.Int32,FSharpx.DataStructures.BankersDeque{``0},FSharpx.DataStructures.BankersDeque{``0})">
<summary>
O(ys-xs). Returns a deque of the two deques concatenated, c is front-back stream ratio constant, should be at least 2.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersDequeModule.append``1(FSharpx.DataStructures.BankersDeque{``0},FSharpx.DataStructures.BankersDeque{``0})">
<summary>
O(ys-xs). Returns a deque of the two deques concatenated, front-back stream ratio constant defaulted to 2.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.DataStructures.BankersDequeModule">

</member>
<member name="M:FSharpx.DataStructures.BankersQueueModule.tryUncons``1(FSharpx.DataStructures.BankersQueue{``0})">
<summary>
O(1), amortized. Returns option first element and tail.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersQueueModule.uncons``1(FSharpx.DataStructures.BankersQueue{``0})">
<summary>
O(1), amortized. Returns the first element and tail.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersQueueModule.tryGetTail``1(FSharpx.DataStructures.BankersQueue{``0})">
<summary>
O(1), amortized. Returns option queue of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersQueueModule.tail``1(FSharpx.DataStructures.BankersQueue{``0})">
<summary>
O(1), amortized. Returns a new queue of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersQueueModule.snoc``1(``0,FSharpx.DataStructures.BankersQueue{``0})">
<summary>
O(1), amortized. Returns a new queue with the element added to the end.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersQueueModule.rev``1(FSharpx.DataStructures.BankersQueue{``0})">
<summary>
O(1). Returns queue reversed.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersQueueModule.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
O(1). Returns a queue of the seq.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersQueueModule.length``1(Microsoft.FSharp.Core.Unit,FSharpx.DataStructures.BankersQueue{``0})">
<summary>
O(1). Returns the count of elememts.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersQueueModule.isEmpty``1(Microsoft.FSharp.Core.Unit,FSharpx.DataStructures.BankersQueue{``0})">
<summary>
O(1). Returns true if the queue has no elements.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersQueueModule.tryGetHead``1(FSharpx.DataStructures.BankersQueue{``0})">
<summary>
O(1), amortized. Returns option first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersQueueModule.head``1(FSharpx.DataStructures.BankersQueue{``0})">
<summary>
O(1), amortized. Returns the first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BankersQueueModule.empty``1">
<summary>
O(1). Returns queue of no elements.
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.DataStructures.BankersQueueModule">

</member>
<member name="M:FSharpx.DataStructures.BatchedDequeModule.tryUpdate``1(System.Int32,``0,FSharpx.DataStructures.BatchedDeque{``0})">
<summary>
O(n), worst case. Returns option deque with element updated by index.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BatchedDequeModule.update``1(System.Int32,``0,FSharpx.DataStructures.BatchedDeque{``0})">
<summary>
O(n), worst case. Returns deque with element updated by index.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BatchedDequeModule.tryUnsnoc``1(FSharpx.DataStructures.BatchedDeque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns option init and the last element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BatchedDequeModule.unsnoc``1(FSharpx.DataStructures.BatchedDeque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns init and the last element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BatchedDequeModule.tryUncons``1(FSharpx.DataStructures.BatchedDeque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns option first element and tail.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BatchedDequeModule.uncons``1(FSharpx.DataStructures.BatchedDeque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns the first element and tail.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BatchedDequeModule.tryGetTail``1(FSharpx.DataStructures.BatchedDeque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns option deque of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BatchedDequeModule.tail``1(FSharpx.DataStructures.BatchedDeque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns a new deque of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BatchedDequeModule.snoc``1(``0,FSharpx.DataStructures.BatchedDeque{``0})">
<summary>
O(1). Returns a new deque with the element added to the end.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BatchedDequeModule.singleton``1(``0)">
<summary>
O(1). Returns a deque of one element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BatchedDequeModule.rev``1(FSharpx.DataStructures.BatchedDeque{``0})">
<summary>
O(1). Returns deque reversed.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BatchedDequeModule.tryRemove``1(System.Int32,FSharpx.DataStructures.BatchedDeque{``0})">
<summary>
O(n), worst case. Returns option deque with element removed by index.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BatchedDequeModule.remove``1(System.Int32,FSharpx.DataStructures.BatchedDeque{``0})">
<summary>
O(n), worst case. Returns deque with element removed by index.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BatchedDequeModule.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
O(n), worst case. Returns a deque of the seq.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BatchedDequeModule.ofList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
O(n), worst case. Returns a deque of the list.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BatchedDequeModule.ofCatLists``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
O(n), worst case. Returns a deque of the two lists concatenated.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BatchedDequeModule.tryLookup``1(System.Int32,FSharpx.DataStructures.BatchedDeque{``0})">
<summary>
O(n), worst case. Returns option element by index.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BatchedDequeModule.lookup``1(System.Int32,FSharpx.DataStructures.BatchedDeque{``0})">
<summary>
O(n), worst case. Returns element by index.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BatchedDequeModule.length``1(FSharpx.DataStructures.BatchedDeque{``0})">
<summary>
O(1). Returns the count of elememts.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BatchedDequeModule.tryGetLast``1(FSharpx.DataStructures.BatchedDeque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns option last element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BatchedDequeModule.last``1(FSharpx.DataStructures.BatchedDeque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns the last element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BatchedDequeModule.isEmpty``1(FSharpx.DataStructures.BatchedDeque{``0})">
<summary>
O(1). Returns true if the deque has no elements.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BatchedDequeModule.tryGetInit``1(FSharpx.DataStructures.BatchedDeque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns option deque of the elements before the last element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BatchedDequeModule.init``1(FSharpx.DataStructures.BatchedDeque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns a new deque of the elements before the last element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BatchedDequeModule.tryGetHead``1(FSharpx.DataStructures.BatchedDeque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns option first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BatchedDequeModule.head``1(FSharpx.DataStructures.BatchedDeque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns the first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BatchedDequeModule.empty``1">
<summary>
O(1). Returns deque of no elements.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BatchedDequeModule.cons``1(``0,FSharpx.DataStructures.BatchedDeque{``0})">
<summary>
O(1). Returns a new deque with the element added to the beginning.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.DataStructures.BatchedDequeModule">

</member>
<member name="M:FSharpx.DataStructures.BatchedQueueModule.tryUncons``1(FSharpx.DataStructures.BatchedQueue{``0})">
<summary>
returns option first element and tail
</summary>
</member>
<member name="M:FSharpx.DataStructures.BatchedQueueModule.uncons``1(FSharpx.DataStructures.BatchedQueue{``0})">
<summary>
returns the first element and tail
</summary>
</member>
<member name="M:FSharpx.DataStructures.BatchedQueueModule.tryGetTail``1(FSharpx.DataStructures.BatchedQueue{``0})">
<summary>
returns option queue of the elements trailing the first element
</summary>
</member>
<member name="M:FSharpx.DataStructures.BatchedQueueModule.tail``1(FSharpx.DataStructures.BatchedQueue{``0})">
<summary>
returns a new queue of the elements trailing the first element
</summary>
</member>
<member name="M:FSharpx.DataStructures.BatchedQueueModule.snoc``1(``0,FSharpx.DataStructures.BatchedQueue{``0})">
<summary>
returns a new queue with the element added to the end
</summary>
</member>
<member name="M:FSharpx.DataStructures.BatchedQueueModule.rev``1(FSharpx.DataStructures.BatchedQueue{``0})">
<summary>
returns queue reversed
</summary>
</member>
<member name="M:FSharpx.DataStructures.BatchedQueueModule.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
returns a queue of the seq
</summary>
</member>
<member name="M:FSharpx.DataStructures.BatchedQueueModule.ofList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
returns a queue of the list
</summary>
</member>
<member name="M:FSharpx.DataStructures.BatchedQueueModule.length``1(FSharpx.DataStructures.BatchedQueue{``0})">
<summary>
returns the count of elememts
</summary>
</member>
<member name="M:FSharpx.DataStructures.BatchedQueueModule.isEmpty``1(FSharpx.DataStructures.BatchedQueue{``0})">
<summary>
returns true if the queue has no elements
</summary>
</member>
<member name="M:FSharpx.DataStructures.BatchedQueueModule.tryGetHead``1(FSharpx.DataStructures.BatchedQueue{``0})">
<summary>
returns option first element
</summary>
</member>
<member name="M:FSharpx.DataStructures.BatchedQueueModule.head``1(FSharpx.DataStructures.BatchedQueue{``0})">
<summary>
returns the first element
</summary>
</member>
<member name="M:FSharpx.DataStructures.BatchedQueueModule.foldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},FSharpx.DataStructures.BatchedQueue{``0},``1)">
<summary>
applies a function to each element of the queue, threading an accumulator argument through the computation, right to left
</summary>
</member>
<member name="M:FSharpx.DataStructures.BatchedQueueModule.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,FSharpx.DataStructures.BatchedQueue{``1})">
<summary>
applies a function to each element of the queue, threading an accumulator argument through the computation, left to right
</summary>
</member>
<member name="M:FSharpx.DataStructures.BatchedQueueModule.empty``1">
<summary>
returns queue of no elements
c is front-back stream ration constant, should be at least 2
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.DataStructures.BatchedQueueModule">

</member>
<member name="M:FSharpx.DataStructures.BinaryRandomAccessListModule.tryUpdate``1(System.Int32,``0,FSharpx.DataStructures.BinaryRandomAccessList{``0})">
<summary>
O(log n), worst case. Returns option random access list with element updated by index.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BinaryRandomAccessListModule.update``1(System.Int32,``0,FSharpx.DataStructures.BinaryRandomAccessList{``0})">
<summary>
O(log n), worst case. Returns random access list with element updated by index.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BinaryRandomAccessListModule.tryUncons``1(FSharpx.DataStructures.BinaryRandomAccessList{``0})">
<summary>
O(log n), worst case. Returns the option first element and tail.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BinaryRandomAccessListModule.uncons``1(FSharpx.DataStructures.BinaryRandomAccessList{``0})">
<summary>
O(log n), worst case. Returns the first element and tail.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BinaryRandomAccessListModule.tryGetTail``1(FSharpx.DataStructures.BinaryRandomAccessList{``0})">
<summary>
O(log n), worst case. Returns a option random access list of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BinaryRandomAccessListModule.tail``1(FSharpx.DataStructures.BinaryRandomAccessList{``0})">
<summary>
O(log n), worst case. Returns a new random access list of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BinaryRandomAccessListModule.rev``1(FSharpx.DataStructures.BinaryRandomAccessList{``0})">
<summary>
O(n). Returns random access list reversed.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BinaryRandomAccessListModule.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
O(n). Returns random access list from the sequence.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BinaryRandomAccessListModule.tryLookup``1(System.Int32,FSharpx.DataStructures.BinaryRandomAccessList{``0})">
<summary>
O(log n), worst case. Returns option element by index.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BinaryRandomAccessListModule.lookup``1(System.Int32,FSharpx.DataStructures.BinaryRandomAccessList{``0})">
<summary>
O(log n), worst case. Returns element by index.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BinaryRandomAccessListModule.length``1(FSharpx.DataStructures.BinaryRandomAccessList{``0})">
<summary>
O(log n). Returns the count of elememts.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BinaryRandomAccessListModule.isEmpty``1(FSharpx.DataStructures.BinaryRandomAccessList{``0})">
<summary>
O(1). Returns true if the random access list has no elements.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BinaryRandomAccessListModule.empty``1">
<summary>
O(1). Returns a empty random access list.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BinaryRandomAccessListModule.tryGetHead``1(FSharpx.DataStructures.BinaryRandomAccessList{``0})">
<summary>
O(log n), worst case. Returns option first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BinaryRandomAccessListModule.head``1(FSharpx.DataStructures.BinaryRandomAccessList{``0})">
<summary>
O(log n), worst case. Returns the first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BinaryRandomAccessListModule.cons``1(``0,FSharpx.DataStructures.BinaryRandomAccessList{``0})">
<summary>
O(log n), worst case. Returns a new random access list with the element added to the beginning.
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.DataStructures.BinaryRandomAccessListModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.DataStructures.BinaryTreeZipper.BinaryTreeZipper`1">
<summary>
 The zipper datastructure for binary trees
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.DataStructures.BinaryTreeZipper.BinaryTree`1">
<summary>
 A simple binary tree
</summary>
</member>
<member name="M:FSharpx.DataStructures.BinaryTreeZipper.move``1(System.Collections.Generic.IEnumerable{FSharpx.DataStructures.BinaryTreeZipper.TreeZipperDirection},FSharpx.DataStructures.BinaryTreeZipper.BinaryTreeZipper{``0})">
<summary>
 Moves the zipper in the directions of the given list
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.BinaryTreeZipper.zipper``1(FSharpx.DataStructures.BinaryTreeZipper.BinaryTree{``0})">
<summary>
 Creates a zipper from a tree
</summary>
</member>
<member name="M:FSharpx.DataStructures.BinaryTreeZipper.setFocus``1(FSharpx.DataStructures.BinaryTreeZipper.BinaryTree{``0},FSharpx.DataStructures.BinaryTreeZipper.BinaryTreeZipper{``0})">
<summary>
 Modifies the current focus inside the zipper
</summary>
</member>
<member name="M:FSharpx.DataStructures.BinaryTreeZipper.right``1(FSharpx.DataStructures.BinaryTreeZipper.BinaryTreeZipper{``0})">
<summary>
 Moves the zipper to the right
</summary>
</member>
<member name="M:FSharpx.DataStructures.BinaryTreeZipper.left``1(FSharpx.DataStructures.BinaryTreeZipper.BinaryTreeZipper{``0})">
<summary>
 Moves the zipper to the left
</summary>
</member>
<member name="M:FSharpx.DataStructures.BinaryTreeZipper.top``1(FSharpx.DataStructures.BinaryTreeZipper.BinaryTreeZipper{``0})">
<summary>
 Moves the zipper to the top
</summary>
</member>
<member name="M:FSharpx.DataStructures.BinaryTreeZipper.up``1(FSharpx.DataStructures.BinaryTreeZipper.BinaryTreeZipper{``0})">
<summary>
 Moves the zipper one level up
</summary>
</member>
<member name="M:FSharpx.DataStructures.BinaryTreeZipper.branch``1(``0)">
<summary>
 Creates a new branch with the label x and two leafs as subbranches
</summary>
</member>
<member name="T:FSharpx.DataStructures.BinaryTreeZipper">
<summary>
 TreeZipper
 original implementation taken from http://blog.xquant.net/?p=156
</summary>
</member>
<member name="M:FSharpx.DataStructures.BinomialHeap.tryUncons``1(FSharpx.DataStructures.BinomialHeap{``0})">
<summary>
 O(log n). Returns option head element and tail.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BinomialHeap.uncons``1(FSharpx.DataStructures.BinomialHeap{``0})">
<summary>
 O(log n). Returns the head element and tail.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BinomialHeap.tryGetTail``1(FSharpx.DataStructures.BinomialHeap{``0})">
<summary>
O(log n). Returns option heap of the elements trailing the head
</summary>
</member>
<member name="M:FSharpx.DataStructures.BinomialHeap.tail``1(FSharpx.DataStructures.BinomialHeap{``0})">
<summary>
O(log n). Returns a new heap of the elements trailing the head.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BinomialHeap.ofSeq``1(System.Boolean,System.Collections.Generic.IEnumerable{``0})">
<summary>
O(log n). Returns heap from the sequence.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BinomialHeap.tryMerge``1(FSharpx.DataStructures.BinomialHeap{``0},FSharpx.DataStructures.BinomialHeap{``0})">
<summary>
O(log n). Returns heap option from merging two heaps.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BinomialHeap.merge``1(FSharpx.DataStructures.BinomialHeap{``0},FSharpx.DataStructures.BinomialHeap{``0})">
<summary>
O(log n) Returns heap from merging two heaps, both must have same isDescending.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BinomialHeap.length``1(FSharpx.DataStructures.BinomialHeap{``0})">
<summary>
O(log n). Returns the count of elememts.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BinomialHeap.isDescending``1(FSharpx.DataStructures.BinomialHeap{``0})">
<summary>
O(1). Returns true if the heap has max element at head.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BinomialHeap.isEmpty``1(FSharpx.DataStructures.BinomialHeap{``0})">
<summary>
O(1). Returns true if the heap has no elements.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BinomialHeap.insert``1(``0,FSharpx.DataStructures.BinomialHeap{``0})">
<summary>
O(log n). Returns a new heap with the element inserted.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BinomialHeap.tryGetHead``1(FSharpx.DataStructures.BinomialHeap{``0})">
<summary>
O(log n). Returns option first min or max element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BinomialHeap.head``1(FSharpx.DataStructures.BinomialHeap{``0})">
<summary>
O(log n). Returns the min or max element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BinomialHeap.empty``1(System.Boolean)">
<summary>
O(1). Returns a empty heap.
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.DataStructures.BinomialHeap">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.BootstrappedQueue.ofList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
O(1). Returns a queue of the list.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BootstrappedQueue.length``1(FSharpx.DataStructures.BootstrappedQueue.BootstrappedQueue{``0})">
<summary>
O(1). Returns the count of elememts.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BootstrappedQueue.tryGetTail``1(FSharpx.DataStructures.BootstrappedQueue.BootstrappedQueue{``0})">
<summary>
O(log* n), worst case. Returns option queue of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BootstrappedQueue.tail``1(FSharpx.DataStructures.BootstrappedQueue.BootstrappedQueue{``0})">
<summary>
O(log* n), worst case. Returns a new queue of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BootstrappedQueue.tryGetHead``1(FSharpx.DataStructures.BootstrappedQueue.BootstrappedQueue{``0})">
<summary>
O(1), worst case.  Returns option first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BootstrappedQueue.head``1(FSharpx.DataStructures.BootstrappedQueue.BootstrappedQueue{``0})">
<summary>
O(1), worst case. Returns the first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BootstrappedQueue.snoc``1(``0,FSharpx.DataStructures.BootstrappedQueue.BootstrappedQueue{``0})">
<summary>
O(log* n). Returns a new queue with the element added to the end.
</summary>
</member>
<member name="M:FSharpx.DataStructures.BootstrappedQueue.isEmpty``1(FSharpx.DataStructures.BootstrappedQueue.BootstrappedQueue{``0})">
<summary>
O(1). Returns true if the queue has no elements
</summary>
</member>
<member name="M:FSharpx.DataStructures.BootstrappedQueue.empty``1">
<summary>
O(1). Returns queue of no elements.
</summary>
</member>
<member name="T:FSharpx.DataStructures.BootstrappedQueue">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.DataStructures.BottomUpMergeSort">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.DListModule.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,FSharpx.DataStructures.DList{``1})">
<summary>
 Fold walks the DList using constant stack space. Implementation is from Norman Ramsey.
 See http://stackoverflow.com/questions/5324623/functional-o1-append-and-on-iteration-from-first-element-list-data-structure/5334068#5334068
</summary>
</member>
<member name="M:FSharpx.DataStructures.DListModule.tail``1(FSharpx.DataStructures.DList{``0})">
<summary>
O(log n). Returns a new DList of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.DListModule.snoc``1(FSharpx.DataStructures.DList{``0},``0)">
<summary>
O(1). Returns a new DList with the element added to the end.
</summary>
</member>
<member name="M:FSharpx.DataStructures.DListModule.head``1(FSharpx.DataStructures.DList{``0})">
<summary>
O(log n). Returns the first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.DListModule.append``1(FSharpx.DataStructures.DList{``0},FSharpx.DataStructures.DList{``0})">
<summary>
O(1). Returns a new DList of two lists.
</summary>
</member>
<member name="M:FSharpx.DataStructures.DListModule.cons``1(``0,FSharpx.DataStructures.DList{``0})">
<summary>
O(1). Returns a new DList with the element added to the beginning.
</summary>
</member>
<member name="M:FSharpx.DataStructures.DListModule.toSeq``1(FSharpx.DataStructures.DList{``0})">
<summary>
O(n). Returns a seq of the DList elements.
</summary>
</member>
<member name="M:FSharpx.DataStructures.DListModule.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
O(n). Returns a DList of the seq.
</summary>
</member>
<member name="M:FSharpx.DataStructures.DListModule.singleton``1(``0)">
<summary>
O(1). Returns DList of one elements.
</summary>
</member>
<member name="M:FSharpx.DataStructures.DListModule.length``1(FSharpx.DataStructures.DList{``0})">
<summary>
O(1). Returns the count of elememts.
</summary>
</member>
<member name="M:FSharpx.DataStructures.DListModule.isEmpty``1(FSharpx.DataStructures.DList{``0})">
<summary>
O(1). Returns true if the DList has no elements.
</summary>
</member>
<member name="M:FSharpx.DataStructures.DListModule.empty``1">
<summary>
O(1). Returns DList of no elements.
</summary>
</member>
<member name="T:FSharpx.DataStructures.DListModule">

</member>
<member name="M:FSharpx.DataStructures.DequeModule.tryUpdate``1(System.Int32,``0,FSharpx.DataStructures.Deque{``0})">
<summary>
O(n), worst case. Returns option deque with element updated by index.
</summary>
</member>
<member name="M:FSharpx.DataStructures.DequeModule.update``1(System.Int32,``0,FSharpx.DataStructures.Deque{``0})">
<summary>
O(n), worst case. Returns deque with element updated by index.
</summary>
</member>
<member name="M:FSharpx.DataStructures.DequeModule.tryUnsnoc``1(FSharpx.DataStructures.Deque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns option init and the last element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.DequeModule.unsnoc``1(FSharpx.DataStructures.Deque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns init and the last element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.DequeModule.tryUncons``1(FSharpx.DataStructures.Deque{``0})">
<summary>
O(1) amortized, /O(n), worst case. Returns option first element and tail.
</summary>
</member>
<member name="M:FSharpx.DataStructures.DequeModule.uncons``1(FSharpx.DataStructures.Deque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns the first element and tail.
</summary>
</member>
<member name="M:FSharpx.DataStructures.DequeModule.tryGetTail``1(FSharpx.DataStructures.Deque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns option deque of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.DequeModule.tail``1(FSharpx.DataStructures.Deque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns a new deque of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.DequeModule.snoc``1(``0,FSharpx.DataStructures.Deque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns a new deque with the element added to the end.
</summary>
</member>
<member name="M:FSharpx.DataStructures.DequeModule.singleton``1(``0)">
<summary>
O(1). Returns a deque of one element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.DequeModule.rev``1(FSharpx.DataStructures.Deque{``0})">
<summary>
O(1). Returns deque reversed.
</summary>
</member>
<member name="M:FSharpx.DataStructures.DequeModule.tryRemove``1(System.Int32,FSharpx.DataStructures.Deque{``0})">
<summary>
O(n), worst case. Returns option deque with element removed by index.
</summary>
</member>
<member name="M:FSharpx.DataStructures.DequeModule.remove``1(System.Int32,FSharpx.DataStructures.Deque{``0})">
<summary>
O(n), worst case. Returns deque with element removed by index.
</summary>
</member>
<member name="M:FSharpx.DataStructures.DequeModule.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
O(n/2). Returns a deque of the seq.
</summary>
</member>
<member name="M:FSharpx.DataStructures.DequeModule.ofCatLists``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
O(ys). Returns a deque of the two lists concatenated.
</summary>
</member>
<member name="M:FSharpx.DataStructures.DequeModule.tryLookup``1(System.Int32,FSharpx.DataStructures.Deque{``0})">
<summary>
O(n), worst case. Returns option element by index.
</summary>
</member>
<member name="M:FSharpx.DataStructures.DequeModule.lookup``1(System.Int32,FSharpx.DataStructures.Deque{``0})">
<summary>
O(n), worst case. Returns element by index.
</summary>
</member>
<member name="M:FSharpx.DataStructures.DequeModule.length``1(FSharpx.DataStructures.Deque{``0})">
<summary>
O(1). Returns the count of elememts.
</summary>
</member>
<member name="M:FSharpx.DataStructures.DequeModule.tryGetLast``1(FSharpx.DataStructures.Deque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns option last element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.DequeModule.last``1(FSharpx.DataStructures.Deque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns the last element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.DequeModule.isEmpty``1(FSharpx.DataStructures.Deque{``0})">
<summary>
O(1). Returns true if the deque has no elements.
</summary>
</member>
<member name="M:FSharpx.DataStructures.DequeModule.tryGetInit``1(FSharpx.DataStructures.Deque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns option deque of the elements before the last element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.DequeModule.init``1(FSharpx.DataStructures.Deque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns a new deque of the elements before the last element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.DequeModule.tryGetHead``1(FSharpx.DataStructures.Deque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns option first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.DequeModule.head``1(FSharpx.DataStructures.Deque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns the first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.DequeModule.empty``1">
<summary>
O(1). Returns deque of no elements.
</summary>
</member>
<member name="M:FSharpx.DataStructures.DequeModule.cons``1(``0,FSharpx.DataStructures.Deque{``0})">
<summary>
O(n), worst case. Returns a new deque with the element added to the beginning.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.DataStructures.DequeModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.DataStructures.Exceptions">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.DataStructures.HeapPriorityQueue">

</member>
<member name="M:FSharpx.DataStructures.HoodMelvilleQueueModule.tryUncons``1(FSharpx.DataStructures.HoodMelvilleQueue{``0})">
<summary>
returns option first element and tail
</summary>
</member>
<member name="M:FSharpx.DataStructures.HoodMelvilleQueueModule.uncons``1(FSharpx.DataStructures.HoodMelvilleQueue{``0})">
<summary>
returns the first element and tail
</summary>
</member>
<member name="M:FSharpx.DataStructures.HoodMelvilleQueueModule.tryGetTail``1(FSharpx.DataStructures.HoodMelvilleQueue{``0})">
<summary>
returns option queue of the elements trailing the first element
</summary>
</member>
<member name="M:FSharpx.DataStructures.HoodMelvilleQueueModule.tail``1(FSharpx.DataStructures.HoodMelvilleQueue{``0})">
<summary>
returns a new queue of the elements trailing the first element
</summary>
</member>
<member name="M:FSharpx.DataStructures.HoodMelvilleQueueModule.snoc``1(``0,FSharpx.DataStructures.HoodMelvilleQueue{``0})">
<summary>
returns a new queue with the element added to the end
</summary>
</member>
<member name="M:FSharpx.DataStructures.HoodMelvilleQueueModule.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
returns a queue of the seq
</summary>
</member>
<member name="M:FSharpx.DataStructures.HoodMelvilleQueueModule.ofList``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
returns a queue of the list
</summary>
</member>
<member name="M:FSharpx.DataStructures.HoodMelvilleQueueModule.length``1(FSharpx.DataStructures.HoodMelvilleQueue{``0})">
<summary>
returns the count of elememts
</summary>
</member>
<member name="M:FSharpx.DataStructures.HoodMelvilleQueueModule.isEmpty``1(FSharpx.DataStructures.HoodMelvilleQueue{``0})">
<summary>
returns true if the queue has no elements
</summary>
</member>
<member name="M:FSharpx.DataStructures.HoodMelvilleQueueModule.tryGetHead``1(FSharpx.DataStructures.HoodMelvilleQueue{``0})">
<summary>
returns option first element
</summary>
</member>
<member name="M:FSharpx.DataStructures.HoodMelvilleQueueModule.head``1(FSharpx.DataStructures.HoodMelvilleQueue{``0})">
<summary>
returns the first element
</summary>
</member>
<member name="M:FSharpx.DataStructures.HoodMelvilleQueueModule.foldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},FSharpx.DataStructures.HoodMelvilleQueue{``0},``1)">
<summary>
applies a function to each element of the queue, threading an accumulator argument through the computation, right to left
</summary>
</member>
<member name="M:FSharpx.DataStructures.HoodMelvilleQueueModule.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,FSharpx.DataStructures.HoodMelvilleQueue{``1})">
<summary>
applies a function to each element of the queue, threading an accumulator argument through the computation, left to right
</summary>
</member>
<member name="M:FSharpx.DataStructures.HoodMelvilleQueueModule.empty``1">
<summary>
returns queue of no elements
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.DataStructures.HoodMelvilleQueueModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.ImplicitQueue.tryGetTail``1(FSharpx.DataStructures.ImplicitQueue.ImplicitQueue{``0})">
<summary>
O(1), amortized. Returns option queue of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.ImplicitQueue.tail``1(FSharpx.DataStructures.ImplicitQueue.ImplicitQueue{``0})">
<summary>
O(1), amortized. Returns a new queue of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.ImplicitQueue.tryGetHead``1(FSharpx.DataStructures.ImplicitQueue.ImplicitQueue{``0})">
<summary>
O(1), amortized. Returns option first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.ImplicitQueue.head``1(FSharpx.DataStructures.ImplicitQueue.ImplicitQueue{``0})">
<summary>
O(1), amortized. Returns the first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.ImplicitQueue.snoc``1(``0,FSharpx.DataStructures.ImplicitQueue.ImplicitQueue{``0})">
<summary>
O(1), amortized. Returns a new queue with the element added to the end.
</summary>
</member>
<member name="M:FSharpx.DataStructures.ImplicitQueue.isEmpty``1(FSharpx.DataStructures.ImplicitQueue.ImplicitQueue{``0})">
<summary>
O(1). Returns true if the queue has no elements
</summary>
</member>
<member name="M:FSharpx.DataStructures.ImplicitQueue.empty``1">
<summary>
O(1). Returns queue of no elements.
</summary>
</member>
<member name="T:FSharpx.DataStructures.ImplicitQueue">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.IntMap.isProperSubmapOf``1(FSharpx.DataStructures.IntMap{``0},FSharpx.DataStructures.IntMap{``0})">
<summary>
O(n+m). Is this a proper submap? (ie. a submap but not equal). Defined as (isProperSubmapOf = isProperSubmapOfBy (==)). Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.isProperSubmapOfBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},FSharpx.DataStructures.IntMap{``0},FSharpx.DataStructures.IntMap{``1})">
<summary>
O(n+m). Is this a proper submap? (ie. a submap but not equal). The expression (isProperSubmapOfBy f m1 m2) returns True when m1 and m2 are not equal, all keys in m1 are in m2, and when f returns True when applied to their respective values.  Credit: Haskell.org
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.IntMap.isSubmapOf``1(FSharpx.DataStructures.IntMap{``0},FSharpx.DataStructures.IntMap{``0})">
<summary>
O(n+m). Is this a submap? Defined as (isSubmapOf = isSubmapOfBy (==)). Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.isSubmapOfBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},FSharpx.DataStructures.IntMap{``0},FSharpx.DataStructures.IntMap{``1})">
<summary>
O(n+m). The expression (isSubmapOfBy f m1 m2) returns True if all keys in m1 are in m2, and when f returns True when applied to their respective values. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.mapKeysWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Int32})">
<summary>
O(n*log n). mapKeysWith c f s is the map obtained by applying f to each key of s. The size of the result may be smaller if f maps two or more distinct keys to the same new key. In this case the associated values will be combined using c. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.mapKeys``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Int32})">
<summary>
O(n*min(n,W)). mapKeys f s is the map obtained by applying f to each key of s. The size of the result may be smaller if f maps two or more distinct keys to the same new key. In this case the value at the greatest of the original keys is retained. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.ofArrayWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Tuple{System.Int32,``0}[])">
<summary>
O(n*min(n,W)). Create a map from an array of key/value pairs with a combining function. See also fromAscListWith. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.ofArrayWithKey``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}}},System.Tuple{System.Int32,``0}[])">
<summary>
O(n*min(n,W)). Build a map from an array of key/value pairs with a combining function. See also fromAscListWithKey&apos;. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.ofArray``1(System.Tuple{System.Int32,``0}[])">
<summary>
O(n*min(n,W)). Create a map from an array of key/value pairs. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.ofSeqWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Collections.Generic.IEnumerable{System.Tuple{System.Int32,``0}})">
<summary>
O(n*min(n,W)). Create a map from a seq of key/value pairs with a combining function. See also fromAscListWith. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.ofSeqWithKey``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}}},System.Collections.Generic.IEnumerable{System.Tuple{System.Int32,``0}})">
<summary>
O(n*min(n,W)). Build a map from a seq of key/value pairs with a combining function. See also fromAscListWithKey&apos;. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.ofSeq``1(System.Collections.Generic.IEnumerable{System.Tuple{System.Int32,``0}})">
<summary>
O(n*min(n,W)). Create a map from a seq of key/value pairs. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.ofListWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,``0}})">
<summary>
O(n*min(n,W)). Create a map from a list of key/value pairs with a combining function. See also fromAscListWith. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.ofListWithKey``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}}},Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,``0}})">
<summary>
O(n*min(n,W)). Build a map from a list of key/value pairs with a combining function. See also fromAscListWithKey&apos;. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.ofList``1(Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,``0}})">
<summary>
O(n*min(n,W)). Create a map from a list of key/value pairs. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.toArray``1(FSharpx.DataStructures.IntMap{``0})">
<summary>
O(n). Convert the map to an array of key/value pairs. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.toSeq``1(FSharpx.DataStructures.IntMap{``0})">
<summary>
O(n). Convert the map to a seq of key/value pairs. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.toList``1(FSharpx.DataStructures.IntMap{``0})">
<summary>
O(n). Convert the map to a list of key/value pairs. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.keys``1(FSharpx.DataStructures.IntMap{``0})">
<summary>
O(n). Return all keys of the map in ascending order. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.values``1(FSharpx.DataStructures.IntMap{``0})">
<summary>
O(n). Return all elements of the map in the ascending order of their keys. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.foldWithKey``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}},``0)">
<summary>
O(n). Fold the keys and values in the map, such that foldWithKey f z == Prelude.foldr (uncurry f) z . toAscList. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.foldBackWithKey``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}}},``1,FSharpx.DataStructures.IntMap{``0})">
<summary>
O(n). FoldBack the keys and values in the map, such that foldWithKey f z == Prelude.foldr (uncurry f) z . toAscList. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0)">
<summary>
O(n). Fold the values in the map, such that fold f z == Prelude.foldr f z . elems. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.foldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},``1)">
<summary>
O(n). FoldBack the values in the map, such that fold f z == Prelude.foldr f z . elems. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.splitTryFind``1(System.Int32,FSharpx.DataStructures.IntMap{``0})">
<summary>
O(log n). Performs a split but also returns whether the pivot key was found in the original map. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.split``1(System.Int32,FSharpx.DataStructures.IntMap{``0})">
<summary>
O(log n). The expression (split k map) is a pair (map1,map2) where all keys in map1 are lower than k and all keys in map2 larger than k. Any key equal to k is found in neither map1 nor map2. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.mapChoice``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}})">
<summary>
O(n). Map values and separate the Left and Right results. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.mapChoiceWithKey``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}}},FSharpx.DataStructures.IntMap{``0})">
<summary>
O(n). Map keys/values and separate the Left and Right results. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.mapOption``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}})">
<summary>
O(n). Map values and collect the Just results. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.mapOptionWithKey``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}}},FSharpx.DataStructures.IntMap{``0})">
<summary>
O(n). Map keys/values and collect the Just results. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.partition``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},FSharpx.DataStructures.IntMap{``0})">
<summary>
O(n). partition the map according to some predicate. The first map contains all elements that satisfy the predicate, the second all elements that fail the predicate. See also split. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.partitionWithKey``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},FSharpx.DataStructures.IntMap{``0})">
<summary>
O(n). partition the map according to some predicate. The first map contains all elements that satisfy the predicate, the second all elements that fail the predicate. See also split. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},FSharpx.DataStructures.IntMap{``0})">
<summary>
O(n). Filter all values that satisfy some predicate. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.filterWithKey``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},FSharpx.DataStructures.IntMap{``0})">
<summary>
O(n). Filter all keys/values that satisfy some predicate. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.mapAccum``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``0,``2}}})">
<summary>
O(n). The function mapAccumWithKey threads an accumulating argument through the map in ascending order of keys. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.mapAccumWithKey``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``0,``2}}}},``0,FSharpx.DataStructures.IntMap{``1})">
<summary>
O(n). The function mapAccum threads an accumulating argument through the map in ascending order of keys. Credit: Haskell.org
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.IntMap.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharpx.DataStructures.IntMap{``0})">
<summary>
O(n). Map a function over all values in the map. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.mapWithKey``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},FSharpx.DataStructures.IntMap{``0})">
<summary>
O(n). Map a function over all values in the map. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.deleteMax``1(FSharpx.DataStructures.IntMap{``0})">
<summary>
O(log n). Delete the maximal key. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.deleteMin``1(FSharpx.DataStructures.IntMap{``0})">
<summary>
O(log n). Delete the minimal key. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.findMax``1(FSharpx.DataStructures.IntMap{``0})">
<summary>
O(log n). The maximal key of the map. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.findMin``1(FSharpx.DataStructures.IntMap{``0})">
<summary>
O(log n). The minimal key of the map. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.deleteFindMin``1(FSharpx.DataStructures.IntMap{``0})">
<summary>
O(log n). Retrieves the minimal key of the map, and the map stripped from that element. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.deleteFindMax``1(FSharpx.DataStructures.IntMap{``0})">
<summary>
O(log n). Retrieves the maximal key of the map, and the map stripped from that element. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.minView``1(FSharpx.DataStructures.IntMap{``0})">
<summary>
O(min(n,W)). Retrieves the minimal key of the map, and the map stripped of that element, or Nothing if passed an empty map. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.maxView``1(FSharpx.DataStructures.IntMap{``0})">
<summary>
O(min(n,W)). Retrieves the maximal key of the map, and the map stripped of that element, or Nothing if passed an empty map. Credit: Haskell.org
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.IntMap.updateMin``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
O(log n). Update the value at the minimal key. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.updateMax``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
O(log n). Update the value at the maximal key. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.minViewWithKey``1(FSharpx.DataStructures.IntMap{``0})">
<summary>
O(log n). Retrieves the minimal (key,value) couple of the map, and the map stripped from that element. fails (in the monad) when passed an empty map. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.maxViewWithKey``1(FSharpx.DataStructures.IntMap{``0})">
<summary>
O(log n). Retrieves the maximal (key,value) couple of the map, and the map stripped from that element. fails (in the monad) when passed an empty map. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.updateMaxWithKey``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``0}}},FSharpx.DataStructures.IntMap{``0})">
<summary>
O(log n). Update the value at the maximal key. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.updateMinWithKey``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``0}}},FSharpx.DataStructures.IntMap{``0})">
<summary>
O(log n). Update the value at the minimal key. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.intersectionWith``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},FSharpx.DataStructures.IntMap{``0},FSharpx.DataStructures.IntMap{``1})">
<summary>
O(n+m). The intersection with a combining function. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.intersectionWithKey``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},FSharpx.DataStructures.IntMap{``0},FSharpx.DataStructures.IntMap{``1})">
<summary>
O(n+m). The intersection with a combining function. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.intersection``2(FSharpx.DataStructures.IntMap{``0},FSharpx.DataStructures.IntMap{``1})">
<summary>
O(n+m). The (left-biased) intersection of two maps (based on keys). Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.differenceWith``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``0}}},FSharpx.DataStructures.IntMap{``0},FSharpx.DataStructures.IntMap{``1})">
<summary>
O(n+m). Difference with a combining function. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.differenceWithKey``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``0}}}},FSharpx.DataStructures.IntMap{``0},FSharpx.DataStructures.IntMap{``1})">
<summary>
O(n+m). Difference with a combining function. When two equal keys are encountered, the combining function is applied to the key and both values. If it returns Nothing, the element is discarded (proper set difference). If it returns (Just y), the element is updated with a new value y. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.difference``2(FSharpx.DataStructures.IntMap{``0},FSharpx.DataStructures.IntMap{``1})">
<summary>
O(n+m). Difference between two maps (based on keys). Credit: Haskell.org
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.IntMap.mergeWithKey``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``2}}}},Microsoft.FSharp.Core.FSharpFunc{FSharpx.DataStructures.IntMap{``0},FSharpx.DataStructures.IntMap{``2}},Microsoft.FSharp.Core.FSharpFunc{FSharpx.DataStructures.IntMap{``1},FSharpx.DataStructures.IntMap{``2}})">
<summary>
Refer to Haskell documentation. Unexpected code growth or corruption of the data structure can occure from wrong use. Credit: Haskell.org
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.IntMap.alter``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``0}},System.Int32,FSharpx.DataStructures.IntMap{``0})">
<summary>
O(log n). The expression (alter f k map) alters the value x at k, or absence thereof. alter can be used to insert, delete, or update a value in an IntMap. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.updateTryFindWithKey``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``0}}},System.Int32,FSharpx.DataStructures.IntMap{``0})">
<summary>
O(min(n,W)). Lookup and update. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.adjust``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0},System.Int32,FSharpx.DataStructures.IntMap{``0})">
<summary>
O(min(n,W)). Adjust a value at a specific key. When the key is not a member of the map, the original map is returned. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.adjustWithKey``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Int32,FSharpx.DataStructures.IntMap{``0})">
<summary>
O(min(n,W)). Adjust a value at a specific key. When the key is not a member of the map, the original map is returned. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.update``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``0}},System.Int32,FSharpx.DataStructures.IntMap{``0})">
<summary>
O(min(n,W)). The expression (update f k map) updates the value x at k (if it is in the map). If (f x) is Nothing, the element is deleted. If it is (Just y), the key k is bound to the new value y. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.updateWithKey``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``0}}},System.Int32,FSharpx.DataStructures.IntMap{``0})">
<summary>
O(min(n,W)). The expression (update f k map) updates the value x at k (if it is in the map). If (f k x) is Nothing, the element is deleted. If it is (Just y), the key k is bound to the new value y. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.delete``1(System.Int32,FSharpx.DataStructures.IntMap{``0})">
<summary>
O(min(n,W)). Delete a key and its value from the map. When the key is not a member of the map, the original map is returned. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.insertTryFindWithKey``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}}},System.Int32,``0,FSharpx.DataStructures.IntMap{``0})">
<summary>
O(min(n,W)). The expression (insertLookupWithKey f k x map) is a pair where the first element is equal to (lookup k map) and the second element equal to (insertWithKey f k x map). Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.insertWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Int32,``0,FSharpx.DataStructures.IntMap{``0})">
<summary>
O(min(n,W)). Insert with a combining function. insertWith f key value mp will insert the pair (key, value) into mp if key does not exist in the map. If the key does exist, the function will insert f new_value old_value. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.insertWithKey``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}}},System.Int32,``0,FSharpx.DataStructures.IntMap{``0})">
<summary>
O(min(n,W)). Insert with a combining function. insertWithKey f key value mp will insert the pair (key, value) into mp if key does not exist in the map. If the key does exist, the function will insert f key new_value old_value. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.insert``1(System.Int32,``0,FSharpx.DataStructures.IntMap{``0})">
<summary>
O(min(n,W)). Insert a new key/value pair in the map. If the key is already present in the map, the associated value is replaced with the supplied value, i.e. insert is equivalent to insertWith const. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.singleton``1(System.Int32,``0)">
<summary>
O(1). A map of one element. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.empty``1">
<summary>
O(1). The empty map. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.tryFindGE``1(System.Int32,FSharpx.DataStructures.IntMap{``0})">
<summary>
O(log n). Find smallest key greater or equal to the given one and return the corresponding (key, value) pair Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.tryFindLE``1(System.Int32,FSharpx.DataStructures.IntMap{``0})">
<summary>
O(log n). Find largest key smaller or equal to the given one and return the corresponding (key, value) pair. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.tryFindGT``1(System.Int32,FSharpx.DataStructures.IntMap{``0})">
<summary>
O(log n). Find smallest key greater than the given one and return the corresponding (key, value) pair. Credit: Haskell.org
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.IntMap.tryFindLT``1(System.Int32,FSharpx.DataStructures.IntMap{``0})">
<summary>
O(log n). Find largest key smaller than the given one and return the corresponding (key, value) pair.  Credit: Haskell.org
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.IntMap.findWithDefault``1(``0,System.Int32,FSharpx.DataStructures.IntMap{``0})">
<summary>
O(min(n,W)). The expression (findWithDefault def k map) returns the value at key k or returns def when the key is not an element of the map.  Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.find``1(System.Int32,FSharpx.DataStructures.IntMap{``0})">
<summary>
O(min(n,W)). Lookup the value at a key in the map. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.notExists``1(System.Int32,FSharpx.DataStructures.IntMap{``0})">
<summary>
O(log n). Is the key not a member of the map? Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.exists``1(System.Int32,FSharpx.DataStructures.IntMap{``0})">
<summary>
O(min(n,W)). Is the key a member of the map? Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.tryFind``1(System.Int32,FSharpx.DataStructures.IntMap{``0})">
<summary>
O(min(n,W)). Lookup the value at a key in the map. Returns &apos;a option. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.size``1(FSharpx.DataStructures.IntMap{``0})">
<summary>
O(n). Number of elements in the map. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.DataStructures.IntMap.isEmpty``1(FSharpx.DataStructures.IntMap{``0})">
<summary>
O(1). Map is empty.  Credit: Haskell.org
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.DataStructures.IntMap">

</member>
<member name="P:FSharpx.DataStructures.Interfaces.IRandomAccessList`1.Uncons">
<summary>
returns the first element and tail
</summary>
</member>
<member name="P:FSharpx.DataStructures.Interfaces.IRandomAccessList`1.TryUncons">
<summary>
returns the option first element and tail
</summary>
</member>
<member name="P:FSharpx.DataStructures.Interfaces.IRandomAccessList`1.TryGetTail">
<summary>
returns a option random access list of the elements trailing the first element
</summary>
</member>
<member name="P:FSharpx.DataStructures.Interfaces.IRandomAccessList`1.TryGetHead">
<summary>
returns option first element 
</summary>
</member>
<member name="P:FSharpx.DataStructures.Interfaces.IRandomAccessList`1.Tail">
<summary>
returns a new random access list of the elements trailing the first element
</summary>
</member>
<member name="P:FSharpx.DataStructures.Interfaces.IRandomAccessList`1.IsEmpty">
<summary>
returns true if the random access list has no elements
</summary>
</member>
<member name="P:FSharpx.DataStructures.Interfaces.IRandomAccessList`1.Head">
<summary>
returns the first element
</summary>
</member>
<member name="M:FSharpx.DataStructures.Interfaces.IRandomAccessList`1.Update(System.Int32,`0)">
<summary>
returns random access list with element updated by index
</summary>
</member>
<member name="M:FSharpx.DataStructures.Interfaces.IRandomAccessList`1.TryUpdate(System.Int32,`0)">
<summary>
returns option random access list with element updated by index
</summary>
</member>
<member name="M:FSharpx.DataStructures.Interfaces.IRandomAccessList`1.TryLookup(System.Int32)">
<summary>
returns option element by index
</summary>
</member>
<member name="M:FSharpx.DataStructures.Interfaces.IRandomAccessList`1.Rev">
<summary>
returns random access list reversed
</summary>
</member>
<member name="M:FSharpx.DataStructures.Interfaces.IRandomAccessList`1.Lookup(System.Int32)">
<summary>
returns element by index
</summary>
</member>
<member name="M:FSharpx.DataStructures.Interfaces.IRandomAccessList`1.Length">
<summary>
returns the count of elememts
</summary>
</member>
<member name="M:FSharpx.DataStructures.Interfaces.IRandomAccessList`1.Count">
<summary>
returns the count of elememts
</summary>
</member>
<member name="M:FSharpx.DataStructures.Interfaces.IRandomAccessList`1.Cons(`0)">
<summary>
returns a new random access list with the element added to the beginning
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.Interfaces.IPriorityQueue`1.IsEmpty">
<summary>
returns true if the queue has no elements
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.Interfaces.IPriorityQueue`1.TryPeek">
<summary>
returns option first element
</summary>
</member>
<member name="M:FSharpx.DataStructures.Interfaces.IPriorityQueue`1.Pop">
<summary>
returns the first element and tail
</summary>
</member>
<member name="M:FSharpx.DataStructures.Interfaces.IPriorityQueue`1.Peek">
<summary>
returns the first element
</summary>
</member>
<member name="M:FSharpx.DataStructures.Interfaces.IPriorityQueue`1.Insert(`0)">
<summary>
returns a new queue with the element added to the end
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.Interfaces.IQueue`1.Uncons">
<summary>
returns the first element and tail
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.Interfaces.IQueue`1.TryGetTail">
<summary>
returns option queue of the elements trailing the first element
</summary>
</member>
<member name="P:FSharpx.DataStructures.Interfaces.IQueue`1.TryGetHead">
<summary>
returns option first element
</summary>
</member>
<member name="P:FSharpx.DataStructures.Interfaces.IQueue`1.Tail">
<summary>
returns a new queue of the elements trailing the first element
</summary>
</member>
<member name="P:FSharpx.DataStructures.Interfaces.IQueue`1.IsEmpty">
<summary>
returns true if the queue has no elements
</summary>
</member>
<member name="P:FSharpx.DataStructures.Interfaces.IQueue`1.Head">
<summary>
returns the first element
</summary>
</member>
<member name="M:FSharpx.DataStructures.Interfaces.IQueue`1.Snoc(`0)">
<summary>
returns a new queue with the element added to the end
</summary>
</member>
<member name="M:FSharpx.DataStructures.Interfaces.IQueue`1.Length">
<summary>
returns the count of elememts
</summary>
</member>
<member name="M:FSharpx.DataStructures.Interfaces.IQueue`1.Count">
<summary>
returns the count of elememts
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.Interfaces.IHeap`2.Uncons">
<summary>
returns the head element and tail
</summary>
</member>
<member name="M:FSharpx.DataStructures.Interfaces.IHeap`2.TryUncons">
<summary>
returns option head element and tail
</summary>
</member>
<member name="M:FSharpx.DataStructures.Interfaces.IHeap`2.TryMerge(`0)">
<summary>
returns heap option from merging two heaps
</summary>
</member>
<member name="M:FSharpx.DataStructures.Interfaces.IHeap`2.TryGetTail">
<summary>
returns option heap of the elements trailing the head
</summary>
</member>
<member name="M:FSharpx.DataStructures.Interfaces.IHeap`2.Tail">
<summary>
returns a new heap of the elements trailing the head
</summary>
</member>
<member name="M:FSharpx.DataStructures.Interfaces.IHeap`2.Merge(`0)">
<summary>
returns heap from merging two heaps, both must have same isDescending
</summary>
</member>
<member name="M:FSharpx.DataStructures.Interfaces.IHeap`2.Insert(`1)">
<summary>
returns a new heap with the element inserted
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.Interfaces.IHeap`1.IsEmpty">
<summary>
returns true if the heap has no elements
</summary>
</member>
<member name="P:FSharpx.DataStructures.Interfaces.IHeap`1.IsDescending">
<summary>
returns true if the heap has max element at head
</summary>
</member>
<member name="M:FSharpx.DataStructures.Interfaces.IHeap`1.TryGetHead">
<summary>
returns option first min or max element
</summary>
</member>
<member name="M:FSharpx.DataStructures.Interfaces.IHeap`1.Length">
<summary>
returns the count of elememts
</summary>
</member>
<member name="M:FSharpx.DataStructures.Interfaces.IHeap`1.Head">
<summary>
returns the min or max element
</summary>
</member>
<member name="M:FSharpx.DataStructures.Interfaces.IHeap`1.Count">
<summary>
returns the count of elememts
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.Interfaces.IDeque`1.Unsnoc">
<summary>
returns init and the last element
</summary>
</member>
<member name="P:FSharpx.DataStructures.Interfaces.IDeque`1.Uncons">
<summary>
returns the first element and tail
</summary>
</member>
<member name="P:FSharpx.DataStructures.Interfaces.IDeque`1.TryUnsnoc">
<summary>
returns option init and the last element
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.Interfaces.IDeque`1.TryGetTail">
<summary>
returns option deque of the elements trailing the first element
</summary>
</member>
<member name="P:FSharpx.DataStructures.Interfaces.IDeque`1.TryGetLast">
<summary>
returns option last element
</summary>
</member>
<member name="P:FSharpx.DataStructures.Interfaces.IDeque`1.TryGetInit">
<summary>
returns option deque of the elements before the last element
</summary>
</member>
<member name="P:FSharpx.DataStructures.Interfaces.IDeque`1.TryGetHead">
<summary>
returns option first element
</summary>
</member>
<member name="P:FSharpx.DataStructures.Interfaces.IDeque`1.Tail">
<summary>
returns a new deque of the elements trailing the first element
</summary>
</member>
<member name="P:FSharpx.DataStructures.Interfaces.IDeque`1.Rev">
<summary>
returns deque reversed
</summary>
</member>
<member name="P:FSharpx.DataStructures.Interfaces.IDeque`1.Length">
<summary>
returns the count of elememts
</summary>
</member>
<member name="P:FSharpx.DataStructures.Interfaces.IDeque`1.Last">
<summary>
returns the last element
</summary>
</member>
<member name="P:FSharpx.DataStructures.Interfaces.IDeque`1.IsEmpty">
<summary>
returns true if the deque has no elements
</summary>
</member>
<member name="P:FSharpx.DataStructures.Interfaces.IDeque`1.Init">
<summary>
returns a new deque of the elements before the last element
</summary>
</member>
<member name="P:FSharpx.DataStructures.Interfaces.IDeque`1.Head">
<summary>
returns the first element
</summary>
</member>
<member name="P:FSharpx.DataStructures.Interfaces.IDeque`1.Count">
<summary>
returns the count of elememts
</summary>
</member>
<member name="M:FSharpx.DataStructures.Interfaces.IDeque`1.Update(System.Int32,`0)">
<summary>
returns deque with element updated by index
</summary>
</member>
<member name="M:FSharpx.DataStructures.Interfaces.IDeque`1.TryUpdate(System.Int32,`0)">
<summary>
returns option deque with element updated by index
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.Interfaces.IDeque`1.TryLookup(System.Int32)">
<summary>
returns option element by index
</summary>
</member>
<member name="M:FSharpx.DataStructures.Interfaces.IDeque`1.Snoc(`0)">
<summary>
returns a new deque with the element added to the end
</summary>
</member>
<member name="M:FSharpx.DataStructures.Interfaces.IDeque`1.Remove(System.Int32)">
<summary>
returns deque with element removed by index
</summary>
</member>
<member name="M:FSharpx.DataStructures.Interfaces.IDeque`1.Lookup(System.Int32)">
<summary>
returns element by index
</summary>
</member>
<member name="M:FSharpx.DataStructures.Interfaces.IDeque`1.Cons(`0)">
<summary>
returns a new deque with the element added to the beginning
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.DataStructures.Interfaces.IVector`1.Item(System.Int32)">
<summary>
 Returns the value at the index. If the index is out of bounds it throws an exception.
</summary>
</member>
<member name="M:FSharpx.DataStructures.Interfaces.IVector`1.Pop">
<summary>
 Returns a new vector without the last item. If the collection is empty it throws an exception.
</summary>
</member>
<member name="M:FSharpx.DataStructures.Interfaces.IVector`1.Peek">
<summary>
 Returns the last element in the vector. If the vector is empty it throws an exception.
</summary>
</member>
<member name="M:FSharpx.DataStructures.Interfaces.IVector`1.Count">
<summary>
 Returns the number of items in the collection.
</summary>
</member>
<member name="M:FSharpx.DataStructures.Interfaces.IVector`1.Conj(`0)">
<summary>
 Returns a new vector with the element &apos;added&apos; at the end.
</summary>
</member>
<member name="M:FSharpx.DataStructures.Interfaces.IVector`1.AssocN(System.Int32,`0)">
<summary>
 Returns a new vector that contains the given value at the index. Note - index must be &lt;= vector.Count.
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.DataStructures.Interfaces">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.DataStructures.LazyList">

</member>
<member name="M:FSharpx.DataStructures.LeftistHeapModule.tryUncons``1(FSharpx.DataStructures.LeftistHeap{``0})">
<summary>
O(log n). Returns option head element and tail.
</summary>
</member>
<member name="M:FSharpx.DataStructures.LeftistHeapModule.uncons``1(FSharpx.DataStructures.LeftistHeap{``0})">
<summary>
O(log n). Returns the head element and tail.
</summary>
</member>
<member name="M:FSharpx.DataStructures.LeftistHeapModule.tryGetTail``1(FSharpx.DataStructures.LeftistHeap{``0})">
<summary>
O(log n). Returns option heap of the elements trailing the head.
</summary>
</member>
<member name="M:FSharpx.DataStructures.LeftistHeapModule.tail``1(FSharpx.DataStructures.LeftistHeap{``0})">
<summary>
O(log n). Returns a new heap of the elements trailing the head.
</summary>
</member>
<member name="M:FSharpx.DataStructures.LeftistHeapModule.ofSeq``1(System.Boolean,System.Collections.Generic.IEnumerable{``0})">
<summary>
O(log n). Returns heap from the sequence.
</summary>
</member>
<member name="M:FSharpx.DataStructures.LeftistHeapModule.tryMerge``1(FSharpx.DataStructures.LeftistHeap{``0},FSharpx.DataStructures.LeftistHeap{``0})">
<summary>
O(log n). Returns heap option from merging two heaps.
</summary>
</member>
<member name="M:FSharpx.DataStructures.LeftistHeapModule.merge``1(FSharpx.DataStructures.LeftistHeap{``0},FSharpx.DataStructures.LeftistHeap{``0})">
<summary>
O(log n). Returns heap from merging two heaps, both must have same isDescending.
</summary>
</member>
<member name="M:FSharpx.DataStructures.LeftistHeapModule.length``1(FSharpx.DataStructures.LeftistHeap{``0})">
<summary>
O(1). Returns the count of elememts.
</summary>
</member>
<member name="M:FSharpx.DataStructures.LeftistHeapModule.isDescending``1(FSharpx.DataStructures.LeftistHeap{``0})">
<summary>
O(1). Returns true if the heap has max element at head.
</summary>
</member>
<member name="M:FSharpx.DataStructures.LeftistHeapModule.isEmpty``1(FSharpx.DataStructures.LeftistHeap{``0})">
<summary>
O(1). Returns true if the heap has no elements.
</summary>
</member>
<member name="M:FSharpx.DataStructures.LeftistHeapModule.insert``1(``0,FSharpx.DataStructures.LeftistHeap{``0})">
<summary>
O(log n). Returns a new heap with the element inserted.
</summary>
</member>
<member name="M:FSharpx.DataStructures.LeftistHeapModule.tryGetHead``1(FSharpx.DataStructures.LeftistHeap{``0})">
<summary>
O(1). Returns option first min or max element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.LeftistHeapModule.head``1(FSharpx.DataStructures.LeftistHeap{``0})">
<summary>
O(1). Returns the min or max element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.LeftistHeapModule.empty``1(System.Boolean)">
<summary>
O(1). Returns a empty heap.
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.DataStructures.LeftistHeapModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.DataStructures.ListHelpr">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.DataStructures.ListZipper.ListZipper`1">
<summary>
 A zipper for lists
</summary>
</member>
<member name="M:FSharpx.DataStructures.ListZipper.getList``1(FSharpx.DataStructures.ListZipper.ListZipper{``0})">
<summary>
 Returns the whole list from the zipper
</summary>
</member>
<member name="M:FSharpx.DataStructures.ListZipper.zipper``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Creates a list zipper
</summary>
</member>
<member name="M:FSharpx.DataStructures.ListZipper.front``1(FSharpx.DataStructures.ListZipper.ListZipper{``0})">
<summary>
 Moves the zipper to the front
</summary>
</member>
<member name="M:FSharpx.DataStructures.ListZipper.back``1(FSharpx.DataStructures.ListZipper.ListZipper{``0})">
<summary>
 Moves the zipper backwards
</summary>
</member>
<member name="M:FSharpx.DataStructures.ListZipper.forward``1(FSharpx.DataStructures.ListZipper.ListZipper{``0})">
<summary>
 Moves the zipper forward
</summary>
</member>
<member name="M:FSharpx.DataStructures.ListZipper.modify``1(``0,FSharpx.DataStructures.ListZipper.ListZipper{``0})">
<summary>
 Changes the element under the focus
</summary>
</member>
<member name="M:FSharpx.DataStructures.ListZipper.focus``1(FSharpx.DataStructures.ListZipper.ListZipper{``0})">
<summary>
 Returns the head element from the list under focus
</summary>
</member>
<member name="T:FSharpx.DataStructures.ListZipper">
<summary>
 ListZipper
 original implementation taken from http://learnyouahaskell.com/zippers
</summary>
</member>
<member name="M:FSharpx.DataStructures.PairingHeapModule.tryUncons``1(FSharpx.DataStructures.PairingHeap{``0})">
<summary>
O(log n) amortized time. Returns option head element and tail.
</summary>
</member>
<member name="M:FSharpx.DataStructures.PairingHeapModule.uncons``1(FSharpx.DataStructures.PairingHeap{``0})">
<summary>
O(log n) amortized time. Returns the head element and tail.
</summary>
</member>
<member name="M:FSharpx.DataStructures.PairingHeapModule.tryGetTail``1(FSharpx.DataStructures.PairingHeap{``0})">
<summary>
O(log n) amortized time. Returns option heap of the elements trailing the head.
</summary>
</member>
<member name="M:FSharpx.DataStructures.PairingHeapModule.tail``1(FSharpx.DataStructures.PairingHeap{``0})">
<summary>
O(log n) amortized time. Returns a new heap of the elements trailing the head.
</summary>
</member>
<member name="M:FSharpx.DataStructures.PairingHeapModule.ofSeq``1(System.Boolean,System.Collections.Generic.IEnumerable{``0})">
<summary>
O(n). Returns heap from the sequence.
</summary>
</member>
<member name="M:FSharpx.DataStructures.PairingHeapModule.tryMerge``1(FSharpx.DataStructures.PairingHeap{``0},FSharpx.DataStructures.PairingHeap{``0})">
<summary>
O(log n) amortized time. Returns heap option from merging two heaps.
</summary>
</member>
<member name="M:FSharpx.DataStructures.PairingHeapModule.merge``1(FSharpx.DataStructures.PairingHeap{``0},FSharpx.DataStructures.PairingHeap{``0})">
<summary>
O(log n) amortized time. Returns heap from merging two heaps, both must have same descending.
</summary>
</member>
<member name="M:FSharpx.DataStructures.PairingHeapModule.length``1(FSharpx.DataStructures.PairingHeap{``0})">
<summary>
O(n). Returns the count of elememts.
</summary>
</member>
<member name="M:FSharpx.DataStructures.PairingHeapModule.isDescending``1(FSharpx.DataStructures.PairingHeap{``0})">
<summary>
O(1). Returns true if the heap has max element at head.
</summary>
</member>
<member name="M:FSharpx.DataStructures.PairingHeapModule.isEmpty``1(FSharpx.DataStructures.PairingHeap{``0})">
<summary>
O(1) Returns true if the heap has no elements.
</summary>
</member>
<member name="M:FSharpx.DataStructures.PairingHeapModule.insert``1(``0,FSharpx.DataStructures.PairingHeap{``0})">
<summary>
O(log n) amortized time. Returns a new heap with the element inserted.
</summary>
</member>
<member name="M:FSharpx.DataStructures.PairingHeapModule.tryGetHead``1(FSharpx.DataStructures.PairingHeap{``0})">
<summary>
O(1) worst case. Returns option first min or max element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.PairingHeapModule.head``1(FSharpx.DataStructures.PairingHeap{``0})">
<summary>
O(1) worst case. Returns the min or max element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.PairingHeapModule.empty``1(System.Boolean)">
<summary>
O(1) Returns a empty heap.
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.DataStructures.PairingHeapModule">

</member>
<member name="M:FSharpx.DataStructures.PhysicistQueueModule.tryUncons``1(FSharpx.DataStructures.PhysicistQueue{``0})">
<summary>
O(1), amortized. Returns option first element and tail.
</summary>
</member>
<member name="M:FSharpx.DataStructures.PhysicistQueueModule.uncons``1(FSharpx.DataStructures.PhysicistQueue{``0})">
<summary>
O(1), amortized. Returns the first element and tail.
</summary>
</member>
<member name="M:FSharpx.DataStructures.PhysicistQueueModule.tryGetTail``1(FSharpx.DataStructures.PhysicistQueue{``0})">
<summary>
O(1), amortized. Returns option queue of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.PhysicistQueueModule.tail``1(FSharpx.DataStructures.PhysicistQueue{``0})">
<summary>
O(1), amortized. Returns a new queue of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.PhysicistQueueModule.snoc``1(``0,FSharpx.DataStructures.PhysicistQueue{``0})">
<summary>
O(1), amortized. Returns a new queue with the element added to the end.
</summary>
</member>
<member name="M:FSharpx.DataStructures.PhysicistQueueModule.rev``1(FSharpx.DataStructures.PhysicistQueue{``0})">
<summary>
O(1). Returns queue reversed.
</summary>
</member>
<member name="M:FSharpx.DataStructures.PhysicistQueueModule.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
O(1). Returns a queue of the seq.
</summary>
</member>
<member name="M:FSharpx.DataStructures.PhysicistQueueModule.ofList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
O(1). Returns a queue of the list.
</summary>
</member>
<member name="M:FSharpx.DataStructures.PhysicistQueueModule.length``1(FSharpx.DataStructures.PhysicistQueue{``0})">
<summary>
O(1). Returns the count of elememts.
</summary>
</member>
<member name="M:FSharpx.DataStructures.PhysicistQueueModule.isEmpty``1(FSharpx.DataStructures.PhysicistQueue{``0})">
<summary>
O(1). Returns true if the queue has no elements.
</summary>
</member>
<member name="M:FSharpx.DataStructures.PhysicistQueueModule.tryGetHead``1(FSharpx.DataStructures.PhysicistQueue{``0})">
<summary>
O(1), amortized. Returns option first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.PhysicistQueueModule.head``1(FSharpx.DataStructures.PhysicistQueue{``0})">
<summary>
O(1), amortized. Returns the first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.PhysicistQueueModule.foldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},FSharpx.DataStructures.PhysicistQueue{``0},``1)">
<summary>
O(n). Applies a function to each element of the queue, threading an accumulator argument through the computation, right to left.
</summary>
</member>
<member name="M:FSharpx.DataStructures.PhysicistQueueModule.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,FSharpx.DataStructures.PhysicistQueue{``1})">
<summary>
O(n). Applies a function to each element of the queue, threading an accumulator argument through the computation, left to right.
</summary>
</member>
<member name="M:FSharpx.DataStructures.PhysicistQueueModule.empty``1">
<summary>
O(1). Returns queue of no elements.
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.DataStructures.PhysicistQueueModule">

</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque.tryUpdate``1(System.Int32,``0,FSharpx.DataStructures.RealTimeDeque{``0})">
<summary>
O(n/2), worst case. Returns option deque with element updated by index.
</summary>
</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque.update``1(System.Int32,``0,FSharpx.DataStructures.RealTimeDeque{``0})">
<summary>
O(n/2), worst case. Returns deque with element updated by index.
</summary>
</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque.tryUnsnoc``1(FSharpx.DataStructures.RealTimeDeque{``0})">
<summary>
O(1), worst case. Returns option init and the last element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque.unsnoc``1(FSharpx.DataStructures.RealTimeDeque{``0})">
<summary>
O(1), worst case. Returns init and the last element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque.tryUncons``1(FSharpx.DataStructures.RealTimeDeque{``0})">
<summary>
O(1), worst case. Returns option first element and tail.
</summary>
</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque.uncons``1(FSharpx.DataStructures.RealTimeDeque{``0})">
<summary>
O(1), worst case. Returns the first element and tail.
</summary>
</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque.tryGetTail``1(FSharpx.DataStructures.RealTimeDeque{``0})">
<summary>
O(1), worst case. Returns option deque of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque.tail``1(FSharpx.DataStructures.RealTimeDeque{``0})">
<summary>
O(1), worst case. Returns a new deque of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque.snoc``1(``0,FSharpx.DataStructures.RealTimeDeque{``0})">
<summary>
O(1), worst case. Returns a new deque with the element added to the end.
</summary>
</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque.singletonC``1(System.Int32,``0)">
<summary>
O(1). Returns a deque of one element, c is front-back stream ratio constant, should be at least 2.
</summary>
</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque.singleton``1(``0)">
<summary>
O(1). Returns a deque of one element, front-back stream ratio constant defaulted to 2.
</summary>
</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque.rev``1(FSharpx.DataStructures.RealTimeDeque{``0})">
<summary>
O(1). Returns deque reversed.
</summary>
</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque.tryRemove``1(System.Int32,FSharpx.DataStructures.RealTimeDeque{``0})">
<summary>
O(n/2), worst case. Returns option deque with element removed by index.
</summary>
</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque.remove``1(System.Int32,FSharpx.DataStructures.RealTimeDeque{``0})">
<summary>
O(n/2), worst case. Returns deque with element removed by index.
</summary>
</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque.ofSeqC``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
<summary>
O(n). Returns a deque of the seq, c is front-back stream ratio constant, should be at least 2.
</summary>
</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
O(n). Returns a deque of the seq, front-back stream ratio constant defaulted to 2.
</summary>
</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque.ofCatSeqsC``1(System.Int32,System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
<summary>
O(|ys-xs|). Returns a deque of the two seqs concatenated, c is front-back stream ratio constant, should be at least 2.
</summary>
</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque.ofCatSeqs``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
<summary>
O(|ys-xs|). Returns a deque of the two seqs concatenated, front-back stream ratio constant defaulted to 2.
</summary>
</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque.ofCatListsC``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
O(|ys-xs|). Returns a deque of the two lists concatenated, c is front-back stream ration constant, should be at least 2.
</summary>
</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque.ofCatLists``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
O(|ys-xs|). Returns a deque of the two lists concatenated, front-back stream ratio constant defaulted to 2.
</summary>
</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque.tryLookup``1(System.Int32,FSharpx.DataStructures.RealTimeDeque{``0})">
<summary>
O(n/2), worst case. Returns option element by index.
</summary>
</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque.lookup``1(System.Int32,FSharpx.DataStructures.RealTimeDeque{``0})">
<summary>
O(n/2), worst case. Returns option element by index.
</summary>
</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque.length``1(FSharpx.DataStructures.RealTimeDeque{``0})">
<summary>
O(1). Returns the count of elememts.
</summary>
</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque.tryGetLast``1(FSharpx.DataStructures.RealTimeDeque{``0})">
<summary>
O(1), worst case. Returns option last element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque.last``1(FSharpx.DataStructures.RealTimeDeque{``0})">
<summary>
O(1), worst case. Returns the last element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque.isEmpty``1(FSharpx.DataStructures.RealTimeDeque{``0})">
<summary>
O(1). Returns true if the deque has no elements.
</summary>
</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque.tryGetInit``1(FSharpx.DataStructures.RealTimeDeque{``0})">
<summary>
O(1), worst case. Returns option deque of the elements before the last element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque.init``1(FSharpx.DataStructures.RealTimeDeque{``0})">
<summary>
O(1), worst case. Returns a new deque of the elements before the last element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque.tryGetHead``1(FSharpx.DataStructures.RealTimeDeque{``0})">
<summary>
O(1), worst case. Returns option first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque.head``1(FSharpx.DataStructures.RealTimeDeque{``0})">
<summary>
O(1), worst case. Returns the first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque.empty``1(System.Int32)">
<summary>
O(1). Returns deque of no elements, c is front-back stream ration constant, should be at least 2.
</summary>
</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque.cons``1(``0,FSharpx.DataStructures.RealTimeDeque{``0})">
<summary>
O(1), worst case. Returns a new deque with the element added to the beginning.
</summary>
</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque.appendC``1(System.Int32,FSharpx.DataStructures.RealTimeDeque{``0},FSharpx.DataStructures.RealTimeDeque{``0})">
<summary>
O(|ys-xs|). Returns a deque of the two deques concatenated, c is front-back stream ratio constant, should be at least 2.
</summary>
</member>
<member name="M:FSharpx.DataStructures.RealTimeDeque.append``1(FSharpx.DataStructures.RealTimeDeque{``0},FSharpx.DataStructures.RealTimeDeque{``0})">
<summary>
O(|ys-xs|). Returns a deque of the two deques concatenated, front-back stream ratio constant defaulted to 2.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.DataStructures.RealTimeDeque">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.RealTimeQueue.tryGetTail``1(FSharpx.DataStructures.RealTimeQueue.RealTimeQueue{``0})">
<summary>
O(1), worst case. Returns option queue of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.RealTimeQueue.tail``1(FSharpx.DataStructures.RealTimeQueue.RealTimeQueue{``0})">
<summary>
O(1), worst case. Returns a new queue of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.RealTimeQueue.tryGetHead``1(FSharpx.DataStructures.RealTimeQueue.RealTimeQueue{``0})">
<summary>
O(1), worst case.  Returns option first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.RealTimeQueue.head``1(FSharpx.DataStructures.RealTimeQueue.RealTimeQueue{``0})">
<summary>
O(1), worst case. Returns the first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.RealTimeQueue.snoc``1(``0,FSharpx.DataStructures.RealTimeQueue.RealTimeQueue{``0})">
<summary>
O(1), worst case. Returns a new queue with the element added to the end.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.RealTimeQueue.isEmpty``1(FSharpx.DataStructures.RealTimeQueue.RealTimeQueue{``0})">
<summary>
O(1). Returns true if the queue has no elements
</summary>
</member>
<member name="M:FSharpx.DataStructures.RealTimeQueue.empty``1">
<summary>
O(1). Returns queue of no elements.
</summary>
</member>
<member name="T:FSharpx.DataStructures.RealTimeQueue">

</member>
<member name="">

</member>
<member name="T:FSharpx.DataStructures.RingBuffer">

</member>
<member name="M:FSharpx.DataStructures.RoseTreeModule.mapAccum``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``0,``2}}},``0,FSharpx.DataStructures.RoseTree{``1})">
<summary>
 Behaves like a combination of map and fold; 
 it applies a function to each element of a tree, 
 passing an accumulating parameter, 
 and returning a final value of this accumulator together with the new tree.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.DataStructures.RoseTreeModule">

</member>
<member name="M:FSharpx.DataStructures.SkewBinaryRandomAccessListModule.tryUpdate``1(System.Int32,``0,FSharpx.DataStructures.SkewBinaryRandomAccessList{``0})">
<summary>
O(log n), worst case. Returns option random access list with element updated by index.
</summary>
</member>
<member name="M:FSharpx.DataStructures.SkewBinaryRandomAccessListModule.update``1(System.Int32,``0,FSharpx.DataStructures.SkewBinaryRandomAccessList{``0})">
<summary>
O(log n), worst case. Returns random access list with element updated by index.
</summary>
</member>
<member name="M:FSharpx.DataStructures.SkewBinaryRandomAccessListModule.tryUncons``1(FSharpx.DataStructures.SkewBinaryRandomAccessList{``0})">
<summary>
O(1), worst case. Returns the option first element and tail.
</summary>
</member>
<member name="M:FSharpx.DataStructures.SkewBinaryRandomAccessListModule.uncons``1(FSharpx.DataStructures.SkewBinaryRandomAccessList{``0})">
<summary>
O(1), worst case. Returns the first element and tail.
</summary>
</member>
<member name="M:FSharpx.DataStructures.SkewBinaryRandomAccessListModule.tryGetTail``1(FSharpx.DataStructures.SkewBinaryRandomAccessList{``0})">
<summary>
O(1), worst case. Returns a option random access list of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.SkewBinaryRandomAccessListModule.tail``1(FSharpx.DataStructures.SkewBinaryRandomAccessList{``0})">
<summary>
O(1), worst case. Returns a new random access list of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.SkewBinaryRandomAccessListModule.rev``1(FSharpx.DataStructures.SkewBinaryRandomAccessList{``0})">
<summary>
O(n). Returns random access list reversed.
</summary>
</member>
<member name="M:FSharpx.DataStructures.SkewBinaryRandomAccessListModule.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
O(n) Returns random access list from the sequence.
</summary>
</member>
<member name="M:FSharpx.DataStructures.SkewBinaryRandomAccessListModule.tryLookup``1(System.Int32,FSharpx.DataStructures.SkewBinaryRandomAccessList{``0})">
<summary>
O(log n), worst case. Returns option element by index.
</summary>
</member>
<member name="M:FSharpx.DataStructures.SkewBinaryRandomAccessListModule.lookup``1(System.Int32,FSharpx.DataStructures.SkewBinaryRandomAccessList{``0})">
<summary>
O(log n), worst case. Returns element by index.
</summary>
</member>
<member name="M:FSharpx.DataStructures.SkewBinaryRandomAccessListModule.length``1(FSharpx.DataStructures.SkewBinaryRandomAccessList{``0})">
<summary>
O(log n). Returns the count of elememts.
</summary>
</member>
<member name="M:FSharpx.DataStructures.SkewBinaryRandomAccessListModule.isEmpty``1(FSharpx.DataStructures.SkewBinaryRandomAccessList{``0})">
<summary>
O(1). Returns true if the random access list has no elements.
</summary>
</member>
<member name="M:FSharpx.DataStructures.SkewBinaryRandomAccessListModule.empty``1">
<summary>
returns a empty random access list.
</summary>
</member>
<member name="M:FSharpx.DataStructures.SkewBinaryRandomAccessListModule.tryGetHead``1(FSharpx.DataStructures.SkewBinaryRandomAccessList{``0})">
<summary>
O(1), worst case. Returns option first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.SkewBinaryRandomAccessListModule.head``1(FSharpx.DataStructures.SkewBinaryRandomAccessList{``0})">
<summary>
O(1), worst case. Returns the first element.
</summary>
</member>
<member name="M:FSharpx.DataStructures.SkewBinaryRandomAccessListModule.cons``1(``0,FSharpx.DataStructures.SkewBinaryRandomAccessList{``0})">
<summary>
O(1), worst case. Returns a new random access list with the element added to the beginning.
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.DataStructures.SkewBinaryRandomAccessListModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.Vector.assocN``1(System.Int32,``0,FSharpx.DataStructures.Interfaces.IVector{``0})">
<summary>
 Returns a new vector that contains the given value at the index. Note - index must be &lt;= vector.Count.
</summary>
</member>
<member name="M:FSharpx.DataStructures.Vector.pop``1(FSharpx.DataStructures.Interfaces.IVector{``0})">
<summary>
 Returns a new vector without the last item. If the collection is empty it throws an exception.
</summary>
</member>
<member name="M:FSharpx.DataStructures.Vector.peek``1(FSharpx.DataStructures.Interfaces.IVector{``0})">
<summary>
 Returns the last element in the vector. If the vector is empty it throws an exception.
</summary>
</member>
<member name="M:FSharpx.DataStructures.Vector.conj``1(``0,FSharpx.DataStructures.Interfaces.IVector{``0})">
<summary>
 Returns a new vector with the element &apos;added&apos; at the end.   
</summary>
</member>
<member name="M:FSharpx.DataStructures.Vector.nth``1(System.Int32,FSharpx.DataStructures.Interfaces.IVector{``0})">
<summary>
 Returns the value at the index. If the index is out of bounds it throws an exception.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.Vector.count``1(FSharpx.DataStructures.Interfaces.IVector{``0})">
<summary>
 Returns the number of items in the collection.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.DataStructures.Vector">
<summary>
 vector implementation ported from https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/PersistentVector.java
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Enumerator.scanUntil``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerator{``1})">
<summary>
 Scan progressively folds over the enumerator, returning a new enumerator
 that lazily computes each state until the provided predicate is true.
</summary>
</member>
<member name="M:FSharpx.Enumerator.scanWhile``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerator{``1})">
<summary>
 Scan progressively folds over the enumerator, returning a new enumerator
 that lazily computes each state while the provided predicate is true.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Enumerator.scan``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,System.Collections.Generic.IEnumerator{``1})">
<summary>
 Scan progressively folds over the enumerator, returning a new enumerator
 that lazily computes each state.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Enumerator">

</member>
<member name="M:FSharpx.IO.combinePaths(System.String,System.String)">
<summary>
 Combines two path strings
</summary>
</member>
<member name="P:FSharpx.IO.directorySeparator">
<summary>
 The directory separator string. On most systems / or \
</summary>
</member>
<member name="M:FSharpx.IO.appendFileNamesIfNotNull(System.Collections.Generic.IEnumerable{System.String},System.Text.StringBuilder)">
<summary>
 Appends all notnull fileNames
</summary>
</member>
<member name="M:FSharpx.IO.appendStringIfValueIsNotNullOrEmpty(System.String)">
<summary>
 Appends a text if the value is not null or empty
</summary>
</member>
<member name="M:FSharpx.IO.appendStringIfValueIsNotNull``1(``0)">
<summary>
 Appends a text if the value is not null
</summary>
</member>
<member name="M:FSharpx.IO.appendIfNotNull``1(``0,System.String)">
<summary>
 Appends a text if the value is not null
</summary>
</member>
<member name="M:FSharpx.IO.appendIfFalse(System.Boolean)">
<summary>
 Appends a text if the predicate is false
</summary>
</member>
<member name="M:FSharpx.IO.appendIfTrue(System.Boolean,System.String,System.Text.StringBuilder)">
<summary>
 Appends a text if the predicate is true
</summary>
</member>
<member name="M:FSharpx.IO.append(System.String,System.Text.StringBuilder)">
<summary>
 Appends a text
</summary>
</member>
<member name="M:FSharpx.IO.convertTextToWindowsLineBreaks(System.String)">
<summary>
 Converts the given text from linux or mac linebreaks to windows line breaks
</summary>
</member>
<member name="M:FSharpx.IO.replaceFile(System.String,System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Replaces the file with the given string
</summary>
</member>
<member name="M:FSharpx.IO.writeStringToFile(System.Boolean,System.String,System.String)">
<summary>
 Writes a single string to a file
</summary>
</member>
<member name="M:FSharpx.IO.writeToFile(System.Boolean,System.String,System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Writes a file line by line
</summary>
</member>
<member name="M:FSharpx.IO.readFile(System.String)">
<summary>
 Reads a file line by line
</summary>
</member>
<member name="M:FSharpx.IO.readFileAsString(System.String)">
<summary>
 Reads a file as one text
</summary>
</member>
<member name="M:FSharpx.IO.allFilesExist(System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Checks if all given files exists
</summary>
</member>
<member name="M:FSharpx.IO.checkFileExists(System.String)">
<summary>
 Checks if the file exists on disk.
</summary>
</member>
<member name="P:FSharpx.IO.currentDirectory">
<summary>
 Gets the current directory
</summary>
</member>
<member name="M:FSharpx.IO.filesInDir(System.IO.DirectoryInfo)">
<summary>
 Gets all files in the directory
</summary>
</member>
<member name="M:FSharpx.IO.subDirectories(System.IO.DirectoryInfo)">
<summary>
 Gets all subdirectories
</summary>
</member>
<member name="M:FSharpx.IO.getFullName(System.String)">
<summary>
 Converts a file to it&apos;s full file system name
</summary>
</member>
<member name="M:FSharpx.IO.fileSystemInfo(System.String)">
<summary>
 Creates a FileInfo or a DirectoryInfo for the given path
</summary>
</member>
<member name="M:FSharpx.IO.fileInfo(System.String)">
<summary>
 Creates a FileInfo for the given path
</summary>
</member>
<member name="M:FSharpx.IO.directoryInfo(System.String)">
<summary>
 Creates a DirectoryInfo for the given path
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.IO">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.IterateeModule.op_LessEqualsLess``4(Microsoft.FSharp.Core.FSharpFunc{``0,FSharpx.Iteratee{``1,``2}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.IterateeModule.op_GreaterEqualsGreater``4(Microsoft.FSharp.Core.FSharpFunc{``0,FSharpx.Iteratee{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``2,FSharpx.Iteratee{``1,``3}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.IterateeModule.op_GreaterGreaterDot``3(FSharpx.Iteratee{``0,``1},FSharpx.Iteratee{``0,``2})">
<summary>
 Sequentially compose two iteratee actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.IterateeModule.op_LessMultiply``3(FSharpx.Iteratee{``0,``1},FSharpx.Iteratee{``0,``2})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.IterateeModule.op_MultiplyGreater``3(FSharpx.Iteratee{``0,``1},FSharpx.Iteratee{``0,``2})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.IterateeModule.ap``3(FSharpx.Iteratee{``0,``1},FSharpx.Iteratee{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.IterateeModule.op_LessMultiplyGreater``3(FSharpx.Iteratee{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},FSharpx.Iteratee{``0,``1})">
<summary>
 Sequential application
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.IterateeModule.BinaryModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.IterateeModule.ListModule">

</member>
<member name="T:FSharpx.IterateeModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.JSON.parse(System.Collections.Generic.IEnumerable{System.Char})">
<summary>
 Parses a JSON source text and returns an JSON AST
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.JSON.DocumentExtensions">

</member>
<member name="T:FSharpx.JSON">

</member>
<member name="">

</member>
<member name="T:FSharpx.LazyModule">

</member>
<member name="">

</member>
<member name="M:FSharpx.LensModule.listToArray``2(FSharpx.Lens{``0,Microsoft.FSharp.Collections.FSharpList{``1}})">
<summary>
 Converts a lens that views a list into a lens that views an array
</summary>
</member>
<member name="M:FSharpx.LensModule.xmap``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,``0},FSharpx.Lens{``2,``0})">
<summary>
 Applies an isomorphism to the value viewed through a lens
</summary>
</member>
<member name="M:FSharpx.LensModule.seqMap``2(FSharpx.Lens{``0,``1})">
<summary>
 Creates a lens that maps the given lens in a sequence
</summary>
</member>
<member name="M:FSharpx.LensModule.arrayMap``2(FSharpx.Lens{``0,``1})">
<summary>
 Creates a lens that maps the given lens in an array
</summary>
</member>
<member name="M:FSharpx.LensModule.listMap``2(FSharpx.Lens{``0,``1})">
<summary>
 Creates a lens that maps the given lens in a list
</summary>
</member>
<member name="M:FSharpx.LensModule.forList``1(System.Int32)">
<summary>
 Lens for a particular position in a list
</summary>
</member>
<member name="M:FSharpx.LensModule.forArray``1(System.Int32)">
<summary>
 Lens for a particular position in an array
</summary>
</member>
<member name="M:FSharpx.LensModule.forMap``2(``0)">
<summary>
 Lens for a particular key in a map
</summary>
</member>
<member name="M:FSharpx.LensModule.forSet``1(``0)">
<summary>
 Lens for a particular value in a set
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.LensModule.id``1">
<summary>
 Identity lens
</summary>
</member>
<member name="M:FSharpx.LensModule.snd``2">
<summary>
 Gets/sets the snd element in a pair
</summary>
</member>
<member name="M:FSharpx.LensModule.fst``2">
<summary>
 Gets/sets the fst element in a pair
</summary>
</member>
<member name="M:FSharpx.LensModule.modifyAndGetState``2(FSharpx.Lens{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,``1})">
<summary>
 Modifies the state in a state monad and returns the modified value.
</summary>
</member>
<member name="M:FSharpx.LensModule.getAndModifyState``2(FSharpx.Lens{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,``1})">
<summary>
 Modifies the state in a state monad and returns the original value.
</summary>
</member>
<member name="M:FSharpx.LensModule.updateState``2(FSharpx.Lens{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,``1},``0)">
<summary>
 Update through a lens within a state monad
</summary>
</member>
<member name="M:FSharpx.LensModule.setState``2(FSharpx.Lens{``0,``1},``1,``0)">
<summary>
 Applies a lens in the &apos;set&apos; direction within a state monad
</summary>
</member>
<member name="M:FSharpx.LensModule.getState``2(FSharpx.Lens{``0,``1},``0)">
<summary>
 Applies a lens in the &apos;get&apos; direction within a state monad      
</summary>
</member>
<member name="M:FSharpx.LensModule.cond``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},FSharpx.Lens{``0,``1},FSharpx.Lens{``0,``1})">
 <summary>
 <paramref name="pred"/> is applied to source. 
 If true, <paramref name="lensTrue"/> is selected.
 If false, <paramref name="lensFalse"/> is selected.
 </summary>
</member>
<member name="M:FSharpx.LensModule.pair``4(FSharpx.Lens{``0,``1},FSharpx.Lens{``2,``3})">
<summary>
 Pair two lenses
</summary>
</member>
<member name="M:FSharpx.LensModule.choice``3(FSharpx.Lens{``0,``1},FSharpx.Lens{``2,``1})">
<summary>
 Composes two lenses through a sum in the source
</summary>
</member>
<member name="M:FSharpx.LensModule.compose``3(FSharpx.Lens{``0,``1},FSharpx.Lens{``2,``0})">
<summary>
 Sequentially composes two lenses
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.LensModule.StateOperators">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.LensModule.Operators">

</member>
<member name="T:FSharpx.LensModule">

</member>
<member name="M:FSharpx.Linq.QuotationEvaluator.ToLinqExpression(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Convert the quotation expression to LINQ expression trees

 This operation will only succeed for a subset of quotation expressions.

 Exceptions: InvalidArgumentException will be raised if the input expression is
 not in the subset that can be converted to a LINQ expression tree
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Linq.QuotationEvaluator.EvaluateUntyped(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Compile the quotation expression by first converting to LINQ expression trees

 Exceptions: InvalidArgumentException will be raised if the input expression is
 not in the subset that can be converted to a LINQ expression tree
</summary>
</member>
<member name="M:FSharpx.Linq.QuotationEvaluator.Evaluate``1(Microsoft.FSharp.Quotations.FSharpExpr{``0})">
<summary>
 Evaluate the quotation expression by first converting to LINQ expression trees

 Exceptions: InvalidArgumentException will be raised if the input expression is
 not in the subset that can be converted to a LINQ expression tree
</summary>
</member>
<member name="M:FSharpx.Linq.QuotationEvaluator.CompileUntyped(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Compile the quotation expression by first converting to LINQ expression trees

 Exceptions: InvalidArgumentException will be raised if the input expression is
 not in the subset that can be converted to a LINQ expression tree
</summary>
</member>
<member name="M:FSharpx.Linq.QuotationEvaluator.Compile``1(Microsoft.FSharp.Quotations.FSharpExpr{``0})">
<summary>
 Compile the quotation expression by first converting to LINQ expression trees

 Exceptions: InvalidArgumentException will be raised if the input expression is
 not in the subset that can be converted to a LINQ expression tree
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Linq.QuotationHelpers.toLinqExpression``2(Microsoft.FSharp.Quotations.FSharpExpr{Microsoft.FSharp.Core.FSharpFunc{``0,``1}})">
<summary>
 Converts a Lambda quotation into a Linq Lamba Expression with 1 parameter
</summary>
</member>
<member name="T:FSharpx.Linq.QuotationHelpers">

</member>
<member name="M:FSharpx.Linq.QuotationEvaluation.LinqExpressionHelper``1(``0)">
<summary>
 This function should not be called directly. 
</summary>
</member>
<member name="M:FSharpx.Linq.QuotationEvaluation.Expr`1.Eval``1(Microsoft.FSharp.Quotations.FSharpExpr{``0})">
<summary>
 Evaluate the quotation expression by first converting to LINQ expression trees

 Exceptions: InvalidArgumentException will be raised if the input expression is
 not in the subset that can be converted to a LINQ expression tree
</summary>
</member>
<member name="M:FSharpx.Linq.QuotationEvaluation.Expr`1.Compile``1(Microsoft.FSharp.Quotations.FSharpExpr{``0})">
<summary>
 Compile the quotation expression by first converting to LINQ expression trees

 Exceptions: InvalidArgumentException will be raised if the input expression is
 not in the subset that can be converted to a LINQ expression tree
</summary>
</member>
<member name="M:FSharpx.Linq.QuotationEvaluation.Expr.EvalUntyped(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Compile the quotation expression by first converting to LINQ expression trees

 Exceptions: InvalidArgumentException will be raised if the input expression is
 not in the subset that can be converted to a LINQ expression tree
</summary>
</member>
<member name="M:FSharpx.Linq.QuotationEvaluation.Expr.CompileUntyped(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Compile the quotation expression by first converting to LINQ expression trees

 Exceptions: InvalidArgumentException will be raised if the input expression is
 not in the subset that can be converted to a LINQ expression tree
</summary>
</member>
<member name="M:FSharpx.Linq.QuotationEvaluation.Expr.ToLinqExpression(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Convert the quotation expression to LINQ expression trees

 This operation will only succeed for a subset of quotation expressions.

 Exceptions: InvalidArgumentException will be raised if the input expression is
 not in the subset that can be converted to a LINQ expression tree
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Linq.QuotationEvaluation.HelperTypes">
<summary>
 A set of types used for implementing quotation conversions.
 These are public only because targets of Linq Lambda expressions require them to be so
</summary>
</member>
<member name="T:FSharpx.Linq.QuotationEvaluation">
<summary>
 This module provides Compile and Eval extension members
 for F# quotation values, implemented by translating to LINQ
 expression trees and using the LINQ dynamic compiler.
</summary>
</member>
<member name="M:FSharpx.Linq.ExtraHashCompare.GenericNotEqualIntrinsic``1(``0,``0)">
<summary>
 An intrinsic for compiling &lt;c&gt;&amp;lt;@ x &lt;&gt; y @&amp;gt;&lt;/c&gt; to expression trees
</summary>
</member>
<member name="T:FSharpx.Linq.ExtraHashCompare">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharpx.Monoid.productInt">
<summary>
 Monoid (int,1,*)
</summary>
</member>
<member name="P:FSharpx.Monoid.sumInt">
<summary>
 Monoid (int,0,+)
</summary>
</member>
<member name="M:FSharpx.Monoid.product``1">
<summary>
 Monoid (a,1,*)
</summary>
</member>
<member name="M:FSharpx.Monoid.sum``1">
<summary>
 Monoid (a,0,+)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Monoid.dual``1(FSharpx.Monoid{``0})">
<summary>
 The dual of a monoid, obtained by swapping the arguments of &apos;Combine&apos;.
</summary>
</member>
<member name="T:FSharpx.Monoid">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Nullable.lift2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Nullable{``0},System.Nullable{``1})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Nullable.toList``1(System.Nullable{``0})">
<summary>
 Convert the nullable to a list of length 0 or 1.
</summary>
</member>
<member name="M:FSharpx.Nullable.toArray``1(System.Nullable{``0})">
<summary>
 Convert the nullable to an array of length 0 or 1.
</summary>
</member>
<member name="M:FSharpx.Nullable.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Nullable{``0})">
<summary>
 Transforms a Nullable value by using a specified mapping function.
</summary>
</member>
<member name="M:FSharpx.Nullable.iter``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},System.Nullable{``0})">
<summary>
 Executes a function for a nullable value.
</summary>
</member>
<member name="M:FSharpx.Nullable.forall``1(Microsoft.FSharp.Core.FSharpFunc{System.Nullable{``0},System.Boolean},System.Nullable{``0})">
<summary>
 Evaluates the equivalent of List.forall for a nullable.
</summary>
</member>
<member name="M:FSharpx.Nullable.exists``1(Microsoft.FSharp.Core.FSharpFunc{System.Nullable{``0},System.Boolean},System.Nullable{``0})">
<summary>
 Evaluates the equivalent of List.exists for a nullable.
</summary>
</member>
<member name="M:FSharpx.Nullable.foldBack``2(Microsoft.FSharp.Core.FSharpFunc{System.Nullable{``0},Microsoft.FSharp.Core.FSharpFunc{``1,``1}},System.Nullable{``0},``1)">
<summary>
 Performs the equivalent of the List.foldBack operation on a nullable.
</summary>
</member>
<member name="M:FSharpx.Nullable.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,System.Nullable{``1})">
<summary>
 Evaluates the equivalent of List.fold for a nullable.
</summary>
</member>
<member name="M:FSharpx.Nullable.count``1(System.Nullable{``0})">
<summary>
 Returns 1 if Nullable has value, otherwise 0
</summary>
</member>
<member name="M:FSharpx.Nullable.isNull``1(System.Nullable{``0})">
<summary>
 True if Nullable does not have value
</summary>
</member>
<member name="M:FSharpx.Nullable.hasValue``1(System.Nullable{``0})">
<summary>
 True if Nullable has value
</summary>
</member>
<member name="M:FSharpx.Nullable.bind``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Nullable{``1}},System.Nullable{``0})">
<summary>
 Monadic bind
</summary>
</member>
<member name="M:FSharpx.Nullable.toOption``1">
<summary>
 Converts nullable to option
</summary>
</member>
<member name="M:FSharpx.Nullable.ofOption``1">
<summary>
 Converts option to nullable
</summary>
</member>
<member name="M:FSharpx.Nullable.get``1(System.Nullable{``0})">
<summary>
 Gets the value associated with the Nullable.
 If no value, throws.
</summary>
</member>
<member name="M:FSharpx.Nullable.getOrElse``1(System.Nullable{``0},System.Lazy{``0})">
<summary>
 Gets the value associated with the nullable or the supplied default value.
</summary>
</member>
<member name="M:FSharpx.Nullable.getOrDefault``1(System.Nullable{``0},``0)">
<summary>
 Gets the value associated with the nullable or the supplied default value.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Nullable">

</member>
<member name="M:FSharpx.Operators.applyM``7(``0,``5,``1,``6)">
<summary>
 Sequential application
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Operators.returnM``3(``0,``1)">
<summary>
 Inject a value into the monadic type
</summary>
</member>
<member name="T:FSharpx.Operators">
<summary>
 Generic monadic operators    
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Option.MaybeBuilder">
<summary>
 The maybe monad.
 This monad is my own and uses an &apos;T option. Others generally make their own Maybe&lt;&apos;T&gt; type from Option&lt;&apos;T&gt;.
 The builder approach is from Matthew Podwysocki&apos;s excellent Creating Extended Builders series http://codebetter.com/blogs/matthew.podwysocki/archive/2010/01/18/much-ado-about-monads-creating-extended-builders.aspx.
</summary>
</member>
<member name="M:FSharpx.Option.concat``1(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
 Concatenates an option of option.
</summary>
</member>
<member name="M:FSharpx.Option.fromTryPattern``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{System.Boolean,``1}},``0)">
<summary>
 transforms a function in the Try...(input, out output) style
 into a function of type: input -&gt; output Option
 Example: fromTryPattern(System.Double.TryParse)
 See Examples.Option
</summary>
</member>
<member name="M:FSharpx.Option.option``2(``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0},Microsoft.FSharp.Core.FSharpOption{``1})">
<summary>
 Haskell-style maybe operator
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Option.Cast``1(System.Object)">
<summary>
 Attempts to cast an object. Returns None if unsuccessful.
</summary>
</member>
<member name="M:FSharpx.Option.filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Applies a predicate to the option. If the predicate returns true, returns Some x, otherwise None.
</summary>
</member>
<member name="M:FSharpx.Option.orElse``1(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Gets the option if Some x, otherwise the supplied default value.
</summary>
</member>
<member name="M:FSharpx.Option.getOrDefault``1(Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Gets the value associated with the option or the default value for the type.
</summary>
</member>
<member name="M:FSharpx.Option.getOrElseF``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Gets the value associated with the option or the supplied default value from a function.
</summary>
</member>
<member name="M:FSharpx.Option.getOrElseLazy``1(System.Lazy{``0},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Gets the value associated with the option or the supplied default value.
</summary>
</member>
<member name="M:FSharpx.Option.getOrElse``1(``0,Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Gets the value associated with the option or the supplied default value.
</summary>
</member>
<member name="M:FSharpx.Option.ofChoice``2(Microsoft.FSharp.Core.FSharpChoice{``0,``1})">
<summary>
 Maps Choice 1Of2 to Some value, otherwise None.
</summary>
</member>
<member name="M:FSharpx.Option.ofBoolAndValue``1(System.Boolean,``0)">
<summary>
 If true,value then returns Some value. Otherwise returns None.
 Useful to process TryXX style functions.
</summary>
</member>
<member name="M:FSharpx.Option.tryParseWith``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{System.Boolean,``1}})">
<summary>
 Converts a function returning bool,value to a function returning value option.
 Useful to process TryXX style functions.
</summary>
</member>
<member name="M:FSharpx.Option.ofBool(System.Boolean)">
<summary>
 True -&gt; Some(), False -&gt; None
</summary>
</member>
<member name="M:FSharpx.Option.toNullable``1(Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Maps an Option to Nullable
</summary>
</member>
<member name="M:FSharpx.Option.ofNullable``1(System.Nullable{``0})">
<summary>
 Maps a Nullable to Option
</summary>
</member>
<member name="M:FSharpx.Option.op_LessEqualsLess``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Option.op_GreaterEqualsGreater``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``2}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Option.op_GreaterGreaterDot``2(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1})">
<summary>
 Sequentially compose two maybe actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.Option.op_LessMultiply``2(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Option.op_MultiplyGreater``2(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Option.lift2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Option.op_LessBangGreater``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Infix map
</summary>
</member>
<member name="M:FSharpx.Option.ap``2(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{``0,``1}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Option.op_LessMultiplyGreater``2(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{``0,``1}},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Option.op_EqualsLessLess``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Flipped &gt;&gt;=
</summary>
</member>
<member name="M:FSharpx.Option.op_GreaterGreaterEquals``2(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}})">
<summary>
 Sequentially compose two actions, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:FSharpx.Option.returnM``1(``0)">
<summary>
 Inject a value into the option type
</summary>
</member>
<member name="M:FSharpx.Option.monoid``1(FSharpx.ISemigroup{``0})">
<summary>
 Option wrapper monoid
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.Option">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Pluralizer">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Prelude.tuple6``6(``0,``1,``2,``3,``4,``5)">
<summary>
 Creates a 6-tuple
</summary>
</member>
<member name="M:FSharpx.Prelude.tuple5``5(``0,``1,``2,``3,``4)">
<summary>
 Creates a 5-tuple
</summary>
</member>
<member name="M:FSharpx.Prelude.tuple4``4(``0,``1,``2,``3)">
<summary>
 Creates a 4-tuple
</summary>
</member>
<member name="M:FSharpx.Prelude.tuple3``3(``0,``1,``2)">
<summary>
 Creates a 3-tuple
</summary>
</member>
<member name="M:FSharpx.Prelude.tuple2``2(``0,``1)">
<summary>
 Creates a pair
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Prelude">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Reader.ReaderBuilder">
<summary>
 The reader monad.
 This monad comes from Matthew Podwysocki&apos;s http://codebetter.com/blogs/matthew.podwysocki/archive/2010/01/07/much-ado-about-monads-reader-edition.aspx.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Reader.op_LessEqualsLess``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Reader.op_GreaterEqualsGreater``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``1,``3}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Reader.op_GreaterGreaterDot``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2})">
<summary>
 Sequentially compose two reader actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.Reader.op_LessMultiply``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Reader.op_MultiplyGreater``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Reader.lift2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``3,``0},Microsoft.FSharp.Core.FSharpFunc{``3,``1})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Reader.op_LessBangGreater``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``0})">
<summary>
 Infix map
</summary>
</member>
<member name="M:FSharpx.Reader.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``0})">
<summary>
 Transforms a Reader value by using a specified mapping function.
</summary>
</member>
<member name="M:FSharpx.Reader.ap``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Reader.op_LessMultiplyGreater``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Reader.op_EqualsLessLess``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``1,``0})">
<summary>
 Flipped &gt;&gt;=
</summary>
</member>
<member name="M:FSharpx.Reader.op_GreaterGreaterEquals``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``2}})">
<summary>
 Sequentially compose two actions, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:FSharpx.Reader.returnM``2(``0)">
<summary>
 Inject a value into the Reader type
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Reader">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.ReflectImpl">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.RegexModule.tryMatchWithOptions(System.Text.RegularExpressions.RegexOptions,System.String,System.String)">
<summary>
flags:RegexOptions -&gt; pattern:string -&gt; input:string -&gt; Regex.ActiveMatch option
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.RegexModule.Interpreted">

</member>
<member name="">

</member>
<member name="T:FSharpx.RegexModule.Compiled">

</member>
<member name="T:FSharpx.RegexModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Semigroup">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.State.StateBuilder">
<summary>
 The state monad.
 The algorithm is adjusted from my original work off of Brian Beckman&apos;s http://channel9.msdn.com/shows/Going+Deep/Brian-Beckman-The-Zen-of-Expressing-State-The-State-Monad/.
 The approach was adjusted from Matthew Podwysocki&apos;s http://codebetter.com/blogs/matthew.podwysocki/archive/2009/12/30/much-ado-about-monads-state-edition.aspx and mirrors his final result.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.State.op_LessEqualsLess``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``1,``2}}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.State.op_GreaterEqualsGreater``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``1,``2}}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``3,``2}}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.State.op_GreaterGreaterDot``3(Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``0,``1}},Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``2,``1}})">
<summary>
 Sequentially compose two state actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.State.op_LessMultiply``3(Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``0,``1}},Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``2,``1}})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.State.op_MultiplyGreater``3(Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``0,``1}},Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``2,``1}})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.State.lift2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``3,System.Tuple{``0,``3}},Microsoft.FSharp.Core.FSharpFunc{``3,System.Tuple{``1,``3}})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.State.op_LessBangGreater``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``0,``2}})">
<summary>
 Infix map
</summary>
</member>
<member name="M:FSharpx.State.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``0,``2}})">
<summary>
 Transforms a State value by using a specified mapping function.
</summary>
</member>
<member name="M:FSharpx.State.ap``3(Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``0,``1}},Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{Microsoft.FSharp.Core.FSharpFunc{``0,``2},``1}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.State.op_LessMultiplyGreater``3(Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2}},Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``0,``2}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.State.op_EqualsLessLess``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``1,``2}}},Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``0,``2}})">
<summary>
 Flipped &gt;&gt;=
</summary>
</member>
<member name="M:FSharpx.State.op_GreaterGreaterEquals``3(Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``0,``1}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``2,``1}}})">
<summary>
 Sequentially compose two actions, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:FSharpx.State.returnM``2(``0)">
<summary>
 Inject a value into the State type
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.State">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.StateMachine">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Stm.ListQueue">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Stm.ArrayQueue">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Stm.Core.TLog">
<summary>
 A transactional memory log
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Stm.Core.TVar`1">
<summary>
 A transactional variable 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Stm.Core.TVar">
<summary>
 A base type for transactional variables
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Stm.Core">

</member>
<member name="T:FSharpx.Stm">
 <summary>The Software Transactional Memory monad.</summary>
 <see href="http://cs.hubfs.net/blogs/hell_is_other_languages/archive/2008/01/16/4565.aspx" />
</member>
<member name="M:FSharpx.Strings.inferType(System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Checks whether all values of the sequence can be inferred to a special type
</summary>
</member>
<member name="M:FSharpx.Strings.isFloat(System.String)">
<summary>
 Checks whether the string is a float
</summary>
</member>
<member name="M:FSharpx.Strings.isInt64(System.String)">
<summary>
 Checks whether the string is an int64
</summary>
</member>
<member name="M:FSharpx.Strings.isInt(System.String)">
<summary>
 Checks whether the string is an int32
</summary>
</member>
<member name="M:FSharpx.Strings.isBool(System.String)">
<summary>
 Checks whether the string is a boolean value
</summary>
</member>
<member name="M:FSharpx.Strings.niceName(System.String)">
<summary>
 Turns a string into a nice PascalCase identifier
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Strings.singularize(System.String)">
<summary>
 Returns the singularized version of a noun
</summary>
</member>
<member name="M:FSharpx.Strings.pluralize(System.String)">
<summary>
 Returns the pluralized version of a noun
</summary>
</member>
<member name="M:FSharpx.Strings.isNullOrEmpty(System.String)">
<summary>
 Returns if the string is null or empty
</summary>
</member>
<member name="M:FSharpx.Strings.separatedBy(System.String,System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Converts a sequence of strings to a single string separated with the delimiters
</summary>
</member>
<member name="M:FSharpx.Strings.split(System.Char,System.String)">
<summary>
 Splits the given string at the given delimiter
</summary>
</member>
<member name="M:FSharpx.Strings.contains(System.String,System.String)">
<summary>
 Returns a value indicating whether the specified substring occurs within this string
</summary>
</member>
<member name="M:FSharpx.Strings.replace(System.String,System.String,System.String)">
<summary>
 Replaces the given &quot;replacement&quot; for every occurence of the pattern in the given text 
</summary>
</member>
<member name="M:FSharpx.Strings.startsWith(System.String,System.String)">
<summary>
 Checks whether the given text starts with the given prefix
</summary>
</member>
<member name="T:FSharpx.Strings">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Task.Result`1.Successful">
<summary>
 Task completed successfully
</summary>
</member>
<member name="T:FSharpx.Task.Result`1.Error">
<summary>
 Unhandled exception in task
</summary>
</member>
<member name="T:FSharpx.Task.Result`1.Canceled">
<summary>
 Task was canceled
</summary>
</member>
<member name="T:FSharpx.Task.Result`1">
<summary>
 Task result
</summary>
</member>
<member name="M:FSharpx.Task.op_LessMultiply``2(System.Threading.Tasks.Task{``0},System.Threading.Tasks.Task{``1})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Task.op_MultiplyGreater``2(System.Threading.Tasks.Task{``0},System.Threading.Tasks.Task{``1})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Task.op_LessBangGreater``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Threading.Tasks.Task{``0})">
<summary>
 Infix map
</summary>
</member>
<member name="M:FSharpx.Task.op_LessMultiplyGreater``2(System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpFunc{``0,``1}},System.Threading.Tasks.Task{``0})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Task.ap``2(System.Threading.Tasks.Task{``0},System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpFunc{``0,``1}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Task.lift2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Threading.Tasks.Task{``0},System.Threading.Tasks.Task{``1})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Task.op_LessEqualsLess``4(Microsoft.FSharp.Core.FSharpFunc{``0,System.Threading.Tasks.Task{``1}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Task.op_GreaterEqualsGreater``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,System.Threading.Tasks.Task{``3}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Task.op_GreaterGreaterDot``2(System.Threading.Tasks.Task{``0},System.Threading.Tasks.Task{``1})">
<summary>
 Sequentially compose two either actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.Task.op_EqualsLessLess``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Threading.Tasks.Task{``1}},System.Threading.Tasks.Task{``0})">
<summary>
 Flipped &gt;&gt;=
</summary>
</member>
<member name="M:FSharpx.Task.op_GreaterGreaterEquals``2(System.Threading.Tasks.Task{``0},Microsoft.FSharp.Core.FSharpFunc{``0,System.Threading.Tasks.Task{``1}})">
<summary>
 Sequentially compose two actions, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Task.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Threading.Tasks.Task{``0})">
<summary>
 Transforms a Task&apos;s first value by using a specified mapping function.
</summary>
</member>
<member name="M:FSharpx.Task.mapWithOptions``2(System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler,Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Threading.Tasks.Task{``0})">
<summary>
 Transforms a Task&apos;s first value by using a specified mapping function.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Task">

</member>
<member name="M:FSharpx.TimeMeasurement.compareTwoRuntimes``2(System.Int32,System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``1})">
<summary>
 Stops the average runtime for the given functions
 Afterwards it reports it with the given descriptions
</summary>
</member>
<member name="M:FSharpx.TimeMeasurement.stopAndReportAvarageTime``1(System.Int32,System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Stops the average runtime for a given function and applies it the given count
 Afterwards it reports it with the given description
</summary>
</member>
<member name="M:FSharpx.TimeMeasurement.stopAverageTime``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Stops the average runtime for a given function and applies it the given count
</summary>
</member>
<member name="M:FSharpx.TimeMeasurement.stopTime``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Stops the runtime for a given function
</summary>
</member>
<member name="T:FSharpx.TimeMeasurement">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Undo">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Validation.CustomValidation`1.lift2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpChoice{``0,`0},Microsoft.FSharp.Core.FSharpChoice{``1,`0})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Validation.CustomValidation`1.apr``2(Microsoft.FSharp.Core.FSharpChoice{``0,`0},Microsoft.FSharp.Core.FSharpChoice{``1,`0})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Validation.CustomValidation`1.apl``2(Microsoft.FSharp.Core.FSharpChoice{``0,`0},Microsoft.FSharp.Core.FSharpChoice{``1,`0})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Validation.CustomValidation`1.ap``2(Microsoft.FSharp.Core.FSharpChoice{``0,`0})">
<summary>
 Sequential application
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Validation.op_LessMultiply``3(Microsoft.FSharp.Core.FSharpChoice{``0,FSharpx.Collections.NonEmptyList{``1}},Microsoft.FSharp.Core.FSharpChoice{``2,FSharpx.Collections.NonEmptyList{``1}})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Validation.op_MultiplyGreater``3(Microsoft.FSharp.Core.FSharpChoice{``0,FSharpx.Collections.NonEmptyList{``1}},Microsoft.FSharp.Core.FSharpChoice{``2,FSharpx.Collections.NonEmptyList{``1}})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Validation.lift2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpChoice{``0,FSharpx.Collections.NonEmptyList{``3}},Microsoft.FSharp.Core.FSharpChoice{``1,FSharpx.Collections.NonEmptyList{``3}})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Validation.op_LessMultiplyGreater``3(Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharpx.Collections.NonEmptyList{``2}},Microsoft.FSharp.Core.FSharpChoice{``0,FSharpx.Collections.NonEmptyList{``2}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Validation.ap``3(Microsoft.FSharp.Core.FSharpChoice{``0,FSharpx.Collections.NonEmptyList{``1}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Validation.apm``3(FSharpx.ISemigroup{``0})">
<summary>
 Sequential application, parameterized by semigroup
</summary>
</member>
<member name="M:FSharpx.Validation.apa``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},Microsoft.FSharp.Core.FSharpChoice{``1,``0},Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Core.FSharpFunc{``1,``2},``0})">
<summary>
 Sequential application, parameterized by append
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.Validation">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Writer.WriterBuilder`1">
<summary>
 The writer monad.
 This monad comes from Matthew Podwysocki&apos;s http://codebetter.com/blogs/matthew.podwysocki/archive/2010/02/01/a-kick-in-the-monads-writer-edition.aspx.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Writer.op_LessEqualsLess``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Writer.op_GreaterEqualsGreater``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``2,Microsoft.FSharp.Collections.FSharpList{System.String}}}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Writer.op_GreaterGreaterDot``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Sequentially compose two state actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.Writer.op_LessMultiply``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Writer.op_MultiplyGreater``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Writer.lift2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Writer.op_LessBangGreater``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Infix map
</summary>
</member>
<member name="M:FSharpx.Writer.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Transforms a Writer value by using a specified mapping function.
</summary>
</member>
<member name="M:FSharpx.Writer.ap``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Writer.op_LessMultiplyGreater``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{System.String}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Writer.op_EqualsLessLess``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Flipped &gt;&gt;=
</summary>
</member>
<member name="M:FSharpx.Writer.op_GreaterGreaterEquals``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}}})">
<summary>
 Sequentially compose two actions, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Writer.returnM``2(FSharpx.Monoid{``0},``1,Microsoft.FSharp.Core.Unit)">
<summary>
 Inject a value into the Writer type
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.Writer">

</member>
<member name="M:FSharpx.ZipList.op_LessMultiply``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.ZipList.op_MultiplyGreater``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.ZipList.lift2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.ZipList.ap``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpFunc{``0,``1}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.ZipList.op_LessMultiplyGreater``2(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpFunc{``0,``1}},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Sequential application
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.ZipList">

</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.unzip``2(System.Collections.Generic.List{System.Tuple{``0,``1}})">
<summary>
 Split an array of pairs into two arrays
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.zip``2(System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Combine the two arrays into an array of pairs. The two arrays must have equal lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is
 raised..
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.tryFindIndexi``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},System.Collections.Generic.List{``0})">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.tryFindIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.singleton``1(``0)">
<summary>
 Return an array containing the given element
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.scanBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},System.Collections.Generic.List{``0},``1)">
<summary>
 Like &lt;c&gt;foldBack&lt;/c&gt;, but return both the intermediary and final results
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.scan``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,System.Collections.Generic.List{``1})">
<summary>
 Like &lt;c&gt;fold&lt;/c&gt;, but return the intermediary and final results
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.mapi2``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to the corresponding elements of the two collections pairwise.  The two input
 arrays must have the same lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is
 raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.iteri2``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Apply the given function to pair of elements drawn from matching indices in two arrays,
 also passing the index of the elements. The two arrays must have the same lengths, 
 otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.isEmpty``1(System.Collections.Generic.List{``0})">
<summary>
 Return true if the given array is empty, otherwise false
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.forall2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Test elements of the two arrays pairwise to see if all pairs of elements satisfy the given predicate.
 Raise ArgumentException if the arrays have different lengths.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.foldBack2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``2}}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1},``2)">
<summary>
 Apply a function to pairs of elements drawn from the two collections, right-to-left, 
 threading an accumulator argument through the computation.  The two input
 arrays must have the same lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is
 raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.fold2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``0}}},``0,System.Collections.Generic.List{``1},System.Collections.Generic.List{``2})">
<summary>
 Apply a function to pairs of elements drawn from the two collections, 
 left-to-right, threading an accumulator argument
 through the computation.  The two input
 arrays must have the same lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is
 raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.reduceBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Collections.Generic.List{``0})">
<summary>
 Apply a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; then 
 computes &lt;c&gt;f i0 (...(f iN-1 iN))&lt;/c&gt;. Raises ArgumentException if the array has size zero.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.reduce``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Collections.Generic.List{``0})">
<summary>
 Apply a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; 
 then computes &lt;c&gt;f (... (f i0 i1)...) iN&lt;/c&gt;. Raises ArgumentException if the array has size zero.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.findIndexi``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},System.Collections.Generic.List{``0})">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate. Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if 
 none of the elements satisfy the predicate.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.findIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate. Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if 
 none of the elements satisfy the predicate.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.exists2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Test elements of the two arrays pairwise to see if any pair of element satisfies the given predicate.
 Raise ArgumentException if the arrays have different lengths.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.toSeq``1(System.Collections.Generic.List{``0})">
<summary>
 Return a view of the array as an enumerable object
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.ofArray``1(``0[])">
<summary>
 Build a ResizeArray from the given elements
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.toArray``1(System.Collections.Generic.List{``0})">
<summary>
 Return a fixed-length array containing the elements of the input ResizeArray
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.sortBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.List{``0})">
<summary>
 Sort the elements using the key extractor and generic comparison on the keys
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.sort``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}},System.Collections.Generic.List{``0})">
<summary>
 Sort the elements using the given comparison function
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.rev``1(System.Collections.Generic.List{``0})">
<summary>
Return a new array with the elements in reverse order
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.tryPick``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.List{``0})">
<summary>
Apply the given function to successive elements, returning the first
result where function returns &quot;Some(x)&quot; for some x.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.tryFind``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
Return the first element for which the given function returns &lt;c&gt;true&lt;/c&gt;.
Return None if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.find``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
Return the first element for which the given function returns &lt;c&gt;true&lt;/c&gt;.
Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.choose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.List{``0})">
<summary>
Apply the given function to each element of the array. Return
the array comprised of the results &quot;x&quot; for each element where
the function returns Some(x)
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.partition``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
Split the collection into two collections, containing the 
elements for which the given predicate returns &lt;c&gt;true&lt;/c&gt; and &lt;c&gt;false&lt;/c&gt;
respectively 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
Return a new collection containing only the elements of the collection
for which the given predicate returns &lt;c&gt;true&lt;/c&gt;
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.forall``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
 Test if all elements of the array satisfy the given predicate.
 If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; and &quot;j0...jN&quot;
 then computes &lt;c&gt;p i0 &amp;&amp; ... &amp;&amp; p iN&lt;/c&gt;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.exists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
 Test if any element of the array satisfies the given predicate.
 If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; 
 then computes &lt;c&gt;p i0 or ... or p iN&lt;/c&gt;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.mapi``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},System.Collections.Generic.List{``0})">
<summary>
Build a new array whose elements are the results of applying the given function
to each of the elements of the array. The integer index passed to the
function indicates the index of element being transformed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.iteri``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},System.Collections.Generic.List{``0})">
<summary>
Apply the given function to each element of the array.  The integer passed to the
function indicates the index of element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
Build a new collection whose elements are the results of applying the given function
to the corresponding elements of the two collections pairwise.  The two input
arrays must have the same lengths.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.iter2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
Apply the given function to two arrays simultaneously. The
two arrays must have the same lengths, otherwise an Invalid_argument exception is
raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.List{``0})">
<summary>
Build a new array whose elements are the results of applying the given function
to each of the elements of the array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.iter``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},System.Collections.Generic.List{``0})">
<summary>
Apply the given function to each element of the array. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.foldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},System.Collections.Generic.List{``0},``1)">
<summary>
 Apply a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; then 
 computes &lt;c&gt;f i0 (...(f iN s))&lt;/c&gt;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,System.Collections.Generic.List{``1})">
<summary>
 Apply a function to each element of the collection, threading an accumulator argument
 through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; 
 then computes &lt;c&gt;f (... (f s i0)...) iN&lt;/c&gt;
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
Build and array from the given seq
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.ofList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
Build an array from the given list
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.toList``1(System.Collections.Generic.List{``0})">
<summary>
Build a list from the given array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.blit``1(System.Collections.Generic.List{``0},System.Int32,System.Collections.Generic.List{``0},System.Int32,System.Int32)">
<summary>
Read a range of elements from the first array and write them into the second.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.fill``1(System.Collections.Generic.List{``0},System.Int32,System.Int32,``0)">
<summary>
Fill a range of the collection with the given element
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.copy``1(System.Collections.Generic.List{``0})">
<summary>
Build a new array that contains the elements of the given array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.sub``1(System.Collections.Generic.List{``0},System.Int32,System.Int32)">
<summary>
Build a new array that contains the given subrange specified by
starting index and length.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.concat``1(Microsoft.FSharp.Collections.FSharpList{System.Collections.Generic.List{``0}})">
<summary>
Build a new array that contains the elements of each of the given list of arrays
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.append``1(System.Collections.Generic.List{``0},System.Collections.Generic.List{``0})">
<summary>
Build a new array that contains the elements of the first array followed by the elements of the second array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.init``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
<summary>
 Create an array by calling the given generator on each index.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.create``1(System.Int32,``0)">
<summary>
 Create an array whose elements are all initially the given value.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.set``1(System.Collections.Generic.List{``0},System.Int32,``0)">
<summary>
 Set the value of an element in the collection. You can also use the syntax &lt;c&gt;arr.[idx] &lt;- e&lt;/c&gt;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.get``1(System.Collections.Generic.List{``0},System.Int32)">
<summary>
 Fetch an element from the collection.  You can also use the syntax &lt;c&gt;arr.[idx]&lt;/c&gt;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.length``1(System.Collections.Generic.List{``0})">
<summary>
 Return the length of the collection.  You can also use property &lt;c&gt;arr.Length&lt;/c&gt;.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.ResizeArrayModule">
<summary>
 Generic operations on the type System.Collections.Generic.List, which is called ResizeArray in the F# libraries.
</summary>
</member>
<member name="P:Microsoft.FSharp.Control.AsyncResultCell`1.AsyncResult">
<summary>
 Wait for the result and commit it
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncResultCell`1.RegisterResult(Microsoft.FSharp.Control.AsyncResult{`0},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Record the result in the AsyncResultCell. Subsequent sets of the result are ignored. 

 This may result in the scheduled resumption of a waiting asynchronous operation  
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncResultCell`1.#ctor">
<summary>
 Create a new result cell
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.AsyncResultCell`1">
<summary>
 A helper type to store a single result from an asynchronous computation and asynchronously
 access its result.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Control.AsyncResult`1.Commit(Microsoft.FSharp.Control.AsyncResult{`0})">
<summary>
 Create an async whose result depends on the value of an AsyncResult.
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.AsyncResult`1">
<summary>
 Represents the reified result of an asynchronous computation
</summary>
</member>
<member name="P:Microsoft.FSharp.Control.AsyncStreamReader.EndOfStream">
<summary>
 An async that produces true if the reader is at the end of stream and false otherwise

 Note that when the async is run it reflects the reader state at the time of running; multiple runs will 
 yield different results.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Control.AsyncStreamReader.ReadToEnd">
<summary>
 Creates an async that read all characters in the stream up to the end.

 Note that when the async is run it reflects the reader state at the time of running; multiple runs will 
 yield different results.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncStreamReader.ReadLine">
<summary>
 Creates an async that reads next line from the stream

 Note that when the async is run it reflects the reader state at the time of running; multiple runs will 
 yield different results.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncStreamReader.ReadExactly(System.Char[],System.Int32,System.Int32)">
<summary>
 Creates an async that reads exactly &lt;c&gt;count&lt;/c&gt; characters from the stream unless end of stream is reached and puts them 
 into &lt;c&gt;buffer&lt;/c&gt; starting at &lt;c&gt;index&lt;/c&gt;. The async returns the number of characters that are read (if end-of-stream is not reached
 that will be &lt;c&gt;count&lt;/c&gt;

 Note that when the async is run it reflects the reader state at the time of running; multiple runs will 
 yield different results.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncStreamReader.Read(System.Char[],System.Int32,System.Int32)">
<summary>
 Creates an async that reads all the charactes that are avilable in the stream up to &lt;c&gt;count&lt;/c characters and puts them 
 into &lt;c&gt;buffer&lt;/c&gt; starting at &lt;c&gt;index&lt;/c&gt;. The async returns the number of characters that are read.

 Note that when the async is run it reflects the reader state at the time of running; multiple runs will 
 yield different results.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncStreamReader.Read">
<summary>
 Creates an async that reads next character from the stream

 Note that when the async is run it reflects the reader state at the time of running; multiple runs will 
 yield different results.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncStreamReader.Peek">
<summary>
 Creates an async that produces next character from the stream without advancing the stream

 Note that when the async is run it reflects the reader state at the time of running; multiple runs will 
 yield different results.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncStreamReader.DiscardBufferedData">
<summary>
. DiscardBufferedData tells StreamReader to throw away its internal 
. buffer contents.  This is useful if the user needs to seek on the
 underlying stream to a known location then wants the StreamReader 
 to start reading from this new point.  This method should be called
 very sparingly, if ever, since it can lead to very poor performance.
 However, it may be the only way of handling some scenarios where
 users need to re-read the contents of a StreamReader a second time. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Control.AsyncStreamReader.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean,System.Int32)">
<summary>
 Creates a new AsyncStreamReader for the given stream.  The 
 character encoding is set by encoding and the buffer size,
 in number of 16-bit characters, is set by bufferSize. 
 
 Note that detectEncodingFromByteOrderMarks is a very
 loose attempt at detecting the encoding by looking at the first 
 3 bytes of the stream.  It will recognize UTF-8, little endian
 unicode, and big endian unicode text, but that&apos;s it.  If neither
 of those three match, it will use the Encoding you provided.
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.AsyncStreamReader">
 <summary>
 Implements a TextReader-like API that asynchronously reads characters from 
 a byte stream in a particular encoding.
 </summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Control.FileExtensions.File.AsyncOpen.Static(System.String,System.IO.FileMode,Microsoft.FSharp.Core.FSharpOption{System.IO.FileAccess},Microsoft.FSharp.Core.FSharpOption{System.IO.FileShare},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.IO.FileOptions})">
<summary>
 Create an async that opens a &lt;c&gt;System.IO.FileStream&lt;/c&gt; on the specified path, via a fresh I/O thread.
 Pass &lt;c&gt;options=FileOptions.Asynchronous&lt;/c&gt; to enable further asynchronous read/write operations
 on the FileStream.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FileExtensions.File.AsyncAppendText.Static(System.String)">
<summary>
 Create an async that returns a &lt;c&gt;System.IO.StreamWriter&lt;/c&gt; that appends UTF-8 text to an existing file, via a fresh I/O thread.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FileExtensions.File.AsyncOpenWrite.Static(System.String)">
<summary>
 Create an async that opens an existing file writing, via a fresh I/O thread.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FileExtensions.File.AsyncOpenRead.Static(System.String)">
<summary>
 Create an async that opens a &lt;c&gt;System.IO.FileStream&lt;/c&gt; on the specified path for read/write access, via a fresh I/O thread.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FileExtensions.File.AsyncOpenText.Static(System.String)">
<summary>
 Create an async that opens an existing file for reading, via a fresh I/O thread.
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.FileExtensions">

</member>
<member name="M:Microsoft.FSharp.Control.StreamReaderExtensions.StreamReader.AsyncReadToEnd(System.IO.StreamReader)">
<summary>
 Return an asynchronous computation that will read to the end of a stream via a fresh I/O thread.
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.StreamReaderExtensions">

</member>
<member name="M:Microsoft.FSharp.Control.WebClientExtensions.WebClient.AsyncDownloadData(System.Net.WebClient,System.Uri)">
<summary>
 Returns an asynchronous computation that, when run, will wait for the download of the specified resource as a data buffer.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.WebClientExtensions.WebClient.AsyncDownloadFile(System.Net.WebClient,System.Uri,System.String)">
<summary>
 Returns an asynchronous computation that, when run, will wait for the download of a resource with the specified URI to the local file.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.WebClientExtensions.WebClient.AsyncOpenRead(System.Net.WebClient,System.Uri)">
<summary>
 Returns an asynchronous computation that, when run, will wait for the opening of a readable stream containing the specified resource.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.WebClientExtensions.WebClient.AsyncOpenWrite(System.Net.WebClient,System.Uri,System.String)">
<summary>
 Returns an asynchronous computation that, when run, will wait for the opening of a stream for writing data to the specified resource.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.WebClientExtensions.WebClient.AsyncOpenWrite(System.Net.WebClient,System.Uri)">
<summary>
 Returns an asynchronous computation that, when run, will wait for the opening of a stream for writing data to the specified resource.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.WebClientExtensions.WebClient.AsyncUploadData(System.Net.WebClient,System.Uri,System.String,System.Byte[])">
<summary>
 Returns an asynchronous computation that, when run, will wait for the upload of a data buffer to a resource identified by a URI, using the specified method.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.WebClientExtensions.WebClient.AsyncUploadData(System.Net.WebClient,System.Uri,System.Byte[])">
<summary>
 Returns an asynchronous computation that, when run, will wait for the upload of a data buffer to a resource identified by a URI, using the POST method.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.WebClientExtensions.WebClient.AsyncUploadFile(System.Net.WebClient,System.Uri,System.String,System.String)">
<summary>
 Returns an asynchronous computation that, when run, will wait for the upload of the specified local file to the specified resource, using the specified method.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.WebClientExtensions.WebClient.AsyncUploadFile(System.Net.WebClient,System.Uri,System.String)">
<summary>
 Returns an asynchronous computation that, when run, will wait for the upload of the specified local file to the specified resource, using the POST method.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.WebClientExtensions.WebClient.AsyncUploadString(System.Net.WebClient,System.Uri,System.String,System.String)">
<summary>
 Returns an asynchronous computation that, when run, will wait for the upload of the specified string to the specified resource, using the specified method.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.WebClientExtensions.WebClient.AsyncUploadString(System.Net.WebClient,System.Uri,System.String)">
<summary>
 Returns an asynchronous computation that, when run, will wait for the upload of the specified string to the specified resource.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.WebClientExtensions.WebClient.AsyncUploadValues(System.Net.WebClient,System.Uri,System.String,System.Collections.Specialized.NameValueCollection)">
<summary>
 Returns an asynchronous computation that, when run, will wait for the upload of the data in the specified name/value collection to the resource identified by the specified URI, using the specified method.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.WebClientExtensions.WebClient.AsyncUploadValues(System.Net.WebClient,System.Uri,System.Collections.Specialized.NameValueCollection)">
<summary>
 Returns an asynchronous computation that, when run, will wait for the upload of the data in the specified name/value collection to the resource identified by the specified URI.
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Control.WebClientExtensions">

</member>
<member name="M:Microsoft.FSharp.Control.WebRequestExtensions.WebRequest.AsyncGetResponse(System.Net.WebRequest)">
<summary>
 Return an asynchronous computation that, when run, will wait for a response to the given WebRequest.
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.WebRequestExtensions">

</member>
</members>
</doc>
