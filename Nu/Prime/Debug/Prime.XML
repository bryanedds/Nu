<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>Prime</name></assembly>
<members>
<member name="M:Array.tryFindIndexRev``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
<summary>
 Try to find an index in reverse.
</summary>
</member>
<member name="M:List.hash``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Hash a list.
 NOTE: May be a pessimization.
</summary>
</member>
<member name="M:List.compareStrings(Microsoft.FSharp.Collections.FSharpList{System.String},Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Compare a list of strings lexicographically.
</summary>
</member>
<member name="M:List.stackLeft``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Stack a list from the left, starting with the empty list.
 Example - [0, 1, 2] becomes [[]; [0]; [0; 1]; [0; 1; 2]]
</summary>
</member>
<member name="M:List.remove``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Remove all elements from a list that satisfy a predicate.
</summary>
</member>
<member name="M:List.foldWhile``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``0}}},``0,Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Implement a fold while folder results in Some.
</summary>
</member>
<member name="M:List.toHashSet``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Convert a list to a HashSet.
</summary>
</member>
<member name="M:List.toDictBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{``1,``2}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Convert a list of values to a Dictionary.
</summary>
</member>
<member name="M:List.toDict``2(Microsoft.FSharp.Collections.FSharpList{System.Tuple{``0,``1}})">
<summary>
 Convert a list of pairs to a Dictionary.
</summary>
</member>
<member name="M:List.addToDictBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{``1,``2}},System.Collections.Generic.Dictionary{``1,``2},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Add a list of values to a Dictionary.
</summary>
</member>
<member name="M:List.addToDict``2(System.Collections.Generic.Dictionary{``0,``1},Microsoft.FSharp.Collections.FSharpList{System.Tuple{``0,``1}})">
<summary>
 Add a list of pairs to a Dictionary.
</summary>
</member>
<member name="M:List.intersect``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Get the set interesection of two lists.
</summary>
</member>
<member name="M:List.isSuperset``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Query that the first list a superset of the second list.
</summary>
</member>
<member name="M:List.isSubset``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Query that the first list a subset of the second list.
</summary>
</member>
<member name="M:List.setBinop``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpSet{``1},``2}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Runs a binary set operation on two lists that are converted to sets.
</summary>
</member>
<member name="M:List.takeTillInclusive``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Take elements until an element satisfies a predicate, taking also that element.
</summary>
</member>
<member name="M:List.joinList``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{``0}})">
<summary>
 Join a list of lists into a list separated by sep.
</summary>
</member>
<member name="M:List.joinBy``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.String},System.String,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Join a list into a string separated by sep.
 TODO: consider optimizing with a StringBuilder.
</summary>
</member>
<member name="M:List.join(System.String,Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Join a list into a string separated by sep.
</summary>
</member>
<member name="M:List.padWithLastToProportion``2(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Pad a list with instances of its last item so that it is proportion to another list.
</summary>
</member>
<member name="M:List.padWithLast``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Pad a list with count instances of its last item.
</summary>
</member>
<member name="M:List.pad``1(System.Int32,``0,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Pad a list with count instances of its last item, removing items from back if count is negative.
</summary>
</member>
<member name="M:List.allOrEmptyBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Make a transformed list of options an all or nothing proposition.
 TODO: optimize with program fusion.
</summary>
</member>
<member name="M:List.allOrEmpty``1(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
 Make a list of options an all or nothing proposition.
 TODO: optimize with program fusion.
</summary>
</member>
<member name="M:List.definitize``1(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
 Convert option values to definite values.
</summary>
</member>
<member name="M:List.allButLast``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Get all but the last item from a list.
</summary>
</member>
<member name="M:List.foldi``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}},``0,Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Foldi for lists.
</summary>
</member>
<member name="M:List.fornone``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Fornone for lists.
</summary>
</member>
<member name="M:List.replaceHead``1(Microsoft.FSharp.Collections.FSharpList{``0},``0)">
<summary>
 Replace a list&apos;s head.
</summary>
</member>
<member name="M:List.project``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Collections.FSharpList{``1},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
 Project the first list onto the second.
</summary>
</member>
<member name="M:List.tryTake``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 A more tolerant and open-minded take.
</summary>
</member>
<member name="M:List.zipBy``3(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1},``2},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Zip two lists by a function.
 TODO: optimize with program fusion.
</summary>
</member>
<member name="M:List.roll``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}},``0,Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Threads a computation state through the adjacent members of a list.
</summary>
</member>
<member name="M:List.forall2Plus``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 For all 2 that indicates uneven lists by returning false rather than raising.
</summary>
</member>
<member name="M:List.tryFindAt``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Try to find a value at index n.
</summary>
</member>
<member name="M:List.tryFindPlus``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Try to find a value.
</summary>
</member>
<member name="M:List.areSameLength``2(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Query that two lists are of the same length.
</summary>
</member>
<member name="M:List.hasBetween``1(System.Int32,System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Query that a list has at least n elements.
</summary>
</member>
<member name="M:List.hasExactly``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Query that a list has exactly n elements.
</summary>
</member>
<member name="M:List.hasAtMost``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Query that a list has at most n elements.
</summary>
</member>
<member name="M:List.hasAtLeast``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Query that a list has at least n elements.
</summary>
</member>
<member name="M:List.partitionPlus``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Partition a list.
</summary>
</member>
<member name="M:List.notExists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Check that a predicate passes for NO items in a list.
</summary>
</member>
<member name="M:List.flipCons``1(Microsoft.FSharp.Collections.FSharpList{``0},``0)">
<summary>
 Cons with flipped arguments.
</summary>
</member>
<member name="M:List.cons``1(``0,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 The missing cons function.
</summary>
</member>
<member name="T:Prime.AddressConverter">
<summary>
 Converts Address types.
</summary>
</member>
<member name="T:Prime.BoxableSubscription`1">
<summary>
 Describes an event subscription that can be boxed / unboxed.
</summary>
</member>
<member name="M:Prime.ChainBuilder.Return``3(``0)">
<summary>
 Monadic return for the chain monad.
</summary>
</member>
<member name="M:Prime.ChainBuilder.Bind``4(Prime.Chain{``0,``1,``2},Microsoft.FSharp.Core.FSharpFunc{``1,Prime.Chain{``0,``3,``2}})">
<summary>
 Monadic bind for the chain monad.
</summary>
</member>
<member name="T:Prime.ChainBuilder">
<summary>
 Implements the chain monad.
</summary>
</member>
<member name="T:Prime.Chain`3">
<summary>
 The Chain monad. Allows the user to define a chain of operations over the world that
 optionally spans across a bounded number of events.

 The following is a potentially tail-recursible representation as speculated by @tpetracek -
 &apos;w -&gt; (&apos;w * Either&lt;&apos;e -&gt; Chain&lt;&apos;e, &apos;a, &apos;w&gt;, &apos;a&gt; -&gt; &apos;a) -&gt; &apos;a
</summary>
</member>
<member name="T:Prime.Either`2">
<summary>
 Haskell-style Either type.
</summary>
</member>
<member name="T:Prime.Event`2">
<summary>
 An event used by the event system.
</summary>
</member>
<member name="T:Prime.Eventable`1">
<summary>
 Adds the capability to use purely-functional events with the given program type &apos;w.
</summary>
</member>
<member name="T:Prime.Handling">
<summary>
 Describes whether an in-flight event has been resolved or should cascade to down-stream handlers.
</summary>
</member>
<member name="T:Prime.Hkv`2">
<summary>
 A hash-key-value triple, implemented with a struct for efficiency.
</summary>
</member>
<member name="T:Prime.LabelName">
<summary>
 Along with the Label binding, is used to elaborate the name of a target without using a
 string literal.
</summary>
</member>
<member name="T:Prime.Liveness">
<summary>
 Specifies whether an event-based application is running or exiting.
</summary>
</member>
<member name="T:Prime.NameConverter">
<summary>
 Converts Name types.
</summary>
</member>
<member name="T:Prime.Observation`3">
<summary>
 An observation in the functional reactive style.
</summary>
</member>
<member name="T:Prime.Participant">
<summary>
 A participant in the event system.
</summary>
</member>
<member name="T:Prime.ParticipantChangeData`2">
<summary>
 The data for a change in a participant.
</summary>
</member>
<member name="M:Prime.ParticipantOperators.op_MinusGreaterMinus``1(Prime.AddressModule.Address{``0},Prime.Participant)">
<summary>
 Concatenate two addresses, takings the type of first address.
</summary>
</member>
<member name="M:Prime.ParticipantOperators.acatf``1(Prime.AddressModule.Address{``0},Prime.Participant)">
<summary>
 Concatenate two addresses, forcing the type of first address.
</summary>
</member>
<member name="T:Prime.ParticipantOperators">
<summary>
 Operators for the Participant type.
</summary>
</member>
<member name="T:Prime.RelationConverter">
<summary>
 Converts Relation types.
</summary>
</member>
<member name="T:Prime.Rexpr">
<summary>
 Effectively new-types the Regex type to implement custom type-conversation without needing
 explicit initialization by the client program.
</summary>
</member>
<member name="T:Prime.RexprConverter">
<summary>
 Converts Rexpr types.
</summary>
</member>
<member name="T:Prime.SubscriptionEntries">
<summary>
 A map of event subscriptions.
</summary>
</member>
<member name="T:Prime.SubscriptionEntry">
<summary>
 An entry in the subscription map.
</summary>
</member>
<member name="T:Prime.SubscriptionSorter`1">
<summary>
 Abstracts over a subscription sorting procedure.
</summary>
</member>
<member name="T:Prime.Subscription`3">
<summary>
 Describes an event subscription.
</summary>
</member>
<member name="T:Prime.SymbolicCompression`2">
<summary>
 Compresses two unions into a single union in a symbolic-expression.
</summary>
</member>
<member name="T:Prime.UnsubscriptionEntries">
<summary>
 A map of subscription keys to unsubscription data.
</summary>
</member>
<member name="T:Prime.VsyncBuilder">
<summary>
 The Vsync computation expression builder.
</summary>
</member>
<member name="T:Prime.XDefaultValueAttribute">
<summary>
 An attribute to specify the default value of an XProperty.
</summary>
</member>
<member name="T:Prime.XProperties">
<summary>
 A map of XProperties.
</summary>
</member>
<member name="T:Prime.XProperty">
<summary>
 An Xtension property.
</summary>
</member>
<member name="T:Prime.XPropertyDescriptor">
<summary>
 Describes an XProperty.
</summary>
</member>
<member name="M:Prime.AddressModule.Address`1.op_MinusLessMinus``1(Prime.AddressModule.Address{System.Object},Prime.AddressModule.Address{``0})">
<summary>
 Concatenate two addresses, taking the type of the second address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address`1.op_MinusLessLessMinus``1(Prime.AddressModule.Address{`0},Prime.AddressModule.Address{``0})">
<summary>
 Concatenate two addresses, forcing the type of second address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address`1.op_MinusGreaterMinus(Prime.AddressModule.Address{`0},Prime.AddressModule.Address{System.Object})">
<summary>
 Concatenate two addresses, taking the type of first address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address`1.op_MinusGreaterGreaterMinus``1(Prime.AddressModule.Address{`0},Prime.AddressModule.Address{``0})">
<summary>
 Concatenate two addresses, forcing the type of first address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address`1.op_MinusBarMinus(Prime.AddressModule.Address{`0},Prime.AddressModule.Address{`0})">
<summary>
 Concatenate two addresses of the same type.
</summary>
</member>
<member name="M:Prime.AddressModule.Address`1.ntoa``1(Prime.NameModule.Name)">
<summary>
 Convert a single name into an address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address`1.makeFromFullName``1(Prime.NameModule.Name)">
<summary>
 Make an address from a &apos;/&apos; delimited string.
 NOTE: do not move this function as the AddressConverter&apos;s reflection code relies on it being exactly here!
</summary>
</member>
<member name="M:Prime.AddressModule.Address`1.ltoa``1(Microsoft.FSharp.Collections.FSharpList{Prime.NameModule.Name})">
<summary>
 Convert a names list into an address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address`1.hash(Prime.AddressModule.Address{`0})">
<summary>
 Hash an Address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address`1.ftoa``1(Prime.NameModule.Name)">
<summary>
 Convert a full name into an address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address`1.equals``2(Prime.AddressModule.Address{``0},Prime.AddressModule.Address{``1})">
<summary>
 Equate Addresses.
</summary>
</member>
<member name="M:Prime.AddressModule.Address`1.compare``2(Prime.AddressModule.Address{``0},Prime.AddressModule.Address{``1})">
<summary>
 Compare Addresses.
</summary>
</member>
<member name="M:Prime.AddressModule.Address`1.atooa``1(Prime.AddressModule.Address{`0})">
<summary>
 Convert any address to an obj Address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address`1.atoa``2(Prime.AddressModule.Address{`0})">
<summary>
 Convert an address of type &apos;a to an address of type &apos;b.
</summary>
</member>
<member name="M:Prime.AddressModule.Address`1.acatsf``2(Prime.AddressModule.Address{`0},Prime.AddressModule.Address{``1})">
<summary>
 Concatenate two addresses, forcing the type of second address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address`1.acats``1(Prime.AddressModule.Address{System.Object},Prime.AddressModule.Address{`0})">
<summary>
 Concatenate two addresses, taking the type of the second address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address`1.acatff``2(Prime.AddressModule.Address{`0},Prime.AddressModule.Address{``1})">
<summary>
 Concatenate two addresses, forcing the type of first address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address`1.acatf``1(Prime.AddressModule.Address{`0},Prime.AddressModule.Address{System.Object})">
<summary>
 Concatenate two addresses, taking the type of first address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address`1.acat``1(Prime.AddressModule.Address{`0},Prime.AddressModule.Address{`0})">
<summary>
 Concatenate two addresses of the same type.
</summary>
</member>
<member name="T:Prime.AddressModule.Address`1">
<summary>
 Specifies the address of an identifiable value.
</summary>
</member>
<member name="M:Prime.AddressModule.Address.isEmpty``1(Prime.AddressModule.Address{``0})">
<summary>
 Query that an address is devoid of names.
</summary>
</member>
<member name="M:Prime.AddressModule.Address.length``1(Prime.AddressModule.Address{``0})">
<summary>
 Get the length of an address by its names.
</summary>
</member>
<member name="M:Prime.AddressModule.Address.allButLast``2(Prime.AddressModule.Address{``0})">
<summary>
 Take an address composed of all but the last name of an address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address.last``1(Prime.AddressModule.Address{``0})">
<summary>
 Take the last name of an address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address.take``2(System.Int32,Prime.AddressModule.Address{``0})">
<summary>
 Take an address composed of the given number of names of an address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address.skip``2(System.Int32,Prime.AddressModule.Address{``0})">
<summary>
 Take an address composed of the name of an address minus a skipped amount of names.
</summary>
</member>
<member name="M:Prime.AddressModule.Address.item``1(System.Int32,Prime.AddressModule.Address{``0})">
<summary>
 Take a name of an address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address.tail``1(Prime.AddressModule.Address{System.Object})">
<summary>
 Take the tail of an address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address.head``1(Prime.AddressModule.Address{``0})">
<summary>
 Take the head of an address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address.getHashCode``1(Prime.AddressModule.Address{``0})">
<summary>
 Get the address&apos;s hash code.
</summary>
</member>
<member name="M:Prime.AddressModule.Address.getName``1(Prime.AddressModule.Address{``0})">
<summary>
 Get the name of an address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address.getFullName``1(Prime.AddressModule.Address{``0})">
<summary>
 Get the full name of an address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address.changeType``2(Prime.AddressModule.Address{``0})">
<summary>
 Change the type of an address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address.getNames``1(Prime.AddressModule.Address{``0})">
<summary>
 Get the names of an address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address.makeFromFullName``1(Prime.NameModule.Name)">
<summary>
 Make an address from a &apos;/&apos; delimited string.
</summary>
</member>
<member name="M:Prime.AddressModule.Address.makeFromNames``1(Microsoft.FSharp.Collections.FSharpList{Prime.NameModule.Name})">
<summary>
 Make an address from names.
</summary>
</member>
<member name="M:Prime.AddressModule.Address.empty``1">
<summary>
 The empty address.
</summary>
</member>
<member name="M:Prime.AddressOperators.acatsf``2(Prime.AddressModule.Address{``0},Prime.AddressModule.Address{``1})">
<summary>
 Concatenate two addresses, forcing the type of second address.
</summary>
</member>
<member name="M:Prime.AddressOperators.acats``1(Prime.AddressModule.Address{System.Object},Prime.AddressModule.Address{``0})">
<summary>
 Concatenate two addresses, taking the type of the second address.
</summary>
</member>
<member name="M:Prime.AddressOperators.acatff``2(Prime.AddressModule.Address{``0},Prime.AddressModule.Address{``1})">
<summary>
 Concatenate two addresses, forcing the type of first address.
</summary>
</member>
<member name="M:Prime.AddressOperators.acatf``1(Prime.AddressModule.Address{``0},Prime.AddressModule.Address{System.Object})">
<summary>
 Concatenate two addresses, taking the type of first address.
</summary>
</member>
<member name="M:Prime.AddressOperators.acat``1(Prime.AddressModule.Address{``0},Prime.AddressModule.Address{``0})">
<summary>
 Concatenate two addresses of the same type.
</summary>
</member>
<member name="M:Prime.AddressOperators.atooa``1(Prime.AddressModule.Address{``0})">
<summary>
 Convert any address to an obj Address.
</summary>
</member>
<member name="M:Prime.AddressOperators.ntoa``1(Prime.NameModule.Name)">
<summary>
 Convert a single name into an address.
</summary>
</member>
<member name="M:Prime.AddressOperators.ftoa``1(Prime.NameModule.Name)">
<summary>
 Convert a full name into an address.
</summary>
</member>
<member name="M:Prime.AddressOperators.ltoa``1(Microsoft.FSharp.Collections.FSharpList{Prime.NameModule.Name})">
<summary>
 Convert a names list into an address.
</summary>
</member>
<member name="M:Prime.AddressOperators.atoa``2(Prime.AddressModule.Address{``0})">
<summary>
 Convert an address of type &apos;a to an address of type &apos;b.
</summary>
</member>
<member name="M:Prime.Async.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Creates an asynchronous operation that runs &apos;f&apos; over computation of &apos;a&apos;.
</summary>
</member>
<member name="T:Prime.Async">
<summary>
 Async is missing a couple of functions, as we know...
</summary>
</member>
<member name="M:Prime.Chain.runAssumingResolve``3(Prime.Chain{Prime.Event{``0,``1},Microsoft.FSharp.Core.Unit,``2},Prime.Observation{``0,``1,``2},``2)">
<summary>
 Run a chain over Nu&apos;s event system.
 Allows each chainhronized operation to run without referencing its source event, and
 without specifying its event handling approach by assuming Resolve.
</summary>
</member>
<member name="M:Prime.Chain.runAssumingCascade``3(Prime.Chain{Prime.Event{``0,``1},Microsoft.FSharp.Core.Unit,``2},Prime.Observation{``0,``1,``2},``2)">
<summary>
 Run a chain over Nu&apos;s event system.
 Allows each chainhronized operation to run without referencing its source event, and
 without specifying its event handling approach by assuming Cascade.
</summary>
</member>
<member name="M:Prime.Chain.run``2(Prime.Chain{Microsoft.FSharp.Core.Unit,``0,``1},``1)">
<summary>
 Run a chain to its end, providing unit for all its steps.
</summary>
</member>
<member name="M:Prime.Chain.run2``2(Prime.Chain{Microsoft.FSharp.Core.Unit,``0,``1},``1)">
<summary>
 Run a chain to its end, providing unit for all its steps.
</summary>
</member>
<member name="M:Prime.Chain.run3``3(Prime.Chain{``0,``1,``2},``0,``2)">
<summary>
 Run a chain to its end, providing &apos;e&apos; for all its steps.
</summary>
</member>
<member name="M:Prime.Chain.advance``3(Microsoft.FSharp.Core.FSharpFunc{``0,Prime.Chain{``0,``1,``2}},``0,``2)">
<summary>
 Advance a chain value by one step, providing &apos;e&apos;.
</summary>
</member>
<member name="M:Prime.Chain.step``3(Prime.Chain{``0,``1,``2},``2)">
<summary>
 Step once into a chain.
</summary>
</member>
<member name="M:Prime.Chain.during``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Prime.Chain{``1,Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Loop in a chain context while &apos;pred&apos; evaluates to true.
</summary>
</member>
<member name="M:Prime.Chain.loop``3(``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},Microsoft.FSharp.Core.FSharpFunc{``0,Prime.Chain{``2,Microsoft.FSharp.Core.Unit,``1}})">
<summary>
 Loop in a chain context while &apos;pred&apos; evaluate to true.
</summary>
</member>
<member name="M:Prime.Chain.react``2(Microsoft.FSharp.Core.FSharpFunc{``0,``0})">
<summary>
 React to the next event, discarding the event&apos;s value.
</summary>
</member>
<member name="M:Prime.Chain.reactE``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}})">
<summary>
 React to the next event, using the event&apos;s value in the reaction.
</summary>
</member>
<member name="M:Prime.Chain.pass``2">
<summary>
 Pass over the next event.
</summary>
</member>
<member name="M:Prime.Chain.next``2">
<summary>
 Get the next event.
</summary>
</member>
<member name="M:Prime.Chain.update``2(Microsoft.FSharp.Core.FSharpFunc{``0,``0})">
<summary>
 Update the world.
</summary>
</member>
<member name="M:Prime.Chain.updateBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``0}})">
<summary>
 Update the world with an additional transformed world parameter.
</summary>
</member>
<member name="M:Prime.Chain.set``2(``0)">
<summary>
 Set the world.
</summary>
</member>
<member name="M:Prime.Chain.getBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Get the world transformed by &apos;by&apos;.
</summary>
</member>
<member name="M:Prime.Chain.get``2">
<summary>
 Get the world.
</summary>
</member>
<member name="M:Prime.Chain.bind``4(Prime.Chain{``0,``1,``2},Microsoft.FSharp.Core.FSharpFunc{``1,Prime.Chain{``0,``3,``2}})">
<summary>
 Monadic bind for the chain monad.
</summary>
</member>
<member name="M:Prime.Chain.returnM``3(``0)">
<summary>
 Monadic return for the chain monad.
</summary>
</member>
<member name="P:Prime.ChainBuilderModule.chain">
<summary>
 Builds the chain monad.
</summary>
</member>
<member name="M:Prime.Dictionary.dictC``2(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}})">
<summary>
 Like dict, but returns a concrete Dictionary instance with structural hashing.
</summary>
</member>
<member name="M:Prime.Dictionary.tryFind``2(``0,System.Collections.Generic.Dictionary{``0,``1})">
<summary>
 Try to find a value in a dictonary.
</summary>
</member>
<member name="M:Prime.Dictionary.map``2(Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.KeyValuePair{``0,``1},``1},System.Collections.Generic.Dictionary{``0,``1})">
<summary>
 Map over a dictionary. A new dictionary is produced.
</summary>
</member>
<member name="M:Prime.Dictionary.singleton``2(``0,``1)">
<summary>
 Make a dictionary with a single element.
</summary>
</member>
<member name="M:Prime.DictionaryExtension.Dictionary`2.Consume``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.Dictionary{``0,``1})">
<summary>
 Add all the elements of another dictionary.
</summary>
</member>
<member name="M:Prime.DictionaryExtension.Dictionary`2.AddMany``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}})">
<summary>
 Add multiple kvps to a dictionary.
</summary>
</member>
<member name="M:Prime.DictionaryExtension.Dictionary`2.ValueEquals``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.Dictionary{``0,``1})">
<summary>
 Check value equality of dictionary.
 NOTE: be wary the highly imperative nature of this code.
</summary>
</member>
<member name="M:Prime.DictionaryExtension.Dictionary`2.ForceAdd``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1)">
<summary>
 Force the addition of an element, removing the existing one if necessary.
</summary>
</member>
<member name="M:Prime.DictionaryExtension.Dictionary`2.TryAdd``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1)">
<summary>
 Try to add an element, returning false upon failure.
</summary>
</member>
<member name="T:Prime.Either.EitherBuilder">
<summary>
 Builds an either monad.
</summary>
</member>
<member name="M:Prime.Either.split``2(System.Collections.Generic.IEnumerable{Prime.Either{``0,``1}})">
<summary>
 Split a sequences of Either values into a pair of left and right value lists.
</summary>
</member>
<member name="M:Prime.Either.mapRight``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Prime.Either{``2,``0})">
<summary>
 Map over the right side of an Either value.
</summary>
</member>
<member name="M:Prime.Either.mapLeft``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Prime.Either{``0,``2})">
<summary>
 Map over the left side of an Either value.
</summary>
</member>
<member name="M:Prime.Either.getRightValues``2(System.Collections.Generic.IEnumerable{Prime.Either{``0,``1}})">
<summary>
 Get only the Right values of a sequence of an Either value.
</summary>
</member>
<member name="M:Prime.Either.getLeftValues``2(System.Collections.Generic.IEnumerable{Prime.Either{``0,``1}})">
<summary>
 Get only the Left values of a sequence of an Either value.
</summary>
</member>
<member name="M:Prime.Either.getRightValue``2(Prime.Either{``0,``1})">
<summary>
 Get the Right value of an Either value, failing if not available.
</summary>
</member>
<member name="M:Prime.Either.getLeftValue``2(Prime.Either{``0,``1})">
<summary>
 Get the Left value of an Either value, failing if not available.
</summary>
</member>
<member name="M:Prime.Either.isRight``2(Prime.Either{``0,``1})">
<summary>
 Query whether an Either value is a Right value.
</summary>
</member>
<member name="M:Prime.Either.isLeft``2(Prime.Either{``0,``1})">
<summary>
 Query whether an Either value is a Left value.
</summary>
</member>
<member name="P:Prime.Either.either">
<summary>
 The computation expression builder for Either.
</summary>
</member>
<member name="M:Prime.Either.returnFrom``1(``0)">
<summary>
 Monadic &apos;return from&apos; for Either.
</summary>
</member>
<member name="M:Prime.Either.returnM``2(``0)">
<summary>
 Monadic return for Either.
</summary>
</member>
<member name="M:Prime.Either.bind``3(Prime.Either{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,Prime.Either{``0,``2}})">
<summary>
 Monadic bind for Either.
</summary>
</member>
<member name="T:Prime.EventFilter.EventFilter">
<summary>
 Describes how events are filtered.
</summary>
</member>
<member name="M:Prime.EventFilter.filter``1(System.String,System.Collections.Generic.IEnumerable{``0},Prime.EventFilter.EventFilter)">
<summary>
 Filter events.
</summary>
</member>
<member name="T:Prime.EventFilterModule.EventFilter">
<summary>
 Describes how events are filtered.
</summary>
</member>
<member name="T:Prime.EventSystemModule.EventSystem`1">
<summary>
 A publisher-neutral, purely functional event system.
</summary>
</member>
<member name="M:Prime.EventSystemModule.EventSystem.make``1(Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit},System.Boolean,Prime.EventFilter.EventFilter)">
<summary>
 Make an event system.
</summary>
</member>
<member name="M:Prime.EventSystemModule.EventSystem.logEvent``1(Prime.AddressModule.Address{System.Object},Microsoft.FSharp.Collections.FSharpList{Prime.EventInfo},Prime.EventSystemModule.EventSystem{``0})">
<summary>
 Log an event.
</summary>
</member>
<member name="M:Prime.EventSystemModule.EventSystem.setEventFilter``1(Prime.EventFilter.EventFilter,Prime.EventSystemModule.EventSystem{``0})">
<summary>
 Set the state of the event filter.
</summary>
</member>
<member name="M:Prime.EventSystemModule.EventSystem.getEventFilter``1(Prime.EventSystemModule.EventSystem{``0})">
<summary>
 Get the state of the event filter.
</summary>
</member>
<member name="M:Prime.EventSystemModule.EventSystem.setEventTracing``1(System.Boolean,Prime.EventSystemModule.EventSystem{``0})">
<summary>
 Set whether events are being traced.
</summary>
</member>
<member name="M:Prime.EventSystemModule.EventSystem.getEventTracing``1(Prime.EventSystemModule.EventSystem{``0})">
<summary>
 Get whether events are being traced.
</summary>
</member>
<member name="M:Prime.EventSystemModule.EventSystem.getEventState``2(System.Guid,Prime.EventSystemModule.EventSystem{``1})">
<summary>
 Get event state.
</summary>
</member>
<member name="M:Prime.EventSystemModule.EventSystem.setUnsubscriptions``1(Prime.VmapModule.Vmap{System.Guid,System.Tuple{Prime.AddressModule.Address{System.Object},Prime.Participant}},Prime.EventSystemModule.EventSystem{``0})">
<summary>
 Set unsubscriptions.
</summary>
</member>
<member name="M:Prime.EventSystemModule.EventSystem.setSubscriptions``1(Prime.VmapModule.Vmap{Prime.AddressModule.Address{System.Object},Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Guid,Prime.Participant,System.Object}}},Prime.EventSystemModule.EventSystem{``0})">
<summary>
 Set subscriptions.
</summary>
</member>
<member name="M:Prime.EventSystemModule.EventSystem.getUnsubscriptions``1(Prime.EventSystemModule.EventSystem{``0})">
<summary>
 Get unsubscriptions.
</summary>
</member>
<member name="M:Prime.EventSystemModule.EventSystem.getSubscriptions``1(Prime.EventSystemModule.EventSystem{``0})">
<summary>
 Get subscriptions.
</summary>
</member>
<member name="M:Prime.EventSystemModule.EventSystem.removeEventState``1(System.Guid,Prime.EventSystemModule.EventSystem{``0})">
<summary>
 Remove event state.
</summary>
</member>
<member name="M:Prime.EventSystemModule.EventSystem.addEventState``2(System.Guid,``0,Prime.EventSystemModule.EventSystem{``1})">
<summary>
 Add event state.
</summary>
</member>
<member name="M:Prime.Eventable.monitor``3(Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{Prime.Handling,``2}}},Prime.AddressModule.Address{``0},``1,``2)">
<summary>
 Keep active a subscription for the lifetime of a participant.
</summary>
</member>
<member name="M:Prime.Eventable.monitorPlus``3(Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{Prime.Handling,``2}}},Prime.AddressModule.Address{``0},``1,``2)">
<summary>
 Keep active a subscription for the lifetime of a participant, and be provided with an unsubscription callback.
</summary>
</member>
<member name="M:Prime.Eventable.subscribe``3(Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{Prime.Handling,``2}}},Prime.AddressModule.Address{``0},``1,``2)">
<summary>
 Subscribe to an event.
</summary>
</member>
<member name="M:Prime.Eventable.subscribe5``3(System.Guid,Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{Prime.Handling,``2}}},Prime.AddressModule.Address{``0},``1,``2)">
<summary>
 Subscribe to an event using the given subscriptionKey.
</summary>
</member>
<member name="M:Prime.Eventable.subscribePlus``3(Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{Prime.Handling,``2}}},Prime.AddressModule.Address{``0},``1,``2)">
<summary>
 Subscribe to an event, and be provided with an unsubscription callback.
</summary>
</member>
<member name="M:Prime.Eventable.subscribePlus5``3(System.Guid,Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{Prime.Handling,``2}}},Prime.AddressModule.Address{``0},``1,``2)">
<summary>
 Subscribe to an event using the given subscriptionKey, and be provided with an unsubscription callback.
</summary>
</member>
<member name="M:Prime.Eventable.unsubscribe``1(System.Guid,``0)">
<summary>
 Unsubscribe from an event.
</summary>
</member>
<member name="M:Prime.Eventable.publish``3(``0,Prime.AddressModule.Address{``0},Microsoft.FSharp.Collections.FSharpList{Prime.EventInfo},``1,``2)">
<summary>
 Publish an event with no subscription sorting.
</summary>
</member>
<member name="M:Prime.Eventable.publish6``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Guid,Prime.Participant,System.Object}},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Guid,Prime.Participant,System.Object}}}},``0,Prime.AddressModule.Address{``0},Microsoft.FSharp.Collections.FSharpList{Prime.EventInfo},``1,``2)">
<summary>
 Publish an event, using the given publishSorter procedure to arrange the order to which subscriptions are published.
</summary>
</member>
<member name="M:Prime.Eventable.publish7``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Guid,Prime.Participant,System.Object}},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Guid,Prime.Participant,System.Object}}}},Microsoft.FSharp.Core.FSharpFunc{Prime.AddressModule.Address{System.Object},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Guid,Prime.Participant,System.Object}}}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Guid,Prime.Participant,System.Object}},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Guid,Prime.Participant,System.Object}}}},``0,Prime.AddressModule.Address{``0},Microsoft.FSharp.Collections.FSharpList{Prime.EventInfo},``1,``2)">
<summary>
 Publish an event, using the given getSubscriptions and publishSorter procedures to arrange the order to which subscriptions are published.
</summary>
</member>
<member name="M:Prime.Eventable.sortSubscriptionsNone``1(Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Guid,Prime.Participant,System.Object}},``0)">
<summary>
 A &apos;no-op&apos; for subscription sorting - that is, performs no sorting at all.
</summary>
</member>
<member name="M:Prime.Eventable.sortSubscriptionsBy``1(Microsoft.FSharp.Core.FSharpFunc{Prime.Participant,Microsoft.FSharp.Core.FSharpFunc{``0,System.Single}},Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Guid,Prime.Participant,System.Object}},``0)">
<summary>
 Sort subscriptions using categorization via the &apos;by&apos; procedure.
</summary>
</member>
<member name="M:Prime.Eventable.setEventFilter``1(Prime.EventFilter.EventFilter,``0)">
<summary>
 Set the state of the event filter.
</summary>
</member>
<member name="M:Prime.Eventable.getEventFilter``1(``0)">
<summary>
 Get the state of the event filter.
</summary>
</member>
<member name="M:Prime.Eventable.setEventTracing``1(System.Boolean,``0)">
<summary>
 Set whether events are being traced.
</summary>
</member>
<member name="M:Prime.Eventable.getEventTracing``1(``0)">
<summary>
 Get whether events are being traced.
</summary>
</member>
<member name="M:Prime.Eventable.getEventState``2(System.Guid,``1)">
<summary>
 Get event state from the world.
</summary>
</member>
<member name="M:Prime.Eventable.removeEventState``1(System.Guid,``0)">
<summary>
 Remove event state from the world.
</summary>
</member>
<member name="M:Prime.Eventable.addEventState``2(System.Guid,``0,``1)">
<summary>
 Add event state to the world.
</summary>
</member>
<member name="M:Prime.Eventable.setUnsubscriptions``1(Prime.VmapModule.Vmap{System.Guid,System.Tuple{Prime.AddressModule.Address{System.Object},Prime.Participant}},``0)">
<summary>
 Set event unsubscriptions.
</summary>
</member>
<member name="M:Prime.Eventable.setSubscriptions``1(Prime.VmapModule.Vmap{Prime.AddressModule.Address{System.Object},Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Guid,Prime.Participant,System.Object}}},``0)">
<summary>
 Set event subscriptions.
</summary>
</member>
<member name="M:Prime.Eventable.getUnsubscriptions``1(``0)">
<summary>
 Get event unsubscriptions.
</summary>
</member>
<member name="M:Prime.Eventable.getSubscriptions``1(``0)">
<summary>
 Get event subscriptions.
</summary>
</member>
<member name="M:Prime.Eventable.updateEventSystem``1(Microsoft.FSharp.Core.FSharpFunc{Prime.EventSystemModule.EventSystem{``0},Prime.EventSystemModule.EventSystem{``0}},``0)">
<summary>
 Update the event system in the world.
</summary>
</member>
<member name="M:Prime.Eventable.getEventSystemBy``2(Microsoft.FSharp.Core.FSharpFunc{Prime.EventSystemModule.EventSystem{``1},``0},``1)">
<summary>
 Get the event system as tranformed via &apos;by&apos;.
</summary>
</member>
<member name="M:Prime.Eventable.getEventSystem``1(``0)">
<summary>
 Get the event system.
</summary>
</member>
<member name="P:Prime.Events.Any">
<summary>
 Represents any event.
</summary>
</member>
<member name="M:Prime.Generics.div``3(``0,``1)">
<summary>
 Generic (and sectioned) division.
</summary>
</member>
<member name="M:Prime.Generics.mul``3(``0,``1)">
<summary>
 Generic (and sectioned) multiplication.
</summary>
</member>
<member name="M:Prime.Generics.sub``3(``0,``1)">
<summary>
 Generic (and sectioned) subtraction.
</summary>
</member>
<member name="M:Prime.Generics.add``3(``0,``1)">
<summary>
 Generic (and sectioned) addition.
</summary>
</member>
<member name="M:Prime.Generics.dec``3(``0)">
<summary>
 Generic (and sectioned) decrement.
</summary>
</member>
<member name="M:Prime.Generics.inc``3(``0)">
<summary>
 Generic (and sectioned) increment.
</summary>
</member>
<member name="M:Prime.Generics.append``3(``0,``1)">
<summary>
 The generic monoidal append operation.
</summary>
</member>
<member name="M:Prime.Generics.empty``1">
<summary>
 The generic monoidal empty value.
</summary>
</member>
<member name="M:Prime.Generics.one``1">
<summary>
 The generic one value.
</summary>
</member>
<member name="M:Prime.Generics.zero``1">
<summary>
 The generic zero value.
</summary>
</member>
<member name="M:Prime.HashSet.singleton``1(``0)">
<summary>
 Make a hash set with a single element.
</summary>
</member>
<member name="M:Prime.HashSetExtension.HashSet`1.ForceAdd``1(System.Collections.Generic.HashSet{``0},``0)">
<summary>
 Force the addition of an element, removing the existing one if necessary.
</summary>
</member>
<member name="T:Prime.KeyedCacheModule.KeyedCache`2">
<summary>
 Presents a purely-functional interface to a cached value.
 Works by associating a cached value with a given cache key such that the cached value remains valid when queried
 for using the same cache key (as decided by a simple key comparer function), automatically rebuilding the cached
 value and key (as done with a simple factory function).
</summary>
</member>
<member name="M:Prime.KeyedCacheModule.KeyedCache.make``2(``0,``1)">
 <summary>Make a keyed cache value.</summary>
 <param name="cacheKey">The current key against which to validate the cache.</param>
 <param name="cacheValue">The value associated with the cache key.</param>
</member>
<member name="M:Prime.KeyedCacheModule.KeyedCache.getValue``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``0,``1}},``0,Prime.KeyedCacheModule.KeyedCache{``0,``1})">
 <summary>Get the cached value.</summary>
 <param name="keyEquality">Determines the equality of the key used to consider if the cache is valid.</param>
 <param name="getFreshKeyAndValue">Generates a fresh key and corresponding value to cache.</param>
 <param name="cacheKey">The current key against which to validate the cache.</param>
 <param name="keyedCache">The keyed cache.</param>
</member>
<member name="M:Prime.KeyedCacheModule.KeyedCache.getGlobalCacheMisses">
<summary>
 The number of cache misses that have occured when using this type.
 Useful for performance trouble-shooting in Debug mode.
</summary>
</member>
<member name="M:Prime.KeyedCacheModule.KeyedCache.getGlobalCacheHits">
<summary>
 The number of cache hits that have occured when using this type.
 Useful for performance trouble-shooting in Debug mode.
</summary>
</member>
<member name="P:Prime.LabelNameModule.Module">
<summary>
 Label for module names.
 Needed since we can&apos;t utter something like typeof&lt;MyModule&gt;.
</summary>
</member>
<member name="P:Prime.LabelNameModule.Label">
<summary>
 Along with the LabelName type, is used to elaborate the name of a target without
 using a string literal.

 Usage:
     let fieldName = Label?MyFieldName
</summary>
</member>
<member name="M:Prime.Log.init(Microsoft.FSharp.Core.FSharpOption{System.String})">
<summary>
 Initialize logging.
</summary>
</member>
<member name="M:Prime.Log.traceIf(System.Boolean,System.String)">
<summary>
 Conditional trace message call where condition is eagerly evaluted.
</summary>
</member>
<member name="M:Prime.Log.trace(System.String)">
<summary>
 Log a trace message using Trace.Fail and call to info.
</summary>
</member>
<member name="M:Prime.Log.debugIf(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Boolean},System.String)">
<summary>
 Conditional debug message call where condition is lazily evaluated.
</summary>
</member>
<member name="M:Prime.Log.debug(System.String)">
<summary>
 Log a debug message with Debug.Fail and call to info.
</summary>
</member>
<member name="M:Prime.Log.info(System.String)">
<summary>
 Log a purely informational message using Trace.WriteLine.
</summary>
</member>
<member name="M:Prime.Log.remark(System.String,System.String)">
<summary>
 Log a remark with a custom header using Trace.WriteLine.
</summary>
</member>
<member name="M:Prime.Map.concat``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
<summary>
 Combine the contents of two maps, taking an item from the second map in the case of a key
 conflict.
</summary>
</member>
<member name="M:Prime.Map.objectify``2(``0,``1)">
<summary>
 Convert any map value to an obj.
</summary>
</member>
<member name="M:Prime.Map.toValueListBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpMap{``2,``0})">
<summary>
 Convert a list of a map&apos;s values by a function.
</summary>
</member>
<member name="M:Prime.Map.toValueList``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Get a list of a map&apos;s values.
</summary>
</member>
<member name="M:Prime.Map.toKeyListBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpMap{``0,``2})">
<summary>
 Convert a list of a map&apos;s keys by a function.
</summary>
</member>
<member name="M:Prime.Map.toKeyList``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Get a list of a map&apos;s keys.
</summary>
</member>
<member name="M:Prime.Map.toListBy``3(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1},``2},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Convert a map to a list by a function.
 TODO: Optimize by program fusion.
</summary>
</member>
<member name="M:Prime.Map.ofListBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{``1,``2}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Make a map from a list by a function.
 TODO: Optimize by program fusion.
</summary>
</member>
<member name="M:Prime.Map.toValueSeqBy``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Collections.FSharpMap{System.Tuple{``3,``0},``1})">
<summary>
 Convert a seq of a map&apos;s values by a function.
</summary>
</member>
<member name="M:Prime.Map.toValueSeq``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Get a seq of a map&apos;s values.
</summary>
</member>
<member name="M:Prime.Map.toKeySeqBy``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Collections.FSharpMap{System.Tuple{``0,``3},``1})">
<summary>
 Convert a seq of a map&apos;s keys by a function.
</summary>
</member>
<member name="M:Prime.Map.toKeySeq``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Get a seq of a map&apos;s keys.
</summary>
</member>
<member name="M:Prime.Map.toSeqBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Convert a map to a seq by a function.
 TODO: Optimize by program fusion.
</summary>
</member>
<member name="M:Prime.Map.ofSeqBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{``1,``2}},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Make a map from a seq by a function.
 TODO: Optimize by program fusion.
</summary>
</member>
<member name="M:Prime.Map.addMany``2(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Add multiple values to a map.
</summary>
</member>
<member name="M:Prime.Map.singleton``2(``0,``1)">
<summary>
 Make a singleton map.
</summary>
</member>
<member name="M:Prime.MapOperators.op_AtAt``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
<summary>
 Combine the contents of two maps, taking an item from the second map in case of a key overlap.
</summary>
</member>
<member name="T:Prime.MutantCacheModule.MutantCache`1">
<summary>
 Presents a purely-functional interface to a mutable object / record / whatever.
 If it is not satisfactorily efficient to run a clone operation on the mutant for every get,
 just pass in the id function for make&apos;s cloneMutant arg, but make sure to NEVER mutate the
 returned mutant!
</summary>
</member>
<member name="M:Prime.MutantCacheModule.MutantCache.make``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``0)">
 <summary>Make a mutant cache.</summary>
 <param name="cloneMutant">
 A function to clone the mutant before presenting it to the outside world.
 Feel free to pass id if you can ensure that the presented mutant will never be mutated externally.
 </param>
 <param name="mutant">The mutant (mutable object / record / whatever) to be cached.</param>
</member>
<member name="M:Prime.MutantCacheModule.MutantCache.mutateMutant``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FSharpFunc{``0,``0},Prime.MutantCacheModule.MutantCache{``0})">
 <summary>Mutate the underlying mutant (mutable object / record / whatever).</summary>
 <param name="rebuildMutant">A function that rebuilds the mutant from scratch in case the current underlying mutant is out of date.</param>
 <param name="mutateMutant">A function that mutates the underlying mutant.</param>
 <param name="mutantCache">The mutant cache.</param>
</member>
<member name="M:Prime.MutantCacheModule.MutantCache.getMutant``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},Prime.MutantCacheModule.MutantCache{``0})">
 <summary>Get the underlying mutant (mutable object / record / whatever).</summary>
 <param name="rebuildMutant">A function that rebuilds the mutant from scratch in case the current underlying mutant is out of date.</param>
 <param name="mutantCache">The mutant cache.</param>
</member>
<member name="M:Prime.MutantCacheModule.MutantCache.getGlobalMutantRebuilds">
<summary>
 The number of mutant rebuilds that have occured when using this type.
 Useful for performance trouble-shooting in Debug mode.
</summary>
</member>
<member name="M:Prime.NameModule.Name.make(System.String)">
<summary>
 Make a name from a non-empty string without whitespace.
</summary>
</member>
<member name="M:Prime.NameModule.Name.equals(Prime.NameModule.Name,Prime.NameModule.Name)">
<summary>
 Equate Names.
</summary>
</member>
<member name="M:Prime.NameModule.Name.compare(Prime.NameModule.Name,Prime.NameModule.Name)">
<summary>
 Compare Names.
</summary>
</member>
<member name="T:Prime.NameModule.Name">
<summary>
 A name for optimized keying in hashing containers.
</summary>
</member>
<member name="P:Prime.NameModule.NameModule.empty">
<summary>
 The empty name, consisting of an empty string.
</summary>
</member>
<member name="M:Prime.NameModule.NameModule.hashNames(Microsoft.FSharp.Collections.FSharpList{Prime.NameModule.Name})">
<summary>
 Hash a list of names.
</summary>
</member>
<member name="M:Prime.NameModule.NameModule.compareNames(Microsoft.FSharp.Collections.FSharpList{Prime.NameModule.Name},Microsoft.FSharp.Collections.FSharpList{Prime.NameModule.Name})">
<summary>
 Compare a list of names lexicographically.
</summary>
</member>
<member name="M:Prime.NameModule.NameModule.equateNames(Microsoft.FSharp.Collections.FSharpList{Prime.NameModule.Name},Microsoft.FSharp.Collections.FSharpList{Prime.NameModule.Name})">
<summary>
 Query for equality a list of names lexicographically.
</summary>
</member>
<member name="M:Prime.NameModule.NameModule.split(System.Char[],Prime.NameModule.Name)">
<summary>
 Split a name on a separator char array.
</summary>
</member>
<member name="M:Prime.NameModule.NameModule.join(System.String,System.Collections.Generic.IEnumerable{Prime.NameModule.Name})">
<summary>
 Join a list of names by a separator string.
</summary>
</member>
<member name="M:Prime.NameModule.NameModule.getNameStr(Prime.NameModule.Name)">
<summary>
 Get the name of a name key.
</summary>
</member>
<member name="M:Prime.NameOperators.op_BangBang(System.String)">
<summary>
 Convert a name string to a name.
</summary>
</member>
<member name="M:Prime.Observation.participantValue``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Prime.Observation{Prime.ParticipantChangeData{``2,``0},``3,``0})">
<summary>
 Filter out participant change events that do not relate to those returned by &apos;valueGetter&apos;.
</summary>
</member>
<member name="M:Prime.Observation.distinct``3(Prime.Observation{Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2,``0})">
<summary>
 Filter out the events with non-unique data from an observation.
</summary>
</member>
<member name="M:Prime.Observation.distinctBy``4(Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3}},Prime.Observation{``0,``1,``2})">
<summary>
 Filter out the events with non-unique data as defined by &apos;by&apos; from an observation.
</summary>
</member>
<member name="M:Prime.Observation.min``3(Prime.Observation{``0,``1,``2})">
<summary>
 Transform an observation into a running minimum of it numeric data.
</summary>
</member>
<member name="M:Prime.Observation.max``3(Prime.Observation{``0,``1,``2})">
<summary>
 Transform an observation into a running maximum of it numeric data.
</summary>
</member>
<member name="M:Prime.Observation.choose``3(Prime.Observation{Microsoft.FSharp.Core.FSharpOption{``0},``1,``2})">
<summary>
 Filter out the None data values from an observation and strip the Some constructor from
 the remaining values.
</summary>
</member>
<member name="M:Prime.Observation.search``3(Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,System.Boolean}},Prime.Observation{``0,``1,``2})">
<summary>
 Take only the first event from an observation that satisfies &apos;p&apos;.
</summary>
</member>
<member name="M:Prime.Observation.nth``3(System.Int32,Prime.Observation{``0,``1,``2})">
<summary>
 Take only the nth event from an observation.
</summary>
</member>
<member name="M:Prime.Observation.tail``3(Prime.Observation{``0,``1,``2})">
<summary>
 Skip the first event of an observation.
</summary>
</member>
<member name="M:Prime.Observation.head``3(Prime.Observation{``0,``1,``2})">
<summary>
 Take only the first event from an observation.
</summary>
</member>
<member name="M:Prime.Observation.skip``3(System.Int32,Prime.Observation{``0,``1,``2})">
<summary>
 Skip the first n events in an observation.
</summary>
</member>
<member name="M:Prime.Observation.take``3(System.Int32,Prime.Observation{``0,``1,``2})">
<summary>
 Take only the first n events from an observation.
</summary>
</member>
<member name="M:Prime.Observation.duplicate``3(Prime.Observation{``0,``1,``2})">
<summary>
 Transform an observation by duplicating its data into pairs.
</summary>
</member>
<member name="M:Prime.Observation.withSnd``5(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Prime.Observation{System.Tuple{``2,``0},``3,``4})">
<summary>
 Transform an observation of pairs by a mapping of its snd values.
</summary>
</member>
<member name="M:Prime.Observation.withFst``5(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Prime.Observation{System.Tuple{``0,``2},``3,``4})">
<summary>
 Transform an observation&apos;s pairs by a mapping of its fst values.
</summary>
</member>
<member name="M:Prime.Observation.toSnd``4(Prime.Observation{System.Tuple{``0,``1},``2,``3})">
<summary>
 Transform an observation of pairs into its snd values.
</summary>
</member>
<member name="M:Prime.Observation.toFst``4(Prime.Observation{System.Tuple{``0,``1},``2,``3})">
<summary>
 Transform an observation of pairs into its fst values.
</summary>
</member>
<member name="M:Prime.Observation.productN``3(Prime.Observation{``0,``1,``2})">
<summary>
 Transform an observation into a running product of its data.
</summary>
</member>
<member name="M:Prime.Observation.sumN``3(Prime.Observation{``0,``1,``2})">
<summary>
 Transform an observation into a running sum of its data.
</summary>
</member>
<member name="M:Prime.Observation.group``3(Prime.Observation{``0,``1,``2})">
<summary>
 Transform an observation into a running set of its event&apos;s unique data.
</summary>
</member>
<member name="M:Prime.Observation.groupBy``4(Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3}},Prime.Observation{``0,``1,``2})">
<summary>
 Transform an observation into a running set of its event&apos;s unique data as defined by &apos;by&apos;.
</summary>
</member>
<member name="M:Prime.Observation.organize``4(Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3}},Prime.Observation{``0,``1,``2})">
<summary>
 Transform an observation into a running map from its event&apos;s data to keys as defined by &apos;f&apos;.
</summary>
</member>
<member name="M:Prime.Observation.average``4(Prime.Observation{``0,``2,``3})">
<summary>
 Transform an observation into a running average of its event&apos;s numeric data.
</summary>
</member>
<member name="M:Prime.Observation.scan``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``1,``2},Microsoft.FSharp.Core.FSharpFunc{``3,``0}}},``0,Prime.Observation{``1,``2,``3})">
<summary>
 Scan over an observation, accumulating state.
</summary>
</member>
<member name="M:Prime.Observation.scan2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``0}}},Prime.Observation{``0,``1,``2})">
<summary>
 Scan over an observation, accumulating state.
</summary>
</member>
<member name="M:Prime.Observation.scan4``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``1,``2},Microsoft.FSharp.Core.FSharpFunc{``3,``0}}},Microsoft.FSharp.Core.FSharpFunc{``0,``4},``0,Prime.Observation{``1,``2,``3})">
<summary>
 Scan over an observation, accumulating state.
</summary>
</member>
<member name="M:Prime.Observation.monitor``3(Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{Prime.Handling,``2}}},Prime.Observation{``0,``1,``2},``2)">
<summary>
 Subscribe to an observation until the observer is removed from the world.
</summary>
</member>
<member name="M:Prime.Observation.monitorWithUnsub``3(Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{Prime.Handling,``2}}},Prime.Observation{``0,``1,``2},``2)">
<summary>
 Subscribe to an observation until the observer is removed from the world,
 returning both an unsubscription procedure as well as the world as augmented with said
 subscription.
</summary>
</member>
<member name="M:Prime.Observation.lifetime``3(Prime.Observation{``0,``1,``2})">
<summary>
 Terminate an observation when the observer is removed from the world.
</summary>
</member>
<member name="M:Prime.Observation.until``3(Prime.AddressModule.Address{Microsoft.FSharp.Core.Unit},Prime.Observation{``0,``1,``2})">
<summary>
 Terminate an observation when an event at the given address is raised.
</summary>
</member>
<member name="M:Prime.Observation.subscribe``3(Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{Prime.Handling,``2}}},Prime.Observation{``0,``1,``2},``2)">
<summary>
 Subscribe to an observation, handling each event with the given &apos;handleEvent&apos; procedure.
</summary>
</member>
<member name="M:Prime.Observation.subscribePlus``3(Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{Prime.Handling,``2}}},Prime.Observation{``0,``1,``2},``2)">
<summary>
 Subscribe to an observation, handling each event with the given &apos;handleEvent&apos; procedure,
 returning both an unsubscription procedure as well as the world as augmented with said
 subscription.
</summary>
</member>
<member name="M:Prime.Observation.track``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``0,System.Boolean}}},``0,Prime.Observation{``2,``3,``1})">
<summary>
 TODO: document!
</summary>
</member>
<member name="M:Prime.Observation.track2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``0,System.Boolean}}}},Prime.Observation{``0,``1,``2})">
<summary>
 TODO: document!
</summary>
</member>
<member name="M:Prime.Observation.track4``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``1,``2},Microsoft.FSharp.Core.FSharpFunc{``3,System.Tuple{``0,System.Boolean}}}},Microsoft.FSharp.Core.FSharpFunc{``0,``4},``0,Prime.Observation{``1,``2,``3})">
<summary>
 TODO: document!
</summary>
</member>
<member name="M:Prime.Observation.map``4(Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3}},Prime.Observation{``0,``1,``2})">
<summary>
 Map an observation by the given &apos;mapper&apos; procedure.
</summary>
</member>
<member name="M:Prime.Observation.filter``3(Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,System.Boolean}},Prime.Observation{``0,``1,``2})">
<summary>
 Filter an observation by the given &apos;pred&apos; procedure.
</summary>
</member>
<member name="M:Prime.Observation.sum``4(Prime.AddressModule.Address{``0},Prime.Observation{``1,``2,``3})">
<summary>
 Combine an observation with the events from the given address. Combination is in &apos;sum
 form&apos;, which is defined as an Either of the data of the combined events, where only data
 from the most recent event is available at a time.
 TODO: unit test for this!
</summary>
</member>
<member name="M:Prime.Observation.product``4(Prime.AddressModule.Address{``0},Prime.Observation{``1,``2,``3})">
<summary>
 Combine an observation with the events from the given address. Combination is in &apos;product
 form&apos;, which is defined as a pair of the data of the combined events. Think of it as &apos;zip&apos;
 for event streams.
 TODO: unit test for this!
</summary>
</member>
<member name="M:Prime.Observation.observe``3(Prime.AddressModule.Address{``0},``1)">
<summary>
 Make an observation of an event at the given address.
</summary>
</member>
<member name="M:Prime.ObservationOperators.op_MinusMinusGreater``3(Prime.Observation{``0,``1,``2},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``2,``2}})">
<summary>
 Propagate the event data of an observation to a value in the observing participant when the
 observer exists (doing nothing otherwise).
</summary>
</member>
<member name="M:Prime.ObservationOperators.op_MultiplyMinusMinus``4(``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2},``3)">
<summary>
 Make an observation of the observer&apos;s change events.
</summary>
</member>
<member name="M:Prime.ObservationOperators.op_MinusBarGreater``2">
<summary>
 Pipe-right arrow that provides special precedence for observations.
</summary>
</member>
<member name="M:Prime.Operators.op_EqualsEqualsEquals``1(``0,``0)">
<summary>
 Test just the value parts of a type for equality. Reflective and slow.
</summary>
</member>
<member name="M:Prime.Operators.op_EqualsEquals``1(``0,``0)">
<summary>
 Test for equality, usually faster than (=).
</summary>
</member>
<member name="M:Prime.Operators.op_Concatenate``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0)">
<summary>
 Sequences two functions like Haskell ($).
</summary>
</member>
<member name="M:Prime.Operators.implicit``2(``0)">
<summary>
 As close as we can get to F# implicits.
</summary>
</member>
<member name="M:Prime.Operators.failwithumf``1">
<summary>
 Fail with an unexpected match failure.
</summary>
</member>
<member name="M:Prime.Operators.makeGuidFromInts(System.Int32,System.Int32)">
<summary>
 Make a Guid from a couple of ints.
 It is the user&apos;s responsibility to ensure uniqueness when using the resulting Guids.
</summary>
</member>
<member name="M:Prime.Operators.makeGuid">
<summary>
 Make a Guid.
</summary>
</member>
<member name="M:Prime.Operators.enumerator``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Get the enumerator for a sequence.
</summary>
</member>
<member name="M:Prime.Operators.enumerable``1(System.Collections.IEnumerable)">
<summary>
 Short-hand for linq enumerable cast.
</summary>
</member>
<member name="M:Prime.Operators.assignTypeConverter``2">
<summary>
 Add a custom TypeConverter to an existing type.
</summary>
</member>
<member name="M:Prime.Operators.doUntil(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Boolean})">
<summary>
 Perform an operation until a predicate passes.
</summary>
</member>
<member name="M:Prime.Operators.doTimes``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``0,System.Int32)">
<summary>
 Apply a function recursively a number of times.
</summary>
</member>
<member name="M:Prime.Operators.similar(System.Object,System.Object)">
<summary>
 Test just the value parts of a type for equality.
 NOTE: This function uses mad reflection, so is extremely slow, and should not be used in tight loops.
</summary>
</member>
<member name="M:Prime.Operators.refEq``1(``0,``0)">
<summary>
 Test for reference equality.
</summary>
</member>
<member name="M:Prime.Operators.fastEq``1(``0,``0)">
<summary>
 Test for equality, usually faster than (=).
</summary>
</member>
<member name="M:Prime.Operators.getPropertyValue(System.Object[],System.Reflection.PropertyInfo,System.Object)">
<summary>
 Get the value of a property.
</summary>
</member>
<member name="M:Prime.Operators.getProperties(System.Type)">
<summary>
 Get the properties of a type.
</summary>
</member>
<member name="M:Prime.Operators.getFieldValue(System.Reflection.FieldInfo,System.Object)">
<summary>
 Get the value of a field.
</summary>
</member>
<member name="M:Prime.Operators.getFields(System.Type)">
<summary>
 Get the fields of a type.
</summary>
</member>
<member name="M:Prime.Operators.getTypeName``1(``0)">
<summary>
 Get the .NET type name of a target.
</summary>
</member>
<member name="M:Prime.Operators.getType``1(``0)">
<summary>
 Get the .NET type of a target.
</summary>
</member>
<member name="M:Prime.Operators.strCmp(System.String,System.String)">
<summary>
 Compare two strings.
</summary>
</member>
<member name="M:Prime.Operators.strEq(System.String,System.String)">
<summary>
 Test for string equality.
</summary>
</member>
<member name="M:Prime.Operators.denull``1(``0)">
<summary>
 Convert a nullable value into an option.
</summary>
</member>
<member name="M:Prime.Operators.isNullTrueValue(System.Type)">
<summary>
 Test that the given type has null as an actual value.
</summary>
</member>
<member name="M:Prime.Operators.isNotNull``1(``0)">
<summary>
 Test for non-null.
</summary>
</member>
<member name="M:Prime.Operators.isNull``1(``0)">
<summary>
 Test for null.
</summary>
</member>
<member name="M:Prime.Operators.flip4``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``3,``4}}}},``1,``2,``3,``0)">
<summary>
 Transforms a function by flipping the order of its arguments.
</summary>
</member>
<member name="M:Prime.Operators.flip3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},``1,``2,``0)">
<summary>
 Transforms a function by flipping the order of its arguments.
</summary>
</member>
<member name="M:Prime.Operators.flip``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``1,``0)">
<summary>
 Transforms a function by flipping the order of its arguments.
</summary>
</member>
<member name="M:Prime.Operators.uncurry``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``0,``1)">
<summary>
 Uncurry two values.
</summary>
</member>
<member name="M:Prime.Operators.curry``3(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1},``2},``0,``1)">
<summary>
 Curry up two values.
</summary>
</member>
<member name="M:Prime.Operators.objectify``1(``0)">
<summary>
 Convert any value to an obj.
</summary>
</member>
<member name="M:Prime.Operators.absurdity2``2(``0,``1)">
<summary>
 The absurdity function with two arguments.
 No matter what you pass it, it evaluates to false.
</summary>
</member>
<member name="M:Prime.Operators.absurdity``1(``0)">
<summary>
 The absurdity function.
 No matter what you pass it, it evaluates to false.
</summary>
</member>
<member name="M:Prime.Operators.tautology3``3(``0,``1,``2)">
<summary>
 The tautology function with three arguments.
 No matter what you pass it, it evaluates to true.
</summary>
</member>
<member name="M:Prime.Operators.tautology2``2(``0,``1)">
<summary>
 The tautology function with two arguments.
 No matter what you pass it, it evaluates to true.
</summary>
</member>
<member name="M:Prime.Operators.tautology``1(``0)">
<summary>
 The tautology function.
 No matter what you pass it, it evaluates to true.
</summary>
</member>
<member name="M:Prime.Option.getOrDefault``1(``0,Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Get an option&apos;s value, or missing that, return a default value.
</summary>
</member>
<member name="M:Prime.Option.join``1(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
 Join an option option.
</summary>
</member>
<member name="M:Prime.Pair.sortFstDescending``2(System.Single,``0,System.Single,``1)">
<summary>
 Sort pairs by fst in descending order.
</summary>
</member>
<member name="M:Prime.Pair.make``2(``0,``1)">
<summary>
 Make a pair.
</summary>
</member>
<member name="M:Prime.PairOperators.mapSnd``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2,``0)">
<summary>
 Map over pair member snd.
</summary>
</member>
<member name="M:Prime.PairOperators.mapFst``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0,``2)">
<summary>
 Map over pair member fst.
</summary>
</member>
<member name="M:Prime.PairOperators.withSnd``3(``0,``1,``2)">
<summary>
 Replace pair member snd.
</summary>
</member>
<member name="M:Prime.PairOperators.withFst``3(``0,``1,``2)">
<summary>
 Replace pair member fst.
</summary>
</member>
<member name="M:Prime.Program.runTimings``1(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.String,System.Tuple{System.String,System.String}}[],``0},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.String,System.Tuple{System.String,System.String}}[],Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},System.String)">
<summary>
 Performs some ad-hoc tests to compare performance of maps.
</summary>
</member>
<member name="T:Prime.RandModule.Rand">
<summary>
 An immutable random number generator using the xorshift* algorithm.
</summary>
</member>
<member name="M:Prime.RandModule.RandModule.make">
<summary>
 Make a rand value generator from the default seed state.
</summary>
</member>
<member name="M:Prime.RandModule.RandModule.makeFromInt(System.Int32)">
<summary>
 Make a rand value generator from the given int seed state.
 May not be zero.
</summary>
</member>
<member name="M:Prime.RandModule.RandModule.makeFromSeedState(System.UInt64)">
<summary>
 Make a rand value generator from the given seed state.
 May not be zero.
</summary>
</member>
<member name="M:Prime.RandModule.RandModule.nextInt64Under(System.UInt64,Prime.RandModule.Rand)">
<summary>
 Get the next random value below the given maximum as an int64 type.
</summary>
</member>
<member name="M:Prime.RandModule.RandModule.nextInt64(Prime.RandModule.Rand)">
<summary>
 Get the next random value as an int64 type.
 NOTE: System.Random.Next will never return Int64.MaxValue, but this will.
</summary>
</member>
<member name="M:Prime.RandModule.RandModule.nextIntUnder(System.Int32,Prime.RandModule.Rand)">
<summary>
 Get the next random value below the given maximum as an int type.
</summary>
</member>
<member name="M:Prime.RandModule.RandModule.nextInt(Prime.RandModule.Rand)">
<summary>
 Get the next random value as an int type.
 NOTE: System.Random.Next will never return Int32.MaxValue, but this will.
</summary>
</member>
<member name="M:Prime.RandModule.RandModule.nextSingleUnder(System.Single,Prime.RandModule.Rand)">
<summary>
 Get the next random value below the given maximum as a single type.
</summary>
</member>
<member name="M:Prime.RandModule.RandModule.nextSingle(Prime.RandModule.Rand)">
<summary>
 Get the next random value as a double type.
</summary>
</member>
<member name="M:Prime.RandModule.RandModule.nextDoubleUnder(System.Double,Prime.RandModule.Rand)">
<summary>
 Get the next random value below the given maximum as a double type.
</summary>
</member>
<member name="M:Prime.RandModule.RandModule.nextDouble(Prime.RandModule.Rand)">
<summary>
 Get the next random value as a double type.
</summary>
</member>
<member name="M:Prime.RandModule.RandModule.getState(Prime.RandModule.Rand)">
<summary>
 The internal state of rand, useful for serialization and duplication.
</summary>
</member>
<member name="M:Prime.RandModule.RandModule.advance(Prime.RandModule.Rand)">
<summary>
 Advance the state of rand, thus yielding a new outcome.
</summary>
</member>
<member name="P:Prime.RandModule.RandModule.DefaultSeedState">
<summary>
 The default seed state for rand.
 NOTE: number generated via http://www.random.org/bytes/
</summary>
</member>
<member name="M:Prime.RandModule.RandModule.sample(Prime.RandModule.Rand)">
<summary>
 Get the sample value used to generate the current random value.
</summary>
</member>
<member name="M:Prime.RelationModule.Relation`1.makeFromFullName(Prime.NameModule.Name)">
<summary>
 Make a relation from a &apos;/&apos; delimited string where &apos;.&apos; are empty.
 NOTE: do not move this function as the RelationConverter&apos;s reflection code relies on it being exactly here!
</summary>
</member>
<member name="M:Prime.RelationModule.Relation`1.hash(Prime.RelationModule.Relation{`0})">
<summary>
 Hash a Relation.
</summary>
</member>
<member name="M:Prime.RelationModule.Relation`1.equals``2(Prime.RelationModule.Relation{``0},Prime.RelationModule.Relation{``1})">
<summary>
 Equate Relations.
</summary>
</member>
<member name="T:Prime.RelationModule.Relation`1">
<summary>
 A relation that can be resolved to an address via projection.
</summary>
</member>
<member name="M:Prime.RelationModule.Relation.makeFromFullName``1(Prime.NameModule.Name)">
<summary>
 Make an address from a &apos;/&apos; delimited string.
</summary>
</member>
<member name="M:Prime.RelationModule.Relation.makeFromOptNamesList``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpOption{Prime.NameModule.Name}})">
<summary>
 Make a relation from a list of option names.
</summary>
</member>
<member name="M:Prime.RelationModule.Relation.resolve``1(Prime.AddressModule.Address{``0},Prime.RelationModule.Relation{``0})">
<summary>
 Resolve a relationship to an address.
</summary>
</member>
<member name="M:Prime.String.escape(System.String)">
<summary>
 Expand escaped characters in a string.
</summary>
</member>
<member name="M:Prime.String.unescape(System.String)">
<summary>
 Contract escaped characters in a string.
</summary>
</member>
<member name="M:Prime.String.surround(System.String,System.String)">
<summary>
 Surround a string with another surrounding string.
</summary>
</member>
<member name="M:Prime.String.toArray(System.String)">
<summary>
 Convert a string to an array of characters.
 TODO: optimize this.
</summary>
</member>
<member name="M:Prime.String.withEnd(System.String,System.String)">
<summary>
 Get the string with the given ending.
</summary>
</member>
<member name="M:Prime.String.textualize(System.String)">
<summary>
 Textualize a string for usage as text.
</summary>
</member>
<member name="M:Prime.String.implode(Microsoft.FSharp.Collections.FSharpList{System.Char})">
<summary>
 Converts a list of characters into a string.
</summary>
</member>
<member name="M:Prime.String.explode(System.String)">
<summary>
 Converts a string into a list of characters.
</summary>
</member>
<member name="M:Prime.SymbolIndexModule.prettyPrint(System.String)">
<summary>
 Pretty-print a string in the form an symbolic-expression.
</summary>
</member>
<member name="M:Prime.SymbolIndexModule.fromString(System.String)">
<summary>
 Attempt to a symbol index from a string.
</summary>
</member>
<member name="M:Prime.SymbolModule.tryGetOrigin(Prime.Symbol)">
<summary>
 Try to get the Origin of the symbol if it has one.
</summary>
</member>
<member name="M:Prime.SymbolModule.toString(Prime.Symbol)">
<summary>
 Convert a symbol to a string, with the following unparses:
 
 (* Atom values *)
 None
 CharacterAnimationFacing
 
 (* Number values *)
 0
 -5

 (* String value *)
 &quot;String with quoted spaces.&quot;

 (* Quoted value *)
 `[Some 1]&apos;
 
 (* Symbols values *)
 []
 [Some 0]
 [Left 0]
 [[0 1] [2 4]]
 [AnimationData 4 8]
 [Gem `[Some 1]&apos;]

 ...and so on.
</summary>
</member>
<member name="M:Prime.SymbolModule.fromString(System.String)">
<summary>
 Convert a string to a symbol, with the following parses:
 
 (* Atom values *)
 None
 CharacterAnimationFacing
 
 (* Number values *)
 0
 -5

 (* String value *)
 &quot;String with quoted spaces.&quot;

 (* Quoted value *)
 `[Some 1]&apos;
 
 (* Symbols values *)
 []
 [Some 0]
 [Left 0]
 [[0 1] [2 4]]
 [AnimationData 4 8]
 [Gem `[Some 1]&apos;]

 ...and so on.
</summary>
</member>
<member name="M:Prime.SymbolicDescriptor.convertFrom``1(``0,System.Type)">
<summary>
 Convert a value from given type using its assigned type converter.
</summary>
</member>
<member name="M:Prime.SymbolicDescriptor.convertTo(System.Object,System.Type)">
<summary>
 Convert a value to the given type using its assigned type converter.
</summary>
</member>
<member name="M:Prime.SymbolicDescriptor.canConvertFrom(System.Type,System.Type)">
<summary>
 Query that a value of the destination type can be converted from the source type.
</summary>
</member>
<member name="M:Prime.SymbolicDescriptor.canConvertTo(System.Type,System.Type)">
<summary>
 Query that a value of the source type can be converted to the destination type.
</summary>
</member>
<member name="M:Prime.SymbolicOperators.scvalue``1(System.String)">
<summary>
 Uses a symbolic converter to convert a string to a value.
</summary>
</member>
<member name="M:Prime.SymbolicOperators.scstring``1(``0)">
<summary>
 Uses a symbolic converter to convert a value to a string.
</summary>
</member>
<member name="M:Prime.SymbolicOperators.valueize``1(Prime.Symbol)">
<summary>
 Convert a symbol to a value.
</summary>
</member>
<member name="M:Prime.SymbolicOperators.symbolize``1(``0)">
<summary>
 Convert a value to a symbol.
</summary>
</member>
<member name="M:Prime.Triple.make``3(``0,``1,``2)">
<summary>
 Make a triple.
</summary>
</member>
<member name="M:Prime.Triple.mapC``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2,``3,``0)">
<summary>
 Map over triple member c.
</summary>
</member>
<member name="M:Prime.Triple.mapB``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2,``0,``3)">
<summary>
 Map over triple member b.
</summary>
</member>
<member name="M:Prime.Triple.mapA``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0,``2,``3)">
<summary>
 Map over triple member a.
</summary>
</member>
<member name="M:Prime.Triple.withC``4(``0,``1,``2,``3)">
<summary>
 Replace triple member c.
</summary>
</member>
<member name="M:Prime.Triple.withB``4(``0,``1,``2,``3)">
<summary>
 Replace triple member b.
</summary>
</member>
<member name="M:Prime.Triple.withA``4(``0,``1,``2,``3)">
<summary>
 Replace triple member a.
</summary>
</member>
<member name="M:Prime.Triple.append``3(``0,``1,``2)">
<summary>
 Append an item to a pair to build a triple.
</summary>
</member>
<member name="M:Prime.Triple.insert``3(``0,``1,``2)">
<summary>
 Insert an item in a pair to build a triple.
</summary>
</member>
<member name="M:Prime.Triple.prepend``3(``0,``1,``2)">
<summary>
 Prepend an item to a pair to build a triple.
</summary>
</member>
<member name="M:Prime.Triple.thd``3">
<summary>
 The third item in a triple.
</summary>
</member>
<member name="M:Prime.Triple.snd``3">
<summary>
 The second item in a triple.
</summary>
</member>
<member name="M:Prime.Triple.fst``3">
<summary>
 The first item in a triple.
</summary>
</member>
<member name="M:Prime.TripleOperators._bc``3(``0,``1,``2)">
<summary>
 The second and third items in a triple.
</summary>
</member>
<member name="M:Prime.TripleOperators.a_c``3(``0,``1,``2)">
<summary>
 The first and third items in a triple.
</summary>
</member>
<member name="M:Prime.TripleOperators.ab_``3(``0,``1,``2)">
<summary>
 The first and second items in a triple.
</summary>
</member>
<member name="M:Prime.TripleOperators.__c``3(``0,``1,``2)">
<summary>
 The third item in a triple.
</summary>
</member>
<member name="M:Prime.TripleOperators._b_``3(``0,``1,``2)">
<summary>
 The second item in a triple.
</summary>
</member>
<member name="M:Prime.TripleOperators.a__``3(``0,``1,``2)">
<summary>
 The first item in a triple.
</summary>
</member>
<member name="M:Prime.Type.GetPropertyByPreference``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Get the first property that is signalled to be preferred by the &apos;preference&apos; predicate.
</summary>
</member>
<member name="M:Prime.Type.GetTypeUnqualified(System.String)">
<summary>
 Get an existing type with the given unqualified name. Time-intensive.
</summary>
</member>
<member name="M:Prime.Type.TryGetTypeUnqualified(System.String)">
<summary>
 Try to get an existing type with the given unqualified name. Time-intensive.
</summary>
</member>
<member name="M:Prime.TypeExtension.Type.GetPropertiesPreferWritable(System.Type)">
<summary>
 Get all the properties, preferring those that can be written to if there is a name clash.
</summary>
</member>
<member name="M:Prime.TypeExtension.Type.GetPropertiesByPreference(System.Type,Microsoft.FSharp.Core.FSharpFunc{System.Reflection.PropertyInfo,System.Boolean})">
<summary>
 Get all the properties that are signalled to be preferred by the &apos;preference&apos; predicate.
</summary>
</member>
<member name="M:Prime.TypeExtension.Type.GetPropertyPreferWritable(System.Type,System.Reflection.BindingFlags)">
<summary>
 Get the property with the given name, preferring the variant that can be written to, or null if none found.
</summary>
</member>
<member name="M:Prime.TypeExtension.Type.GetPropertyByPreference(System.Type,Microsoft.FSharp.Core.FSharpFunc{System.Reflection.PropertyInfo,System.Boolean},System.Reflection.BindingFlags)">
<summary>
 Get the first property with the given name that is signalled to be preferred by the &apos;preference&apos; predicate.
</summary>
</member>
<member name="M:Prime.TypeExtension.Type.GetPropertiesWritable(System.Type,System.String)">
<summary>
 Get all the properties with the give name that can be written to.
</summary>
</member>
<member name="M:Prime.TypeExtension.Type.GetPropertiesWritable(System.Type)">
<summary>
 Get all the properties that can be written to.
</summary>
</member>
<member name="M:Prime.TypeExtension.Type.GetProperties(System.Type,System.String)">
<summary>
 Get all the properties with the given name.
</summary>
</member>
<member name="M:Prime.TypeExtension.Type.GetPropertyWritable(System.Type,System.String)">
<summary>
 Get a property with the given name that can be written to, or null.
</summary>
</member>
<member name="M:Prime.TypeExtension.Type.TryGetCustomTypeConverter(System.Type)">
<summary>
 Try to get a custom type converter for the given type.
</summary>
</member>
<member name="M:Prime.TypeExtension.Type.GetTypeDescriptor(System.Type)">
<summary>
 Get the type descriptor for this type as returned by the global TypeDescriptor.
</summary>
</member>
<member name="M:Prime.TypeExtension.Type.GetDefaultValue(System.Type)">
<summary>
 Get the default value for a type.
 Never returns null.
</summary>
</member>
<member name="T:Prime.VmapModule.Vmap`2">
<summary>
 A very fast persistent hash map.
 Works in effectively constant-time for look-ups and updates.
</summary>
</member>
<member name="M:Prime.VmapModule.Vmap.ofSeq``2(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}})">
<summary>
 Convert a sequence of keys and values to a Vmap.
</summary>
</member>
<member name="M:Prime.VmapModule.Vmap.toSeq``2(Prime.VmapModule.Vmap{``0,``1})">
<summary>
 Convert a Vmap to a sequence of pairs of keys and values.
 NOTE: This function seems to profile as being very slow. I don&apos;t know if it&apos;s the seq / yields syntax or what.
 Don&apos;t use it unless you need its laziness or if performance won&apos;t be affected significantly.
</summary>
</member>
<member name="M:Prime.VmapModule.Vmap.filter``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},Prime.VmapModule.Vmap{``0,``1})">
<summary>
 Filter a Vmap.
</summary>
</member>
<member name="M:Prime.VmapModule.Vmap.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Prime.VmapModule.Vmap{``2,``0})">
<summary>
 Map over a Vmap.
</summary>
</member>
<member name="M:Prime.VmapModule.Vmap.fold``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``0}}},``0,Prime.VmapModule.Vmap{``1,``2})">
<summary>
 Fold over a Vmap.
</summary>
</member>
<member name="M:Prime.VmapModule.Vmap.concat``2(Prime.VmapModule.Vmap{``0,``1},System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}})">
<summary>
 Combine the contents of two Vmaps, taking an item from the second map in the case of a key conflict.
</summary>
</member>
<member name="M:Prime.VmapModule.Vmap.containsKey``2(``0,Prime.VmapModule.Vmap{``0,``1})">
<summary>
 Query that a Vmap contains a value with the given key.
</summary>
</member>
<member name="M:Prime.VmapModule.Vmap.find``2(``0,Prime.VmapModule.Vmap{``0,``1})">
<summary>
 Find a value with the given key in a Vmap.
 Constant-time complexity with approx. 1/3 speed of Dictionary.GetValue.
</summary>
</member>
<member name="M:Prime.VmapModule.Vmap.tryFind``2(``0,Prime.VmapModule.Vmap{``0,``1})">
<summary>
 Try to find a value with the given key in a Vmap.
 Constant-time complexity with approx. 1/3 speed of Dictionary.TryGetValue.
</summary>
</member>
<member name="M:Prime.VmapModule.Vmap.removeMany``2(System.Collections.Generic.IEnumerable{``0},Prime.VmapModule.Vmap{``0,``1})">
<summary>
 Remove all values with the given keys from a Vmap.
</summary>
</member>
<member name="M:Prime.VmapModule.Vmap.remove``2(``0,Prime.VmapModule.Vmap{``0,``1})">
<summary>
 Remove a value with the given key from a Vmap.
</summary>
</member>
<member name="M:Prime.VmapModule.Vmap.addMany``2(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}},Prime.VmapModule.Vmap{``0,``1})">
<summary>
 Add a list of values with associated keys to a Vmap.
</summary>
</member>
<member name="M:Prime.VmapModule.Vmap.add``2(``0,``1,Prime.VmapModule.Vmap{``0,``1})">
<summary>
 Add a value with the key to a Vmap.
</summary>
</member>
<member name="M:Prime.VmapModule.Vmap.isEmpty``2(Prime.VmapModule.Vmap{``0,``1})">
<summary>
 Query that a Vmap is empty.
</summary>
</member>
<member name="M:Prime.VmapModule.Vmap.makeEmpty``2">
<summary>
 Create an empty Vmap.
</summary>
</member>
<member name="T:Prime.VnodeModule.Vnode`2">
<summary>
 TODO: there&apos;s an F# issue where UseNullAsTrueValue does not work on unions with 4 or more cases
 https://github.com/Microsoft/visualfsharp/issues/711 . Once resolved, should use it and be able
 to make arrays with Array.zeroCreate alone without also copying over the empty array.
</summary>
</member>
<member name="M:Prime.VnodeModule.Vnode.add``2(Prime.Hkv{``0,``1},Prime.VnodeModule.Vnode{``0,``1}[],System.Int32,Prime.VnodeModule.Vnode{``0,``1})">
<summary>
 OPTIMIZATION: Requires an empty array to use the source of new array clones in order to avoid Array.create.
</summary>
</member>
<member name="M:Prime.VnodeModule.Vnode.toSeq``2(Prime.VnodeModule.Vnode{``0,``1})">
<summary>
 NOTE: This function seems to profile as being very slow. I don&apos;t know if it&apos;s the seq / yields syntax or what.
</summary>
</member>
<member name="M:Prime.VnodeModule.Vnode.cloneArray``2(Prime.VnodeModule.Vnode{``0,``1}[])">
<summary>
 OPTIMIZATION: Array.Clone () is not used since it&apos;s been profiled to be slower
</summary>
</member>
<member name="P:Prime.VsyncBuilderModule.vsync">
<summary>
 The VsyncBuilder instance.
 Used like: vsync { return 0 }
</summary>
</member>
<member name="T:Prime.VsyncModule.Vsync`1">
<summary>
 The &apos;Vsync&apos; (AKA, &apos;Variable Synchrony&apos;) monad.
 Allows code to run in either an async or synchronous fashion to aid in debugging.
 NOTE: to reference how all this stuff works in F#, see here - https://msdn.microsoft.com/en-us/library/dd233182.aspx
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Prime.VsyncModule.Vsync{``0})">
<summary>
 Creates a potentially asynchronous operation that runs &apos;f&apos; over computation of &apos;a&apos;.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.Parallel``1(System.Collections.Generic.IEnumerable{Prime.VsyncModule.Vsync{``0}})">
<summary>
 Creates a potentially asynchronous computation that executes all the given computations
 Initially queues each as work item using a fork/join pattern when asynchronous.
 Executes each work item sequentially on the same thread otherwise.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.Catch``1(Prime.VsyncModule.Vsync{``0})">
<summary>
 Creates a potentially asynchronous computation that executes computation.
 If this computation completes successfully, then return Choice1Of2 with the returned value.
 If this computation raises before completion, then return Choice2Of2 with the raised exception.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.AwaitTask(System.Threading.Tasks.Task)">
<summary>
 Return a potentially asynchronous computation that will wait for the given task to complete and return its result.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.AwaitTaskT``1(System.Threading.Tasks.Task{``0})">
<summary>
 Return a potentially asynchronous computation that will wait for the given task to complete and return its result.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.StartAsTask``1(Prime.VsyncModule.Vsync{``0})">
<summary>
 Executes a computation in the thread pool when asynchronous, in the same thread otherwise.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.Start(Prime.VsyncModule.Vsync{Microsoft.FSharp.Core.Unit})">
<summary>
 Starts the potentially asynchronous computation.
 Computation is run in the thread pool not awaiting its result when asynchronous.
 Computation is run in the current thread awaiting its result otherwise.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.RunSynchronously``1(Prime.VsyncModule.Vsync{``0})">
<summary>
 Runs the potentially asynchronous computation and awaits its result.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.Sleep(System.Int32)">
<summary>
 Creates a potentially asynchronous computation that will sleep for the given time.
 The operation will not block operating system threads for the duration of the wait when running asynchronously.
 The operation will block operating system thread for the duration of the wait otherwise.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.Ignore``1(Prime.VsyncModule.Vsync{``0})">
<summary>
 Creates a potentially asynchronous computation that runs the given computation and ignores its results.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.TryFinally``1(Prime.VsyncModule.Vsync{``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Creates a potentially asynchronous computation that runs computation.
 The action compensation &apos;h&apos; is executed after the computation completes regardless of the outcome.
 If the computation raises and exception itself, the original exception is discarded and the new exception becomes the overall result.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.TryWith``1(Prime.VsyncModule.Vsync{``0},Microsoft.FSharp.Core.FSharpFunc{System.Exception,Prime.VsyncModule.Vsync{``0}})">
<summary>
 Creates a potentially asynchronous computation that runs computation and returns its result.
 If an exception happens, then handler &apos;h&apos; is called and the resulting computation executes instead.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.While(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Boolean},Prime.VsyncModule.Vsync{Microsoft.FSharp.Core.Unit})">
<summary>
 Creates a potentially asynchronous computation that runs computation until guard &apos;g&apos; becomes false.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.For``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Prime.VsyncModule.Vsync{Microsoft.FSharp.Core.Unit}})">
<summary>
 Creates a potentially asynchronous computation that enumerates the sequence &apos;s&apos;, and runs the body &apos;f&apos; for each element.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.Combine``1(Prime.VsyncModule.Vsync{Microsoft.FSharp.Core.Unit},Prime.VsyncModule.Vsync{``0})">
<summary>
 Creates a potentially asynchronous computation that first runs computation &apos;a&apos; and then computation &apos;b&apos;, returning the result of the latter.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.Zero">
<summary>
 Creates a potentially asynchronous computation that just returns unit.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.Delay``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Prime.VsyncModule.Vsync{``0}})">
<summary>
 Creates a potentially asynchronous computation that runs generator &apos;f&apos;.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.Using``2(``0,Microsoft.FSharp.Core.FSharpFunc{``0,Prime.VsyncModule.Vsync{``1}})">
<summary>
 Creates a potentially asynchronous computation that runs binder &apos;f&apos; over resource &apos;d&apos;.
 Dispose is executed as this computation yields its result or if the asynchronous computation raises or by cancellation.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.ReturnFrom``1(Prime.VsyncModule.Vsync{``0})">
<summary>
 Delegates to input computation.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.Return``1(``0)">
<summary>
 Creates a potentially asynchronous operation that returns the result &apos;a&apos;.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.Bind``2(Prime.VsyncModule.Vsync{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Prime.VsyncModule.Vsync{``1}})">
<summary>
 Creates a potentially asynchronous operation that runs computation, and when computation results, runs binder resolution.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.isSync">
<summary>
 Query whether Vsync is using synchronized or asynchronous processing.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.init(System.Boolean)">
<summary>
 Initialize Vsync to use synchronized or asynchronous processing.
</summary>
</member>
<member name="P:Prime.VsyncModule.Vsync.OptSync">
<summary>
 Configures whether to use synchronized processing.
</summary>
</member>
<member name="M:Prime.XtensionModule.Xtension.tryGetDefaultValue``1(Prime.XtensionModule.Xtension,System.String)">
<summary>
 Try to get the default value for a given xtension member, returning None when defaulting is disallowed.
</summary>
</member>
<member name="M:Prime.XtensionModule.Xtension.op_DynamicAssignment``1(Prime.XtensionModule.Xtension,System.String,``0)">
<summary>
 The dynamic assignment operator for an Xtension.
 Example:
     let entity = entity.Position &lt;- Vector2 (4.0, 5.0).
</summary>
</member>
<member name="M:Prime.XtensionModule.Xtension.op_Dynamic``1(Prime.XtensionModule.Xtension,System.String)">
<summary>
 The dynamic look-up operator for an Xtension.
 Example:
     let parallax = entity?Parallax : single
</summary>
</member>
<member name="M:Prime.XtensionModule.Xtension.getDefaultValue``1">
<summary>
 Get the default value of an instance of type &apos;r taking into account XDefaultValue decorations.
</summary>
</member>
<member name="T:Prime.XtensionModule.Xtension">
<summary>
 Xtensions (and their supporting types) are a dynamic, functional, and semi-convenient way
 to implement dynamic properties.
</summary>
</member>
<member name="M:Prime.XtensionModule.XtensionModule.ofSeq(System.Collections.Generic.IEnumerable{System.Tuple{System.String,Prime.XProperty}})">
<summary>
 Convert an xtension to a sequence of its entries.
</summary>
</member>
<member name="M:Prime.XtensionModule.XtensionModule.toSeq(Prime.XtensionModule.Xtension)">
<summary>
 Convert an xtension to a sequence of its entries.
</summary>
</member>
<member name="M:Prime.XtensionModule.XtensionModule.detachProperties(System.Collections.Generic.IEnumerable{System.String},Prime.XtensionModule.Xtension)">
<summary>
 Detach multiple properties from an Xtension.
</summary>
</member>
<member name="M:Prime.XtensionModule.XtensionModule.detachProperty(System.String,Prime.XtensionModule.Xtension)">
<summary>
 Detach a property from an Xtension.
</summary>
</member>
<member name="M:Prime.XtensionModule.XtensionModule.attachProperties(System.Collections.Generic.IEnumerable{System.Tuple{System.String,Prime.XProperty}},Prime.XtensionModule.Xtension)">
<summary>
 Attach multiple properties to an Xtension.
</summary>
</member>
<member name="M:Prime.XtensionModule.XtensionModule.attachProperty(System.String,Prime.XProperty,Prime.XtensionModule.Xtension)">
<summary>
 Attach a property to an Xtension.
</summary>
</member>
<member name="M:Prime.XtensionModule.XtensionModule.tryGetProperty(System.String,Prime.XtensionModule.Xtension)">
<summary>
 Try to get a property from an xtension.
</summary>
</member>
<member name="M:Prime.XtensionModule.XtensionModule.getProperty(System.String,Prime.XtensionModule.Xtension)">
<summary>
 Get a property from an xtension.
</summary>
</member>
<member name="P:Prime.XtensionModule.XtensionModule.mixed">
<summary>
 An Xtension that cannot default and isn&apos;t sealed.
</summary>
</member>
<member name="P:Prime.XtensionModule.XtensionModule.safe">
<summary>
 An Xtension that cannot default and is sealed.
</summary>
</member>
<member name="P:Prime.XtensionModule.XtensionModule.empty">
<summary>
 An Xtension that can default and isn&apos;t sealed.
</summary>
</member>
<member name="M:Prime.XtensionModule.XtensionModule.make(Prime.VmapModule.Vmap{System.String,Prime.XProperty},System.Boolean,System.Boolean)">
<summary>
 Make an extension with custom safety.
</summary>
</member>
<member name="M:Seq.notExists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Check that a predicate passes for NO items in a sequence.
</summary>
</member>
<member name="M:Seq.foldWhile``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``0}}},``0,System.Collections.Generic.IEnumerable{``1})">
<summary>
 Implement a fold while folder results in Some.
</summary>
</member>
<member name="M:Seq.project``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
 Project the first sequence onto the second.
</summary>
</member>
<member name="M:Seq.tryTake``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
<summary>
 A more tolerant and open-minded take.
</summary>
</member>
<member name="M:Seq.fornone``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Check if no elements satisfy a predicate in a seq.
</summary>
</member>
<member name="M:Seq.foldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},System.Collections.Generic.IEnumerable{``0},``1)">
<summary>
 Fold-back for seqs.
</summary>
</member>
<member name="M:Seq.foldi``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}},``0,System.Collections.Generic.IEnumerable{``1})">
<summary>
 Fold, now with a counter!
</summary>
</member>
<member name="M:Seq.fold2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``0}}},``0,System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2})">
<summary>
 Fold with two inputs (plus state).
</summary>
</member>
<member name="M:Seq.definitize``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
 Convert option values to definite values.
</summary>
</member>
<member name="M:Seq.headOrDefault``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Get a seq head or a default value if there is none.
</summary>
</member>
<member name="M:Seq.tryHead``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Get Some head of the seq or None.
</summary>
</member>
<member name="M:Set.addMany``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Collections.FSharpSet{``0})">
<summary>
 Add multiple values to a set.
</summary>
</member>
<member name="M:Set.singleton``1(``0)">
<summary>
 Make a singleton set.
</summary>
</member>
</members>
</doc>
