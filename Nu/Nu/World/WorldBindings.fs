// Nu Game Engine.
// Copyright (C) Bryan Edds, 2013-2023.

//*********************************************************************************************//
//                                                                                             //
// NOTE: This code is GENERATED by 'GenerateWorldBindings.fsx'! Do NOT edit this code by hand! //
//                                                                                             //
//*********************************************************************************************//

namespace Nu
open System
open System.Numerics
open Prime
open Nu
open Nu.Particles

[<RequireQualifiedAccess>]
module WorldBindings =

    let [<Literal>] BindingKeywords =
        "v2 v3 v4 v2i v3i v4i quat color get getAsStream set setAsStream update streamEvent stream bind self game toData monitor " +
        "resolve relate selectScreen tryGetIsSelectedScreenIdling tryGetIsSelectedScreenTransitioning " +
        "isSelectedScreenIdling isSelectedScreenTransitioning tryTransitionScreen transitionScreen " +
        "setScreenSlide createDissolveScreenFromGroupFile6 createDissolveScreenFromGroupFile createSlideScreen6 " +
        "createSlideScreen reloadExistingAssets tryReloadAssets getCurrentSongOpt " +
        "getCurrentSongPosition getMasterAudioVolume getMasterSoundVolume getMasterSongVolume " +
        "setMasterAudioVolume setMasterSoundVolume setMasterSongVolume playSong playSound fadeOutSong " +
        "stopSong loadAudioPackage unloadAudioPackage reloadAudioAssets " +
        "loadRenderPackage2d unloadRenderPackage2d reloadRenderAssets2d reloadRenderAssets3d " +
        "localizeBodyShape getBodyExists getBodyContactNormals getBodyLinearVelocity " +
        "getBodyToGroundContactNormals getBodyToGroundContactNormalOpt getBodyToGroundContactTangentOpt isBodyOnGround " +
        "createBody createBodies destroyBody destroyBodies " +
        "createJoint createJoints destroyJoint destroyJoints " +
        "setBodyEnabled setBodyCenter setBodyRotation setBodyLinearVelocity " +
        "applyBodyLinearImpulse setBodyAngularVelocity applyBodyAngularImpulse applyBodyForce " +
        "applyBodyTorque setBodyObservable isMouseButtonDown getMousePosition " +
        "getMousePosition2dScreen getMousePostion2dWorld getMousePosition3dScreen getMouseRay3dWorld " +
        "isKeyboardKeyDown isKeyboardKeyUp isKeyboardAltDown isKeyboardAltUp " +
        "isKeyboardCtrlDown isKeyboardCtrlUp isKeyboardShiftDown isKeyboardShiftUp " +
        "destroyImmediate destroy tryGetParent getParent " +
        "getChildren getExists isSelected getEntities0 " +
        "getGroups0 writeGameToFile readGameFromFile getScreens " +
        "setScreenDissolve destroyScreen createScreen createDissolveScreen " +
        "writeScreenToFile readScreenFromFile getGroups createGroup " +
        "destroyGroup destroyGroups writeGroupToFile readGroupFromFile " +
        "getEntitiesFlattened getEntitiesSovereign destroyEntity " +
        "destroyEntities tryPickEntity2d tryPickEntity3d writeEntityToFile " +
        "readEntityFromFile createEntity renameEntity trySetEntityOverlayNameOpt " +
        "trySetEntityFacetNames getEyeCenter2d setEyeCenter2d getEyeSize2d " +
        "setEyeSize2d getEyeBounds2d getEyeCenter3d setEyeCenter3d " +
        "getEyeRotation3d setEyeRotation3d getEyeFrustum3dEnclosed getEyeFrustum3dExposed " +
        "getEyeFrustum3dImposter getLightBox3d getOmniScreenOpt setOmniScreenOpt " +
        "getOmniScreen setOmniScreen constrainEyeBounds2d getSelectedScreenOpt " +
        "getSelectedScreen setSelectedScreen getDesiredScreen setDesiredScreen " +
        "getScreenTransitionDestinationOpt setScreenTransitionDestinationOpt getViewBounds2dAbsolute getPlayBounds2dAbsolute " +
        "getViewBounds2d getPlayBounds2d isBoundsInView2d getPlayBounds3d " +
        "isBoundsInView3d isBoundsInPlay3d tryGetTextureSize getTextureSize " +
        "tryGetTextureSizeF getTextureSizeF getImperative getAccompanied " +
        "getUnaccompanied getCollectionConfig getLiveness setAdvancing " +
        "getAdvancing getHalted getUpdateTime getClockDelta " +
        "getClockTime getGameDelta getGameTime exit " +
        "tryGetWindowFlags tryGetWindowMinimized tryGetWindowMaximized tryGetWindowFullScreen " +
        "trySetWindowFullScreen tryGetWindowSize getWindowSize getViewport " +
        "getViewportOffset tryLoadSymbolPackage unloadSymbolPackage tryGetSymbol " +
        "tryGetSymbols reloadSymbols getOverlays tryGetRoutedOverlayNameOpt " +
        "getEventFilter setEventFilter trySetEditMode tryMakeEmitter"

    let resolve relation world =
        let oldWorld = world
        try
            let relation =
                match ScriptingSystem.tryExport typeof<Relation<Object>> relation world with
                | Some value -> value :?> Relation<Object>
                | None -> failwith "Invalid argument type for 'relation'; expecting a value convertable to Relation`1."
            let result = World.resolveViaScript relation world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Address<Object>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'resolve' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let relate address world =
        let oldWorld = world
        try
            let struct (address, world) =
                let context = World.getScriptContext world
                match World.evalInternal address world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Address must be either a String or Keyword."
            let result = World.relateViaScript address world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Relation<Object>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'relate' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let selectScreen transitionState screen world =
        let oldWorld = world
        try
            let transitionState =
                match ScriptingSystem.tryExport typeof<TransitionState> transitionState world with
                | Some value -> value :?> TransitionState
                | None -> failwith "Invalid argument type for 'transitionState'; expecting a value convertable to TransitionState."
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.selectScreen transitionState screen world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'selectScreen' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let tryGetIsSelectedScreenIdling world =
        let oldWorld = world
        try
            let result = World.tryGetIsSelectedScreenIdling world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Boolean>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryGetIsSelectedScreenIdling' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let tryGetIsSelectedScreenTransitioning world =
        let oldWorld = world
        try
            let result = World.tryGetIsSelectedScreenTransitioning world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Boolean>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryGetIsSelectedScreenTransitioning' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let isSelectedScreenIdling world =
        let oldWorld = world
        try
            let result = World.isSelectedScreenIdling world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isSelectedScreenIdling' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let isSelectedScreenTransitioning world =
        let oldWorld = world
        try
            let result = World.isSelectedScreenTransitioning world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isSelectedScreenTransitioning' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let tryTransitionScreen destination world =
        let oldWorld = world
        try
            let struct (destination, world) =
                let context = World.getScriptContext world
                match World.evalInternal destination world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.tryTransitionScreen destination world
            let (value, world) = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryTransitionScreen' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let transitionScreen destination world =
        let oldWorld = world
        try
            let struct (destination, world) =
                let context = World.getScriptContext world
                match World.evalInternal destination world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.transitionScreen destination world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'transitionScreen' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let setScreenSlide slideDescriptor destination screen world =
        let oldWorld = world
        try
            let slideDescriptor =
                match ScriptingSystem.tryExport typeof<SlideDescriptor> slideDescriptor world with
                | Some value -> value :?> SlideDescriptor
                | None -> failwith "Invalid argument type for 'slideDescriptor'; expecting a value convertable to SlideDescriptor."
            let struct (destination, world) =
                let context = World.getScriptContext world
                match World.evalInternal destination world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.setScreenSlide slideDescriptor destination screen world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setScreenSlide' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let createDissolveScreenFromGroupFile6 dispatcherName nameOpt dissolveDescriptor songOpt groupFilePath world =
        let oldWorld = world
        try
            let dispatcherName =
                match ScriptingSystem.tryExport typeof<String> dispatcherName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'dispatcherName'; expecting a value convertable to String."
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let dissolveDescriptor =
                match ScriptingSystem.tryExport typeof<DissolveDescriptor> dissolveDescriptor world with
                | Some value -> value :?> DissolveDescriptor
                | None -> failwith "Invalid argument type for 'dissolveDescriptor'; expecting a value convertable to DissolveDescriptor."
            let songOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<SongDescriptor>> songOpt world with
                | Some value -> value :?> FSharpOption<SongDescriptor>
                | None -> failwith "Invalid argument type for 'songOpt'; expecting a value convertable to FSharpOption`1."
            let groupFilePath =
                match ScriptingSystem.tryExport typeof<String> groupFilePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'groupFilePath'; expecting a value convertable to String."
            let result = World.createDissolveScreenFromGroupFile6 dispatcherName nameOpt dissolveDescriptor songOpt groupFilePath world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createDissolveScreenFromGroupFile6' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let createDissolveScreenFromGroupFile nameOpt dissolveDescriptor songOpt groupFilePath world =
        let oldWorld = world
        try
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let dissolveDescriptor =
                match ScriptingSystem.tryExport typeof<DissolveDescriptor> dissolveDescriptor world with
                | Some value -> value :?> DissolveDescriptor
                | None -> failwith "Invalid argument type for 'dissolveDescriptor'; expecting a value convertable to DissolveDescriptor."
            let songOpt =
                match ScriptingSystem.tryExport typeof<String> songOpt world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'songOpt'; expecting a value convertable to String."
            let groupFilePath =
                match ScriptingSystem.tryExport typeof<FSharpOption<SongDescriptor>> groupFilePath world with
                | Some value -> value :?> FSharpOption<SongDescriptor>
                | None -> failwith "Invalid argument type for 'groupFilePath'; expecting a value convertable to FSharpOption`1."
            let result = World.createDissolveScreenFromGroupFile nameOpt dissolveDescriptor songOpt groupFilePath world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createDissolveScreenFromGroupFile' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let createSlideScreen6 dispatcherName nameOpt slideDescriptor destination world =
        let oldWorld = world
        try
            let dispatcherName =
                match ScriptingSystem.tryExport typeof<String> dispatcherName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'dispatcherName'; expecting a value convertable to String."
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let slideDescriptor =
                match ScriptingSystem.tryExport typeof<SlideDescriptor> slideDescriptor world with
                | Some value -> value :?> SlideDescriptor
                | None -> failwith "Invalid argument type for 'slideDescriptor'; expecting a value convertable to SlideDescriptor."
            let struct (destination, world) =
                let context = World.getScriptContext world
                match World.evalInternal destination world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.createSlideScreen6 dispatcherName nameOpt slideDescriptor destination world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createSlideScreen6' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let createSlideScreen nameOpt slideDescriptor destination world =
        let oldWorld = world
        try
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let slideDescriptor =
                match ScriptingSystem.tryExport typeof<SlideDescriptor> slideDescriptor world with
                | Some value -> value :?> SlideDescriptor
                | None -> failwith "Invalid argument type for 'slideDescriptor'; expecting a value convertable to SlideDescriptor."
            let struct (destination, world) =
                let context = World.getScriptContext world
                match World.evalInternal destination world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.createSlideScreen nameOpt slideDescriptor destination world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createSlideScreen' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let reloadExistingAssets world =
        let oldWorld = world
        try
            let result = World.reloadExistingAssets world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'reloadExistingAssets' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let tryReloadAssets world =
        let oldWorld = world
        try
            let result = World.tryReloadAssets world
            let (value, world) = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryReloadAssets' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getCurrentSongOpt world =
        let oldWorld = world
        try
            let result = World.getCurrentSongOpt world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<SongDescriptor>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getCurrentSongOpt' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getCurrentSongPosition world =
        let oldWorld = world
        try
            let result = World.getCurrentSongPosition world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Double> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getCurrentSongPosition' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getMasterAudioVolume world =
        let oldWorld = world
        try
            let result = World.getMasterAudioVolume world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Single> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getMasterAudioVolume' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getMasterSoundVolume world =
        let oldWorld = world
        try
            let result = World.getMasterSoundVolume world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Single> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getMasterSoundVolume' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getMasterSongVolume world =
        let oldWorld = world
        try
            let result = World.getMasterSongVolume world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Single> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getMasterSongVolume' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let setMasterAudioVolume volume world =
        let oldWorld = world
        try
            let volume =
                match ScriptingSystem.tryExport typeof<Single> volume world with
                | Some value -> value :?> Single
                | None -> failwith "Invalid argument type for 'volume'; expecting a value convertable to Single."
            let result = World.setMasterAudioVolume volume world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setMasterAudioVolume' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let setMasterSoundVolume volume world =
        let oldWorld = world
        try
            let volume =
                match ScriptingSystem.tryExport typeof<Single> volume world with
                | Some value -> value :?> Single
                | None -> failwith "Invalid argument type for 'volume'; expecting a value convertable to Single."
            let result = World.setMasterSoundVolume volume world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setMasterSoundVolume' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let setMasterSongVolume volume world =
        let oldWorld = world
        try
            let volume =
                match ScriptingSystem.tryExport typeof<Single> volume world with
                | Some value -> value :?> Single
                | None -> failwith "Invalid argument type for 'volume'; expecting a value convertable to Single."
            let result = World.setMasterSongVolume volume world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setMasterSongVolume' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let playSong fadeInTime fadeOutTime startTime volume song world =
        let oldWorld = world
        try
            let fadeInTime =
                match ScriptingSystem.tryExport typeof<GameTime> fadeInTime world with
                | Some value -> value :?> GameTime
                | None -> failwith "Invalid argument type for 'fadeInTime'; expecting a value convertable to GameTime."
            let fadeOutTime =
                match ScriptingSystem.tryExport typeof<GameTime> fadeOutTime world with
                | Some value -> value :?> GameTime
                | None -> failwith "Invalid argument type for 'fadeOutTime'; expecting a value convertable to GameTime."
            let startTime =
                match ScriptingSystem.tryExport typeof<GameTime> startTime world with
                | Some value -> value :?> GameTime
                | None -> failwith "Invalid argument type for 'startTime'; expecting a value convertable to GameTime."
            let volume =
                match ScriptingSystem.tryExport typeof<Single> volume world with
                | Some value -> value :?> Single
                | None -> failwith "Invalid argument type for 'volume'; expecting a value convertable to Single."
            let song =
                match ScriptingSystem.tryExport typeof<AssetTag<Song>> song world with
                | Some value -> value :?> AssetTag<Song>
                | None -> failwith "Invalid argument type for 'song'; expecting a value convertable to AssetTag`1."
            let result = World.playSong fadeInTime fadeOutTime startTime volume song world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'playSong' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let playSound volume sound world =
        let oldWorld = world
        try
            let volume =
                match ScriptingSystem.tryExport typeof<Single> volume world with
                | Some value -> value :?> Single
                | None -> failwith "Invalid argument type for 'volume'; expecting a value convertable to Single."
            let sound =
                match ScriptingSystem.tryExport typeof<AssetTag<Sound>> sound world with
                | Some value -> value :?> AssetTag<Sound>
                | None -> failwith "Invalid argument type for 'sound'; expecting a value convertable to AssetTag`1."
            let result = World.playSound volume sound world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'playSound' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let fadeOutSong fadeOutTime world =
        let oldWorld = world
        try
            let fadeOutTime =
                match ScriptingSystem.tryExport typeof<GameTime> fadeOutTime world with
                | Some value -> value :?> GameTime
                | None -> failwith "Invalid argument type for 'fadeOutTime'; expecting a value convertable to GameTime."
            let result = World.fadeOutSong fadeOutTime world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'fadeOutSong' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let stopSong world =
        let oldWorld = world
        try
            let result = World.stopSong world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'stopSong' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let loadAudioPackage packageName world =
        let oldWorld = world
        try
            let packageName =
                match ScriptingSystem.tryExport typeof<String> packageName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'packageName'; expecting a value convertable to String."
            let result = World.loadAudioPackage packageName world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'loadAudioPackage' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let unloadAudioPackage packageName world =
        let oldWorld = world
        try
            let packageName =
                match ScriptingSystem.tryExport typeof<String> packageName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'packageName'; expecting a value convertable to String."
            let result = World.unloadAudioPackage packageName world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'unloadAudioPackage' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let reloadAudioAssets world =
        let oldWorld = world
        try
            let result = World.reloadAudioAssets world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'reloadAudioAssets' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let loadRenderPackage2d packageName world =
        let oldWorld = world
        try
            let packageName =
                match ScriptingSystem.tryExport typeof<String> packageName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'packageName'; expecting a value convertable to String."
            let result = World.loadRenderPackage2d packageName world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'loadRenderPackage2d' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let unloadRenderPackage2d packageName world =
        let oldWorld = world
        try
            let packageName =
                match ScriptingSystem.tryExport typeof<String> packageName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'packageName'; expecting a value convertable to String."
            let result = World.unloadRenderPackage2d packageName world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'unloadRenderPackage2d' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let reloadRenderAssets2d world =
        let oldWorld = world
        try
            let result = World.reloadRenderAssets2d world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'reloadRenderAssets2d' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let reloadRenderAssets3d world =
        let oldWorld = world
        try
            let result = World.reloadRenderAssets3d world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'reloadRenderAssets3d' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let localizeBodyShape size bodyShape world =
        let oldWorld = world
        try
            let size =
                match ScriptingSystem.tryExport typeof<Vector3> size world with
                | Some value -> value :?> Vector3
                | None -> failwith "Invalid argument type for 'size'; expecting a value convertable to Vector3."
            let bodyShape =
                match ScriptingSystem.tryExport typeof<BodyShape> bodyShape world with
                | Some value -> value :?> BodyShape
                | None -> failwith "Invalid argument type for 'bodyShape'; expecting a value convertable to BodyShape."
            let result = World.localizeBodyShape size bodyShape world
            let value = result
            let value = ScriptingSystem.tryImport typeof<BodyShape> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'localizeBodyShape' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getBodyExists bodyId world =
        let oldWorld = world
        try
            let bodyId =
                match ScriptingSystem.tryExport typeof<BodyId> bodyId world with
                | Some value -> value :?> BodyId
                | None -> failwith "Invalid argument type for 'bodyId'; expecting a value convertable to BodyId."
            let result = World.getBodyExists bodyId world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getBodyExists' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getBodyContactNormals bodyId world =
        let oldWorld = world
        try
            let bodyId =
                match ScriptingSystem.tryExport typeof<BodyId> bodyId world with
                | Some value -> value :?> BodyId
                | None -> failwith "Invalid argument type for 'bodyId'; expecting a value convertable to BodyId."
            let result = World.getBodyContactNormals bodyId world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpList<Vector3>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getBodyContactNormals' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getBodyLinearVelocity bodyId world =
        let oldWorld = world
        try
            let bodyId =
                match ScriptingSystem.tryExport typeof<BodyId> bodyId world with
                | Some value -> value :?> BodyId
                | None -> failwith "Invalid argument type for 'bodyId'; expecting a value convertable to BodyId."
            let result = World.getBodyLinearVelocity bodyId world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector3> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getBodyLinearVelocity' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getBodyToGroundContactNormals bodyId world =
        let oldWorld = world
        try
            let bodyId =
                match ScriptingSystem.tryExport typeof<BodyId> bodyId world with
                | Some value -> value :?> BodyId
                | None -> failwith "Invalid argument type for 'bodyId'; expecting a value convertable to BodyId."
            let result = World.getBodyToGroundContactNormals bodyId world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpList<Vector3>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getBodyToGroundContactNormals' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getBodyToGroundContactNormalOpt bodyId world =
        let oldWorld = world
        try
            let bodyId =
                match ScriptingSystem.tryExport typeof<BodyId> bodyId world with
                | Some value -> value :?> BodyId
                | None -> failwith "Invalid argument type for 'bodyId'; expecting a value convertable to BodyId."
            let result = World.getBodyToGroundContactNormalOpt bodyId world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Vector3>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getBodyToGroundContactNormalOpt' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getBodyToGroundContactTangentOpt bodyId world =
        let oldWorld = world
        try
            let bodyId =
                match ScriptingSystem.tryExport typeof<BodyId> bodyId world with
                | Some value -> value :?> BodyId
                | None -> failwith "Invalid argument type for 'bodyId'; expecting a value convertable to BodyId."
            let result = World.getBodyToGroundContactTangentOpt bodyId world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Vector3>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getBodyToGroundContactTangentOpt' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let isBodyOnGround bodyId world =
        let oldWorld = world
        try
            let bodyId =
                match ScriptingSystem.tryExport typeof<BodyId> bodyId world with
                | Some value -> value :?> BodyId
                | None -> failwith "Invalid argument type for 'bodyId'; expecting a value convertable to BodyId."
            let result = World.isBodyOnGround bodyId world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isBodyOnGround' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let createBody is2d bodyId bodyProperties world =
        let oldWorld = world
        try
            let is2d =
                match ScriptingSystem.tryExport typeof<Boolean> is2d world with
                | Some value -> value :?> Boolean
                | None -> failwith "Invalid argument type for 'is2d'; expecting a value convertable to Boolean."
            let bodyId =
                match ScriptingSystem.tryExport typeof<BodyId> bodyId world with
                | Some value -> value :?> BodyId
                | None -> failwith "Invalid argument type for 'bodyId'; expecting a value convertable to BodyId."
            let bodyProperties =
                match ScriptingSystem.tryExport typeof<BodyProperties> bodyProperties world with
                | Some value -> value :?> BodyProperties
                | None -> failwith "Invalid argument type for 'bodyProperties'; expecting a value convertable to BodyProperties."
            let result = World.createBody is2d bodyId bodyProperties world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createBody' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let createBodies is2d bodySource bodiesProperties world =
        let oldWorld = world
        try
            let is2d =
                match ScriptingSystem.tryExport typeof<Boolean> is2d world with
                | Some value -> value :?> Boolean
                | None -> failwith "Invalid argument type for 'is2d'; expecting a value convertable to Boolean."
            let struct (bodySource, world) =
                let context = World.getScriptContext world
                match World.evalInternal bodySource world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.derive address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let struct (bodiesProperties, world) =
                match World.evalInternal bodiesProperties world with
                | struct (Scripting.List list, world) ->
                    Seq.fold (fun struct (values, world) value ->
                        let value =
                            match ScriptingSystem.tryExport typeof<BodyProperties> value world with
                            | Some value -> value :?> BodyProperties
                            | None -> failwith "Invalid argument type for 'bodiesProperties'; expecting a value convertable to BodyProperties."
                        struct (value :: values, world))
                        struct ([], world)
                        list
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.createBodies is2d bodySource bodiesProperties world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createBodies' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let destroyBody is2d bodyId world =
        let oldWorld = world
        try
            let is2d =
                match ScriptingSystem.tryExport typeof<Boolean> is2d world with
                | Some value -> value :?> Boolean
                | None -> failwith "Invalid argument type for 'is2d'; expecting a value convertable to Boolean."
            let bodyId =
                match ScriptingSystem.tryExport typeof<BodyId> bodyId world with
                | Some value -> value :?> BodyId
                | None -> failwith "Invalid argument type for 'bodyId'; expecting a value convertable to BodyId."
            let result = World.destroyBody is2d bodyId world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroyBody' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let destroyBodies is2d bodyIds world =
        let oldWorld = world
        try
            let is2d =
                match ScriptingSystem.tryExport typeof<Boolean> is2d world with
                | Some value -> value :?> Boolean
                | None -> failwith "Invalid argument type for 'is2d'; expecting a value convertable to Boolean."
            let struct (bodyIds, world) =
                match World.evalInternal bodyIds world with
                | struct (Scripting.List list, world) ->
                    Seq.fold (fun struct (values, world) value ->
                        let value =
                            match ScriptingSystem.tryExport typeof<BodyId> value world with
                            | Some value -> value :?> BodyId
                            | None -> failwith "Invalid argument type for 'bodyIds'; expecting a value convertable to BodyId."
                        struct (value :: values, world))
                        struct ([], world)
                        list
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.destroyBodies is2d bodyIds world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroyBodies' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let createJoint is2d jointSource jointProperties world =
        let oldWorld = world
        try
            let is2d =
                match ScriptingSystem.tryExport typeof<Boolean> is2d world with
                | Some value -> value :?> Boolean
                | None -> failwith "Invalid argument type for 'is2d'; expecting a value convertable to Boolean."
            let struct (jointSource, world) =
                let context = World.getScriptContext world
                match World.evalInternal jointSource world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.derive address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let jointProperties =
                match ScriptingSystem.tryExport typeof<JointProperties> jointProperties world with
                | Some value -> value :?> JointProperties
                | None -> failwith "Invalid argument type for 'jointProperties'; expecting a value convertable to JointProperties."
            let result = World.createJoint is2d jointSource jointProperties world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createJoint' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let createJoints is2d jointSource jointsProperties world =
        let oldWorld = world
        try
            let is2d =
                match ScriptingSystem.tryExport typeof<Boolean> is2d world with
                | Some value -> value :?> Boolean
                | None -> failwith "Invalid argument type for 'is2d'; expecting a value convertable to Boolean."
            let struct (jointSource, world) =
                let context = World.getScriptContext world
                match World.evalInternal jointSource world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.derive address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let struct (jointsProperties, world) =
                match World.evalInternal jointsProperties world with
                | struct (Scripting.List list, world) ->
                    Seq.fold (fun struct (values, world) value ->
                        let value =
                            match ScriptingSystem.tryExport typeof<JointProperties> value world with
                            | Some value -> value :?> JointProperties
                            | None -> failwith "Invalid argument type for 'jointsProperties'; expecting a value convertable to JointProperties."
                        struct (value :: values, world))
                        struct ([], world)
                        list
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.createJoints is2d jointSource jointsProperties world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createJoints' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let destroyJoint is2d jointId world =
        let oldWorld = world
        try
            let is2d =
                match ScriptingSystem.tryExport typeof<Boolean> is2d world with
                | Some value -> value :?> Boolean
                | None -> failwith "Invalid argument type for 'is2d'; expecting a value convertable to Boolean."
            let jointId =
                match ScriptingSystem.tryExport typeof<JointId> jointId world with
                | Some value -> value :?> JointId
                | None -> failwith "Invalid argument type for 'jointId'; expecting a value convertable to JointId."
            let result = World.destroyJoint is2d jointId world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroyJoint' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let destroyJoints is2d jointIds world =
        let oldWorld = world
        try
            let is2d =
                match ScriptingSystem.tryExport typeof<Boolean> is2d world with
                | Some value -> value :?> Boolean
                | None -> failwith "Invalid argument type for 'is2d'; expecting a value convertable to Boolean."
            let struct (jointIds, world) =
                match World.evalInternal jointIds world with
                | struct (Scripting.List list, world) ->
                    Seq.fold (fun struct (values, world) value ->
                        let value =
                            match ScriptingSystem.tryExport typeof<JointId> value world with
                            | Some value -> value :?> JointId
                            | None -> failwith "Invalid argument type for 'jointIds'; expecting a value convertable to JointId."
                        struct (value :: values, world))
                        struct ([], world)
                        list
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.destroyJoints is2d jointIds world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroyJoints' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let setBodyEnabled enabled bodyId world =
        let oldWorld = world
        try
            let enabled =
                match ScriptingSystem.tryExport typeof<Boolean> enabled world with
                | Some value -> value :?> Boolean
                | None -> failwith "Invalid argument type for 'enabled'; expecting a value convertable to Boolean."
            let bodyId =
                match ScriptingSystem.tryExport typeof<BodyId> bodyId world with
                | Some value -> value :?> BodyId
                | None -> failwith "Invalid argument type for 'bodyId'; expecting a value convertable to BodyId."
            let result = World.setBodyEnabled enabled bodyId world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setBodyEnabled' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let setBodyCenter center bodyId world =
        let oldWorld = world
        try
            let center =
                match ScriptingSystem.tryExport typeof<Vector3> center world with
                | Some value -> value :?> Vector3
                | None -> failwith "Invalid argument type for 'center'; expecting a value convertable to Vector3."
            let bodyId =
                match ScriptingSystem.tryExport typeof<BodyId> bodyId world with
                | Some value -> value :?> BodyId
                | None -> failwith "Invalid argument type for 'bodyId'; expecting a value convertable to BodyId."
            let result = World.setBodyCenter center bodyId world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setBodyCenter' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let setBodyRotation rotation bodyId world =
        let oldWorld = world
        try
            let rotation =
                match ScriptingSystem.tryExport typeof<Quaternion> rotation world with
                | Some value -> value :?> Quaternion
                | None -> failwith "Invalid argument type for 'rotation'; expecting a value convertable to Quaternion."
            let bodyId =
                match ScriptingSystem.tryExport typeof<BodyId> bodyId world with
                | Some value -> value :?> BodyId
                | None -> failwith "Invalid argument type for 'bodyId'; expecting a value convertable to BodyId."
            let result = World.setBodyRotation rotation bodyId world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setBodyRotation' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let setBodyLinearVelocity linearVelocity bodyId world =
        let oldWorld = world
        try
            let linearVelocity =
                match ScriptingSystem.tryExport typeof<Vector3> linearVelocity world with
                | Some value -> value :?> Vector3
                | None -> failwith "Invalid argument type for 'linearVelocity'; expecting a value convertable to Vector3."
            let bodyId =
                match ScriptingSystem.tryExport typeof<BodyId> bodyId world with
                | Some value -> value :?> BodyId
                | None -> failwith "Invalid argument type for 'bodyId'; expecting a value convertable to BodyId."
            let result = World.setBodyLinearVelocity linearVelocity bodyId world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setBodyLinearVelocity' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let applyBodyLinearImpulse linearImpulse offset bodyId world =
        let oldWorld = world
        try
            let linearImpulse =
                match ScriptingSystem.tryExport typeof<Vector3> linearImpulse world with
                | Some value -> value :?> Vector3
                | None -> failwith "Invalid argument type for 'linearImpulse'; expecting a value convertable to Vector3."
            let offset =
                match ScriptingSystem.tryExport typeof<Vector3> offset world with
                | Some value -> value :?> Vector3
                | None -> failwith "Invalid argument type for 'offset'; expecting a value convertable to Vector3."
            let bodyId =
                match ScriptingSystem.tryExport typeof<BodyId> bodyId world with
                | Some value -> value :?> BodyId
                | None -> failwith "Invalid argument type for 'bodyId'; expecting a value convertable to BodyId."
            let result = World.applyBodyLinearImpulse linearImpulse offset bodyId world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'applyBodyLinearImpulse' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let setBodyAngularVelocity angularVelocity bodyId world =
        let oldWorld = world
        try
            let angularVelocity =
                match ScriptingSystem.tryExport typeof<Vector3> angularVelocity world with
                | Some value -> value :?> Vector3
                | None -> failwith "Invalid argument type for 'angularVelocity'; expecting a value convertable to Vector3."
            let bodyId =
                match ScriptingSystem.tryExport typeof<BodyId> bodyId world with
                | Some value -> value :?> BodyId
                | None -> failwith "Invalid argument type for 'bodyId'; expecting a value convertable to BodyId."
            let result = World.setBodyAngularVelocity angularVelocity bodyId world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setBodyAngularVelocity' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let applyBodyAngularImpulse angularImpulse bodyId world =
        let oldWorld = world
        try
            let angularImpulse =
                match ScriptingSystem.tryExport typeof<Vector3> angularImpulse world with
                | Some value -> value :?> Vector3
                | None -> failwith "Invalid argument type for 'angularImpulse'; expecting a value convertable to Vector3."
            let bodyId =
                match ScriptingSystem.tryExport typeof<BodyId> bodyId world with
                | Some value -> value :?> BodyId
                | None -> failwith "Invalid argument type for 'bodyId'; expecting a value convertable to BodyId."
            let result = World.applyBodyAngularImpulse angularImpulse bodyId world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'applyBodyAngularImpulse' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let applyBodyForce force offset bodyId world =
        let oldWorld = world
        try
            let force =
                match ScriptingSystem.tryExport typeof<Vector3> force world with
                | Some value -> value :?> Vector3
                | None -> failwith "Invalid argument type for 'force'; expecting a value convertable to Vector3."
            let offset =
                match ScriptingSystem.tryExport typeof<Vector3> offset world with
                | Some value -> value :?> Vector3
                | None -> failwith "Invalid argument type for 'offset'; expecting a value convertable to Vector3."
            let bodyId =
                match ScriptingSystem.tryExport typeof<BodyId> bodyId world with
                | Some value -> value :?> BodyId
                | None -> failwith "Invalid argument type for 'bodyId'; expecting a value convertable to BodyId."
            let result = World.applyBodyForce force offset bodyId world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'applyBodyForce' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let applyBodyTorque torque bodyId world =
        let oldWorld = world
        try
            let torque =
                match ScriptingSystem.tryExport typeof<Vector3> torque world with
                | Some value -> value :?> Vector3
                | None -> failwith "Invalid argument type for 'torque'; expecting a value convertable to Vector3."
            let bodyId =
                match ScriptingSystem.tryExport typeof<BodyId> bodyId world with
                | Some value -> value :?> BodyId
                | None -> failwith "Invalid argument type for 'bodyId'; expecting a value convertable to BodyId."
            let result = World.applyBodyTorque torque bodyId world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'applyBodyTorque' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let setBodyObservable observable bodyId world =
        let oldWorld = world
        try
            let observable =
                match ScriptingSystem.tryExport typeof<Boolean> observable world with
                | Some value -> value :?> Boolean
                | None -> failwith "Invalid argument type for 'observable'; expecting a value convertable to Boolean."
            let bodyId =
                match ScriptingSystem.tryExport typeof<BodyId> bodyId world with
                | Some value -> value :?> BodyId
                | None -> failwith "Invalid argument type for 'bodyId'; expecting a value convertable to BodyId."
            let result = World.setBodyObservable observable bodyId world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setBodyObservable' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let isMouseButtonDown mouseButton world =
        let oldWorld = world
        try
            let mouseButton =
                match ScriptingSystem.tryExport typeof<MouseButton> mouseButton world with
                | Some value -> value :?> MouseButton
                | None -> failwith "Invalid argument type for 'mouseButton'; expecting a value convertable to MouseButton."
            let result = World.isMouseButtonDown mouseButton world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isMouseButtonDown' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getMousePosition world =
        let oldWorld = world
        try
            let result = World.getMousePosition world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector2> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getMousePosition' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getMousePosition2dScreen world =
        let oldWorld = world
        try
            let result = World.getMousePosition2dScreen world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector2> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getMousePosition2dScreen' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getMousePostion2dWorld absolute world =
        let oldWorld = world
        try
            let absolute =
                match ScriptingSystem.tryExport typeof<Boolean> absolute world with
                | Some value -> value :?> Boolean
                | None -> failwith "Invalid argument type for 'absolute'; expecting a value convertable to Boolean."
            let result = World.getMousePostion2dWorld absolute world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector2> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getMousePostion2dWorld' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getMousePosition3dScreen world =
        let oldWorld = world
        try
            let result = World.getMousePosition3dScreen world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector2> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getMousePosition3dScreen' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getMouseRay3dWorld absolute world =
        let oldWorld = world
        try
            let absolute =
                match ScriptingSystem.tryExport typeof<Boolean> absolute world with
                | Some value -> value :?> Boolean
                | None -> failwith "Invalid argument type for 'absolute'; expecting a value convertable to Boolean."
            let result = World.getMouseRay3dWorld absolute world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Ray3> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getMouseRay3dWorld' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let isKeyboardKeyDown key world =
        let oldWorld = world
        try
            let key =
                match ScriptingSystem.tryExport typeof<KeyboardKey> key world with
                | Some value -> value :?> KeyboardKey
                | None -> failwith "Invalid argument type for 'key'; expecting a value convertable to KeyboardKey."
            let result = World.isKeyboardKeyDown key world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isKeyboardKeyDown' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let isKeyboardKeyUp key world =
        let oldWorld = world
        try
            let key =
                match ScriptingSystem.tryExport typeof<KeyboardKey> key world with
                | Some value -> value :?> KeyboardKey
                | None -> failwith "Invalid argument type for 'key'; expecting a value convertable to KeyboardKey."
            let result = World.isKeyboardKeyUp key world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isKeyboardKeyUp' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let isKeyboardAltDown world =
        let oldWorld = world
        try
            let result = World.isKeyboardAltDown world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isKeyboardAltDown' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let isKeyboardAltUp world =
        let oldWorld = world
        try
            let result = World.isKeyboardAltUp world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isKeyboardAltUp' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let isKeyboardCtrlDown world =
        let oldWorld = world
        try
            let result = World.isKeyboardCtrlDown world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isKeyboardCtrlDown' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let isKeyboardCtrlUp world =
        let oldWorld = world
        try
            let result = World.isKeyboardCtrlUp world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isKeyboardCtrlUp' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let isKeyboardShiftDown world =
        let oldWorld = world
        try
            let result = World.isKeyboardShiftDown world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isKeyboardShiftDown' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let isKeyboardShiftUp world =
        let oldWorld = world
        try
            let result = World.isKeyboardShiftUp world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isKeyboardShiftUp' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let destroyImmediate simulant world =
        let oldWorld = world
        try
            let struct (simulant, world) =
                let context = World.getScriptContext world
                match World.evalInternal simulant world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.derive address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.destroyImmediate simulant world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroyImmediate' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let destroy simulant world =
        let oldWorld = world
        try
            let struct (simulant, world) =
                let context = World.getScriptContext world
                match World.evalInternal simulant world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.derive address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.destroy simulant world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroy' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let tryGetParent simulant world =
        let oldWorld = world
        try
            let struct (simulant, world) =
                let context = World.getScriptContext world
                match World.evalInternal simulant world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.derive address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.tryGetParent simulant world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Simulant>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryGetParent' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getParent simulant world =
        let oldWorld = world
        try
            let struct (simulant, world) =
                let context = World.getScriptContext world
                match World.evalInternal simulant world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.derive address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.getParent simulant world
            let value = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getParent' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getChildren simulant world =
        let oldWorld = world
        try
            let struct (simulant, world) =
                let context = World.getScriptContext world
                match World.evalInternal simulant world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.derive address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.getChildren simulant world
            let value = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getChildren' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getExists simulant world =
        let oldWorld = world
        try
            let struct (simulant, world) =
                let context = World.getScriptContext world
                match World.evalInternal simulant world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.derive address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.getExists simulant world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getExists' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let isSelected simulant world =
        let oldWorld = world
        try
            let struct (simulant, world) =
                let context = World.getScriptContext world
                match World.evalInternal simulant world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.derive address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.isSelected simulant world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isSelected' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getEntitiesFlattened0 world =
        let oldWorld = world
        try
            let result = World.getEntitiesFlattened1 world
            let value = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEntitiesFlattened0' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getGroups0 world =
        let oldWorld = world
        try
            let result = World.getGroups1 world
            let value = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getGroups0' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let writeGameToFile filePath world =
        let oldWorld = world
        try
            let filePath =
                match ScriptingSystem.tryExport typeof<String> filePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'filePath'; expecting a value convertable to String."
            let result = World.writeGameToFile filePath world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Void> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'writeGameToFile' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let readGameFromFile filePath world =
        let oldWorld = world
        try
            let filePath =
                match ScriptingSystem.tryExport typeof<String> filePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'filePath'; expecting a value convertable to String."
            let result = World.readGameFromFile filePath world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'readGameFromFile' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getScreens world =
        let oldWorld = world
        try
            let result = World.getScreens world
            let value = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getScreens' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let setScreenDissolve dissolveDescriptor songOpt screen world =
        let oldWorld = world
        try
            let dissolveDescriptor =
                match ScriptingSystem.tryExport typeof<DissolveDescriptor> dissolveDescriptor world with
                | Some value -> value :?> DissolveDescriptor
                | None -> failwith "Invalid argument type for 'dissolveDescriptor'; expecting a value convertable to DissolveDescriptor."
            let songOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<SongDescriptor>> songOpt world with
                | Some value -> value :?> FSharpOption<SongDescriptor>
                | None -> failwith "Invalid argument type for 'songOpt'; expecting a value convertable to FSharpOption`1."
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.setScreenDissolve dissolveDescriptor songOpt screen world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setScreenDissolve' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let destroyScreen screen world =
        let oldWorld = world
        try
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.destroyScreen screen world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroyScreen' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let createScreen dispatcherName nameOpt world =
        let oldWorld = world
        try
            let dispatcherName =
                match ScriptingSystem.tryExport typeof<String> dispatcherName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'dispatcherName'; expecting a value convertable to String."
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let result = World.createScreen3 dispatcherName nameOpt world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createScreen' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let createDissolveScreen dispatcherName nameOpt dissolveDescriptor songOpt world =
        let oldWorld = world
        try
            let dispatcherName =
                match ScriptingSystem.tryExport typeof<String> dispatcherName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'dispatcherName'; expecting a value convertable to String."
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let dissolveDescriptor =
                match ScriptingSystem.tryExport typeof<DissolveDescriptor> dissolveDescriptor world with
                | Some value -> value :?> DissolveDescriptor
                | None -> failwith "Invalid argument type for 'dissolveDescriptor'; expecting a value convertable to DissolveDescriptor."
            let songOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<SongDescriptor>> songOpt world with
                | Some value -> value :?> FSharpOption<SongDescriptor>
                | None -> failwith "Invalid argument type for 'songOpt'; expecting a value convertable to FSharpOption`1."
            let result = World.createDissolveScreen5 dispatcherName nameOpt dissolveDescriptor songOpt world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createDissolveScreen' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let writeScreenToFile filePath screen world =
        let oldWorld = world
        try
            let filePath =
                match ScriptingSystem.tryExport typeof<String> filePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'filePath'; expecting a value convertable to String."
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.writeScreenToFile filePath screen world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Void> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'writeScreenToFile' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let readScreenFromFile filePath nameOpt world =
        let oldWorld = world
        try
            let filePath =
                match ScriptingSystem.tryExport typeof<String> filePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'filePath'; expecting a value convertable to String."
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let result = World.readScreenFromFile filePath nameOpt world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'readScreenFromFile' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getGroups screen world =
        let oldWorld = world
        try
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.getGroups screen world
            let value = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getGroups' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let createGroup dispatcherName nameOpt screen world =
        let oldWorld = world
        try
            let dispatcherName =
                match ScriptingSystem.tryExport typeof<String> dispatcherName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'dispatcherName'; expecting a value convertable to String."
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.createGroup4 dispatcherName nameOpt screen world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createGroup' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let destroyGroup group world =
        let oldWorld = world
        try
            let struct (group, world) =
                let context = World.getScriptContext world
                match World.evalInternal group world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Group address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.destroyGroup group world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroyGroup' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let destroyGroups groups world =
        let oldWorld = world
        try
            let struct (groups, world) =
                let context = World.getScriptContext world
                match World.evalInternal groups world with
                | struct (Scripting.List simulants, world) ->
                    List.fold (fun struct (simulants, world) simulant ->
                        match simulant with
                        | Scripting.String str
                        | Scripting.Keyword str ->
                            let relation = Relation.makeFromString str
                            let address = Relation.resolve context.SimulantAddress relation
                            struct (Group address :: simulants, world)
                        | Scripting.Violation (_, error, _) -> failwith error
                        | _ -> failwith "Relation must be either a String or Keyword.")
                        struct ([], world)
                        simulants
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Expecting a list of relations."
            let result = World.destroyGroups groups world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroyGroups' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let writeGroupToFile filePath group world =
        let oldWorld = world
        try
            let filePath =
                match ScriptingSystem.tryExport typeof<String> filePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'filePath'; expecting a value convertable to String."
            let struct (group, world) =
                let context = World.getScriptContext world
                match World.evalInternal group world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Group address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.writeGroupToFile filePath group world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Void> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'writeGroupToFile' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let readGroupFromFile filePath nameOpt screen world =
        let oldWorld = world
        try
            let filePath =
                match ScriptingSystem.tryExport typeof<String> filePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'filePath'; expecting a value convertable to String."
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.readGroupFromFile filePath nameOpt screen world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'readGroupFromFile' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getEntitiesFlattened group world =
        let oldWorld = world
        try
            let struct (group, world) =
                let context = World.getScriptContext world
                match World.evalInternal group world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Group address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.getEntitiesFlattened group world
            let value = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEntitiesFlattened' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getEntitiesSovereign group world =
        let oldWorld = world
        try
            let struct (group, world) =
                let context = World.getScriptContext world
                match World.evalInternal group world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Group address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.getEntitiesSovereign group world
            let value = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEntitiesSovereign' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let destroyEntity entity world =
        let oldWorld = world
        try
            let struct (entity, world) =
                let context = World.getScriptContext world
                match World.evalInternal entity world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Entity address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.destroyEntity entity world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroyEntity' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let destroyEntities entities world =
        let oldWorld = world
        try
            let struct (entities, world) =
                let context = World.getScriptContext world
                match World.evalInternal entities world with
                | struct (Scripting.List simulants, world) ->
                    List.fold (fun struct (simulants, world) simulant ->
                        match simulant with
                        | Scripting.String str
                        | Scripting.Keyword str ->
                            let relation = Relation.makeFromString str
                            let address = Relation.resolve context.SimulantAddress relation
                            struct (Entity address :: simulants, world)
                        | Scripting.Violation (_, error, _) -> failwith error
                        | _ -> failwith "Relation must be either a String or Keyword.")
                        struct ([], world)
                        simulants
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Expecting a list of relations."
            let result = World.destroyEntities entities world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroyEntities' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let tryPickEntity2d position entities world =
        let oldWorld = world
        try
            let position =
                match ScriptingSystem.tryExport typeof<Vector2> position world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'position'; expecting a value convertable to Vector2."
            let struct (entities, world) =
                let context = World.getScriptContext world
                match World.evalInternal entities world with
                | struct (Scripting.List simulants, world) ->
                    List.fold (fun struct (simulants, world) simulant ->
                        match simulant with
                        | Scripting.String str
                        | Scripting.Keyword str ->
                            let relation = Relation.makeFromString str
                            let address = Relation.resolve context.SimulantAddress relation
                            struct (Entity address :: simulants, world)
                        | Scripting.Violation (_, error, _) -> failwith error
                        | _ -> failwith "Relation must be either a String or Keyword.")
                        struct ([], world)
                        simulants
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Expecting a list of relations."
            let result = World.tryPickEntity2d position entities world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Entity>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryPickEntity2d' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let tryPickEntity3d position entities world =
        let oldWorld = world
        try
            let position =
                match ScriptingSystem.tryExport typeof<Vector2> position world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'position'; expecting a value convertable to Vector2."
            let struct (entities, world) =
                let context = World.getScriptContext world
                match World.evalInternal entities world with
                | struct (Scripting.List simulants, world) ->
                    List.fold (fun struct (simulants, world) simulant ->
                        match simulant with
                        | Scripting.String str
                        | Scripting.Keyword str ->
                            let relation = Relation.makeFromString str
                            let address = Relation.resolve context.SimulantAddress relation
                            struct (Entity address :: simulants, world)
                        | Scripting.Violation (_, error, _) -> failwith error
                        | _ -> failwith "Relation must be either a String or Keyword.")
                        struct ([], world)
                        simulants
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Expecting a list of relations."
            let result = World.tryPickEntity3d position entities world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Tuple<Single, Entity>>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryPickEntity3d' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let writeEntityToFile filePath enity world =
        let oldWorld = world
        try
            let filePath =
                match ScriptingSystem.tryExport typeof<String> filePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'filePath'; expecting a value convertable to String."
            let struct (enity, world) =
                let context = World.getScriptContext world
                match World.evalInternal enity world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Entity address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.writeEntityToFile filePath enity world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Void> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'writeEntityToFile' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let readEntityFromFile filePath nameOpt group world =
        let oldWorld = world
        try
            let filePath =
                match ScriptingSystem.tryExport typeof<String> filePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'filePath'; expecting a value convertable to String."
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let struct (group, world) =
                let context = World.getScriptContext world
                match World.evalInternal group world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.derive address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.readEntityFromFile filePath nameOpt group world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'readEntityFromFile' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let createEntity dispatcherName overlayDescriptor surnames group world =
        let oldWorld = world
        try
            let dispatcherName =
                match ScriptingSystem.tryExport typeof<String> dispatcherName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'dispatcherName'; expecting a value convertable to String."
            let overlayDescriptor =
                match ScriptingSystem.tryExport typeof<OverlayNameDescriptor> overlayDescriptor world with
                | Some value -> value :?> OverlayNameDescriptor
                | None -> failwith "Invalid argument type for 'overlayDescriptor'; expecting a value convertable to OverlayNameDescriptor."
            let surnames =
                match ScriptingSystem.tryExport typeof<FSharpOption<String[]>> surnames world with
                | Some value -> value :?> FSharpOption<String[]>
                | None -> failwith "Invalid argument type for 'surnames'; expecting a value convertable to FSharpOption`1."
            let struct (group, world) =
                let context = World.getScriptContext world
                match World.evalInternal group world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Group address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.createEntity5 dispatcherName overlayDescriptor surnames group world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createEntity' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let renameEntity source destination world =
        let oldWorld = world
        try
            let struct (source, world) =
                let context = World.getScriptContext world
                match World.evalInternal source world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Entity address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let struct (destination, world) =
                let context = World.getScriptContext world
                match World.evalInternal destination world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Entity address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.renameEntity source destination world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'renameEntity' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let trySetEntityOverlayNameOpt overlayNameOpt entity world =
        let oldWorld = world
        try
            let overlayNameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> overlayNameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'overlayNameOpt'; expecting a value convertable to FSharpOption`1."
            let struct (entity, world) =
                let context = World.getScriptContext world
                match World.evalInternal entity world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Entity address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.trySetEntityOverlayNameOptFromScript overlayNameOpt entity world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'trySetEntityOverlayNameOpt' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let trySetEntityFacetNames facetNames entity world =
        let oldWorld = world
        try
            let facetNames =
                match ScriptingSystem.tryExport typeof<FSharpSet<String>> facetNames world with
                | Some value -> value :?> FSharpSet<String>
                | None -> failwith "Invalid argument type for 'facetNames'; expecting a value convertable to FSharpSet`1."
            let struct (entity, world) =
                let context = World.getScriptContext world
                match World.evalInternal entity world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Entity address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.trySetEntityFacetNamesFromScript facetNames entity world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'trySetEntityFacetNames' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getEyeCenter2d world =
        let oldWorld = world
        try
            let result = World.getEyeCenter2d world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector2> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEyeCenter2d' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let setEyeCenter2d value world =
        let oldWorld = world
        try
            let value =
                match ScriptingSystem.tryExport typeof<Vector2> value world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'value'; expecting a value convertable to Vector2."
            let result = World.setEyeCenter2d value world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setEyeCenter2d' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getEyeSize2d world =
        let oldWorld = world
        try
            let result = World.getEyeSize2d world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector2> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEyeSize2d' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let setEyeSize2d value world =
        let oldWorld = world
        try
            let value =
                match ScriptingSystem.tryExport typeof<Vector2> value world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'value'; expecting a value convertable to Vector2."
            let result = World.setEyeSize2d value world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setEyeSize2d' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getEyeBounds2d world =
        let oldWorld = world
        try
            let result = World.getEyeBounds2d world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Box2> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEyeBounds2d' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getEyeCenter3d world =
        let oldWorld = world
        try
            let result = World.getEyeCenter3d world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector3> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEyeCenter3d' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let setEyeCenter3d value world =
        let oldWorld = world
        try
            let value =
                match ScriptingSystem.tryExport typeof<Vector3> value world with
                | Some value -> value :?> Vector3
                | None -> failwith "Invalid argument type for 'value'; expecting a value convertable to Vector3."
            let result = World.setEyeCenter3d value world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setEyeCenter3d' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getEyeRotation3d world =
        let oldWorld = world
        try
            let result = World.getEyeRotation3d world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Quaternion> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEyeRotation3d' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let setEyeRotation3d value world =
        let oldWorld = world
        try
            let value =
                match ScriptingSystem.tryExport typeof<Quaternion> value world with
                | Some value -> value :?> Quaternion
                | None -> failwith "Invalid argument type for 'value'; expecting a value convertable to Quaternion."
            let result = World.setEyeRotation3d value world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setEyeRotation3d' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getEyeFrustum3dEnclosed world =
        let oldWorld = world
        try
            let result = World.getEyeFrustum3dEnclosed world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Frustum> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEyeFrustum3dEnclosed' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getEyeFrustum3dExposed world =
        let oldWorld = world
        try
            let result = World.getEyeFrustum3dExposed world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Frustum> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEyeFrustum3dExposed' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getEyeFrustum3dImposter world =
        let oldWorld = world
        try
            let result = World.getEyeFrustum3dImposter world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Frustum> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEyeFrustum3dImposter' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getLightBox3d world =
        let oldWorld = world
        try
            let result = World.getLightBox3d world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Box3> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getLightBox3d' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getOmniScreenOpt world =
        let oldWorld = world
        try
            let result = World.getOmniScreenOpt world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Screen>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getOmniScreenOpt' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let setOmniScreenOpt value world =
        let oldWorld = world
        try
            let value =
                match ScriptingSystem.tryExport typeof<FSharpOption<Screen>> value world with
                | Some value -> value :?> FSharpOption<Screen>
                | None -> failwith "Invalid argument type for 'value'; expecting a value convertable to FSharpOption`1."
            let result = World.setOmniScreenOpt value world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setOmniScreenOpt' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getOmniScreen world =
        let oldWorld = world
        try
            let result = World.getOmniScreen world
            let value = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getOmniScreen' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let setOmniScreen value world =
        let oldWorld = world
        try
            let struct (value, world) =
                let context = World.getScriptContext world
                match World.evalInternal value world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.setOmniScreen value world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setOmniScreen' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let constrainEyeBounds2d bounds world =
        let oldWorld = world
        try
            let bounds =
                match ScriptingSystem.tryExport typeof<Box2> bounds world with
                | Some value -> value :?> Box2
                | None -> failwith "Invalid argument type for 'bounds'; expecting a value convertable to Box2."
            let result = World.constrainEyeBounds2d bounds world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'constrainEyeBounds2d' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getSelectedScreenOpt world =
        let oldWorld = world
        try
            let result = World.getSelectedScreenOpt world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Screen>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getSelectedScreenOpt' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getSelectedScreen world =
        let oldWorld = world
        try
            let result = World.getSelectedScreen world
            let value = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getSelectedScreen' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let setSelectedScreen value world =
        let oldWorld = world
        try
            let struct (value, world) =
                let context = World.getScriptContext world
                match World.evalInternal value world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.setSelectedScreen value world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setSelectedScreen' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getDesiredScreen world =
        let oldWorld = world
        try
            let result = World.getDesiredScreen world
            let value = result
            let value = ScriptingSystem.tryImport typeof<DesiredScreen> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getDesiredScreen' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let setDesiredScreen value world =
        let oldWorld = world
        try
            let value =
                match ScriptingSystem.tryExport typeof<DesiredScreen> value world with
                | Some value -> value :?> DesiredScreen
                | None -> failwith "Invalid argument type for 'value'; expecting a value convertable to DesiredScreen."
            let result = World.setDesiredScreen value world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setDesiredScreen' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getScreenTransitionDestinationOpt world =
        let oldWorld = world
        try
            let result = World.getScreenTransitionDestinationOpt world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Screen>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getScreenTransitionDestinationOpt' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let setScreenTransitionDestinationOpt value world =
        let oldWorld = world
        try
            let value =
                match ScriptingSystem.tryExport typeof<FSharpOption<Screen>> value world with
                | Some value -> value :?> FSharpOption<Screen>
                | None -> failwith "Invalid argument type for 'value'; expecting a value convertable to FSharpOption`1."
            let result = World.setScreenTransitionDestinationOpt value world
            let value = result
            let value = ScriptingSystem.tryImport typeof<ValueTuple<Boolean, World>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setScreenTransitionDestinationOpt' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getViewBounds2dAbsolute world =
        let oldWorld = world
        try
            let result = World.getViewBounds2dAbsolute world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Box2> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getViewBounds2dAbsolute' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getPlayBounds2dAbsolute world =
        let oldWorld = world
        try
            let result = World.getPlayBounds2dAbsolute world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Box2> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getPlayBounds2dAbsolute' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getViewBounds2d world =
        let oldWorld = world
        try
            let result = World.getViewBounds2d world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Box2> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getViewBounds2d' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getPlayBounds2d world =
        let oldWorld = world
        try
            let result = World.getPlayBounds2d world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Box2> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getPlayBounds2d' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let isBoundsInView2d bounds world =
        let oldWorld = world
        try
            let bounds =
                match ScriptingSystem.tryExport typeof<Box2> bounds world with
                | Some value -> value :?> Box2
                | None -> failwith "Invalid argument type for 'bounds'; expecting a value convertable to Box2."
            let result = World.isBoundsInView2d bounds world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isBoundsInView2d' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getPlayBounds3d world =
        let oldWorld = world
        try
            let result = World.getPlayBounds3d world
            let value = result
            let value = ScriptingSystem.tryImport typeof<ValueTuple<Box3, Frustum>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getPlayBounds3d' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let isBoundsInView3d light presence bounds world =
        let oldWorld = world
        try
            let light =
                match ScriptingSystem.tryExport typeof<Boolean> light world with
                | Some value -> value :?> Boolean
                | None -> failwith "Invalid argument type for 'light'; expecting a value convertable to Boolean."
            let presence =
                match ScriptingSystem.tryExport typeof<Presence> presence world with
                | Some value -> value :?> Presence
                | None -> failwith "Invalid argument type for 'presence'; expecting a value convertable to Presence."
            let bounds =
                match ScriptingSystem.tryExport typeof<Box3> bounds world with
                | Some value -> value :?> Box3
                | None -> failwith "Invalid argument type for 'bounds'; expecting a value convertable to Box3."
            let result = World.isBoundsInView3d light presence bounds world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isBoundsInView3d' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let isBoundsInPlay3d bounds world =
        let oldWorld = world
        try
            let bounds =
                match ScriptingSystem.tryExport typeof<Box3> bounds world with
                | Some value -> value :?> Box3
                | None -> failwith "Invalid argument type for 'bounds'; expecting a value convertable to Box3."
            let result = World.isBoundsInPlay3d bounds world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isBoundsInPlay3d' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let tryGetTextureSize assetTag world =
        let oldWorld = world
        try
            let assetTag =
                match ScriptingSystem.tryExport typeof<AssetTag<Image>> assetTag world with
                | Some value -> value :?> AssetTag<Image>
                | None -> failwith "Invalid argument type for 'assetTag'; expecting a value convertable to AssetTag`1."
            let result = World.tryGetTextureSizeViaScript assetTag world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Vector2i>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryGetTextureSize' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getTextureSize assetTag world =
        let oldWorld = world
        try
            let assetTag =
                match ScriptingSystem.tryExport typeof<AssetTag<Image>> assetTag world with
                | Some value -> value :?> AssetTag<Image>
                | None -> failwith "Invalid argument type for 'assetTag'; expecting a value convertable to AssetTag`1."
            let result = World.getTextureSizeViaScript assetTag world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector2i> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getTextureSize' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let tryGetTextureSizeF assetTag world =
        let oldWorld = world
        try
            let assetTag =
                match ScriptingSystem.tryExport typeof<AssetTag<Image>> assetTag world with
                | Some value -> value :?> AssetTag<Image>
                | None -> failwith "Invalid argument type for 'assetTag'; expecting a value convertable to AssetTag`1."
            let result = World.tryGetTextureSizeFViaScript assetTag world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Vector2>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryGetTextureSizeF' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getTextureSizeF assetTag world =
        let oldWorld = world
        try
            let assetTag =
                match ScriptingSystem.tryExport typeof<AssetTag<Image>> assetTag world with
                | Some value -> value :?> AssetTag<Image>
                | None -> failwith "Invalid argument type for 'assetTag'; expecting a value convertable to AssetTag`1."
            let result = World.getTextureSizeFViaScript assetTag world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector2> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getTextureSizeF' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getImperative world =
        let oldWorld = world
        try
            let result = World.getImperative world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getImperative' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getAccompanied world =
        let oldWorld = world
        try
            let result = World.getAccompanied world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getAccompanied' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getUnaccompanied world =
        let oldWorld = world
        try
            let result = World.getUnaccompanied world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getUnaccompanied' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getCollectionConfig world =
        let oldWorld = world
        try
            let result = World.getCollectionConfig world
            let value = result
            let value = ScriptingSystem.tryImport typeof<TConfig> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getCollectionConfig' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getLiveness world =
        let oldWorld = world
        try
            let result = World.getLiveness world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Liveness> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getLiveness' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let setAdvancing advancing world =
        let oldWorld = world
        try
            let advancing =
                match ScriptingSystem.tryExport typeof<Boolean> advancing world with
                | Some value -> value :?> Boolean
                | None -> failwith "Invalid argument type for 'advancing'; expecting a value convertable to Boolean."
            let result = World.setAdvancing advancing world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setAdvancing' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getAdvancing world =
        let oldWorld = world
        try
            let result = World.getAdvancing world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getAdvancing' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getHalted world =
        let oldWorld = world
        try
            let result = World.getHalted world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getHalted' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getUpdateTime world =
        let oldWorld = world
        try
            let result = World.getUpdateTime world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Int64> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getUpdateTime' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getClockDelta world =
        let oldWorld = world
        try
            let result = World.getClockDelta world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Single> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getClockDelta' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getClockTime world =
        let oldWorld = world
        try
            let result = World.getClockTime world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Single> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getClockTime' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getGameDelta world =
        let oldWorld = world
        try
            let result = World.getGameDelta world
            let value = result
            let value = ScriptingSystem.tryImport typeof<GameTime> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getGameDelta' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getGameTime world =
        let oldWorld = world
        try
            let result = World.getGameTime world
            let value = result
            let value = ScriptingSystem.tryImport typeof<GameTime> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getGameTime' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let exit world =
        let oldWorld = world
        try
            let result = World.exit world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'exit' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let tryGetWindowFlags world =
        let oldWorld = world
        try
            let result = World.tryGetWindowFlags world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<UInt32>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryGetWindowFlags' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let tryGetWindowMinimized world =
        let oldWorld = world
        try
            let result = World.tryGetWindowMinimized world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Boolean>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryGetWindowMinimized' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let tryGetWindowMaximized world =
        let oldWorld = world
        try
            let result = World.tryGetWindowMaximized world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Boolean>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryGetWindowMaximized' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let tryGetWindowFullScreen world =
        let oldWorld = world
        try
            let result = World.tryGetWindowFullScreen world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Boolean>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryGetWindowFullScreen' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let trySetWindowFullScreen fullScreen world =
        let oldWorld = world
        try
            let fullScreen =
                match ScriptingSystem.tryExport typeof<Boolean> fullScreen world with
                | Some value -> value :?> Boolean
                | None -> failwith "Invalid argument type for 'fullScreen'; expecting a value convertable to Boolean."
            let result = World.trySetWindowFullScreen fullScreen world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'trySetWindowFullScreen' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let tryGetWindowSize world =
        let oldWorld = world
        try
            let result = World.tryGetWindowSize world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Vector2i>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryGetWindowSize' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getWindowSize world =
        let oldWorld = world
        try
            let result = World.getWindowSize world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector2i> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getWindowSize' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getViewport world =
        let oldWorld = world
        try
            let result = World.getViewport world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Viewport> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getViewport' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getViewportOffset world =
        let oldWorld = world
        try
            let result = World.getViewportOffset world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Viewport> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getViewportOffset' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let tryLoadSymbolPackage implicitDelimiters packageName world =
        let oldWorld = world
        try
            let implicitDelimiters =
                match ScriptingSystem.tryExport typeof<String> implicitDelimiters world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'implicitDelimiters'; expecting a value convertable to String."
            let packageName =
                match ScriptingSystem.tryExport typeof<SymbolLoadMetadata> packageName world with
                | Some value -> value :?> SymbolLoadMetadata
                | None -> failwith "Invalid argument type for 'packageName'; expecting a value convertable to SymbolLoadMetadata."
            let result = World.tryLoadSymbolPackage implicitDelimiters packageName world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Void> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryLoadSymbolPackage' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let unloadSymbolPackage packageName world =
        let oldWorld = world
        try
            let packageName =
                match ScriptingSystem.tryExport typeof<String> packageName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'packageName'; expecting a value convertable to String."
            let result = World.unloadSymbolPackage packageName world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Void> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'unloadSymbolPackage' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let tryGetSymbol assetTag metadata world =
        let oldWorld = world
        try
            let assetTag =
                match ScriptingSystem.tryExport typeof<AssetTag<Symbol>> assetTag world with
                | Some value -> value :?> AssetTag<Symbol>
                | None -> failwith "Invalid argument type for 'assetTag'; expecting a value convertable to AssetTag`1."
            let metadata =
                match ScriptingSystem.tryExport typeof<SymbolLoadMetadata> metadata world with
                | Some value -> value :?> SymbolLoadMetadata
                | None -> failwith "Invalid argument type for 'metadata'; expecting a value convertable to SymbolLoadMetadata."
            let result = World.tryGetSymbol assetTag metadata world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Symbol>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryGetSymbol' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let tryGetSymbols implicitDelimiters assetTags world =
        let oldWorld = world
        try
            let implicitDelimiters =
                match ScriptingSystem.tryExport typeof<AssetTag<Symbol>> implicitDelimiters world with
                | Some value -> value :?> AssetTag<Symbol>
                | None -> failwith "Invalid argument type for 'implicitDelimiters'; expecting a value convertable to AssetTag`1."
            let struct (assetTags, world) =
                match World.evalInternal assetTags world with
                | struct (Scripting.List list, world) ->
                    Seq.fold (fun struct (values, world) value ->
                        let value =
                            match ScriptingSystem.tryExport typeof<SymbolLoadMetadata> value world with
                            | Some value -> value :?> SymbolLoadMetadata
                            | None -> failwith "Invalid argument type for 'assetTags'; expecting a value convertable to SymbolLoadMetadata."
                        struct (value :: values, world))
                        struct ([], world)
                        list
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.tryGetSymbols implicitDelimiters assetTags world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpList<Symbol>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryGetSymbols' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let reloadSymbols world =
        let oldWorld = world
        try
            let result = World.reloadSymbols world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'reloadSymbols' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getOverlays world =
        let oldWorld = world
        try
            let result = World.getOverlays world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpMap<String, Overlay>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getOverlays' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let tryGetRoutedOverlayNameOpt dispatcherName world =
        let oldWorld = world
        try
            let dispatcherName =
                match ScriptingSystem.tryExport typeof<String> dispatcherName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'dispatcherName'; expecting a value convertable to String."
            let result = World.tryGetRoutedOverlayNameOpt dispatcherName world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<String>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryGetRoutedOverlayNameOpt' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let getEventFilter world =
        let oldWorld = world
        try
            let result = World.getEventFilter world
            let value = result
            let value = ScriptingSystem.tryImport typeof<EventFilter> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEventFilter' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let setEventFilter filter world =
        let oldWorld = world
        try
            let filter =
                match ScriptingSystem.tryExport typeof<EventFilter> filter world with
                | Some value -> value :?> EventFilter
                | None -> failwith "Invalid argument type for 'filter'; expecting a value convertable to Filter."
            let result = World.setEventFilter filter world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setEventFilter' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let trySetEditMode editMode world =
        let oldWorld = world
        try
            let editMode =
                match ScriptingSystem.tryExport typeof<String> editMode world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'editMode'; expecting a value convertable to String."
            let result = World.trySetEditMode editMode world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'trySetEditMode' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let tryMakeEmitter time lifeTimeOpt particleLifeTimeMaxOpt particleRate particleMax emitterStyle world =
        let oldWorld = world
        try
            let time =
                match ScriptingSystem.tryExport typeof<GameTime> time world with
                | Some value -> value :?> GameTime
                | None -> failwith "Invalid argument type for 'time'; expecting a value convertable to GameTime."
            let lifeTimeOpt =
                match ScriptingSystem.tryExport typeof<GameTime> lifeTimeOpt world with
                | Some value -> value :?> GameTime
                | None -> failwith "Invalid argument type for 'lifeTimeOpt'; expecting a value convertable to GameTime."
            let particleLifeTimeMaxOpt =
                match ScriptingSystem.tryExport typeof<GameTime> particleLifeTimeMaxOpt world with
                | Some value -> value :?> GameTime
                | None -> failwith "Invalid argument type for 'particleLifeTimeMaxOpt'; expecting a value convertable to GameTime."
            let particleRate =
                match ScriptingSystem.tryExport typeof<Single> particleRate world with
                | Some value -> value :?> Single
                | None -> failwith "Invalid argument type for 'particleRate'; expecting a value convertable to Single."
            let particleMax =
                match ScriptingSystem.tryExport typeof<Int32> particleMax world with
                | Some value -> value :?> Int32
                | None -> failwith "Invalid argument type for 'particleMax'; expecting a value convertable to Int32."
            let emitterStyle =
                match ScriptingSystem.tryExport typeof<String> emitterStyle world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'emitterStyle'; expecting a value convertable to String."
            let result = World.tryMakeEmitter time lifeTimeOpt particleLifeTimeMaxOpt particleRate particleMax emitterStyle world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Emitter>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryMakeEmitter' due to: " + scstring exn, ValueNone)
            struct (violation, World.choose oldWorld)

    let evalResolveBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|relation|] -> resolve relation world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalRelateBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|address|] -> relate address world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSelectScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|transitionState; screen|] -> selectScreen transitionState screen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryGetIsSelectedScreenIdlingBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> tryGetIsSelectedScreenIdling world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryGetIsSelectedScreenTransitioningBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> tryGetIsSelectedScreenTransitioning world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalIsSelectedScreenIdlingBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> isSelectedScreenIdling world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalIsSelectedScreenTransitioningBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> isSelectedScreenTransitioning world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryTransitionScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|destination|] -> tryTransitionScreen destination world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTransitionScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|destination|] -> transitionScreen destination world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetScreenSlideBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|slideDescriptor; destination; screen|] -> setScreenSlide slideDescriptor destination screen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateDissolveScreenFromGroupFile6Binding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|dispatcherName; nameOpt; dissolveDescriptor; songOpt; groupFilePath|] -> createDissolveScreenFromGroupFile6 dispatcherName nameOpt dissolveDescriptor songOpt groupFilePath world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateDissolveScreenFromGroupFileBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|nameOpt; dissolveDescriptor; songOpt; groupFilePath|] -> createDissolveScreenFromGroupFile nameOpt dissolveDescriptor songOpt groupFilePath world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateSlideScreen6Binding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|dispatcherName; nameOpt; slideDescriptor; destination|] -> createSlideScreen6 dispatcherName nameOpt slideDescriptor destination world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateSlideScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|nameOpt; slideDescriptor; destination|] -> createSlideScreen nameOpt slideDescriptor destination world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalReloadExistingAssetsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> reloadExistingAssets world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryReloadAssetsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> tryReloadAssets world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetCurrentSongOptBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getCurrentSongOpt world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetCurrentSongPositionBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getCurrentSongPosition world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetMasterAudioVolumeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getMasterAudioVolume world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetMasterSoundVolumeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getMasterSoundVolume world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetMasterSongVolumeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getMasterSongVolume world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetMasterAudioVolumeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|volume|] -> setMasterAudioVolume volume world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetMasterSoundVolumeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|volume|] -> setMasterSoundVolume volume world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetMasterSongVolumeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|volume|] -> setMasterSongVolume volume world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalPlaySongBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|fadeInTime; fadeOutTime; startTime; volume; song|] -> playSong fadeInTime fadeOutTime startTime volume song world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalPlaySoundBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|volume; sound|] -> playSound volume sound world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalFadeOutSongBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|fadeOutTime|] -> fadeOutSong fadeOutTime world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalStopSongBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> stopSong world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalLoadAudioPackageBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|packageName|] -> loadAudioPackage packageName world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalUnloadAudioPackageBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|packageName|] -> unloadAudioPackage packageName world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalReloadAudioAssetsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> reloadAudioAssets world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalLoadRenderPackage2dBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|packageName|] -> loadRenderPackage2d packageName world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalUnloadRenderPackage2dBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|packageName|] -> unloadRenderPackage2d packageName world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalReloadRenderAssets2dBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> reloadRenderAssets2d world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalReloadRenderAssets3dBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> reloadRenderAssets3d world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalLocalizeBodyShapeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|size; bodyShape|] -> localizeBodyShape size bodyShape world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetBodyExistsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|bodyId|] -> getBodyExists bodyId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetBodyContactNormalsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|bodyId|] -> getBodyContactNormals bodyId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetBodyLinearVelocityBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|bodyId|] -> getBodyLinearVelocity bodyId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetBodyToGroundContactNormalsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|bodyId|] -> getBodyToGroundContactNormals bodyId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetBodyToGroundContactNormalOptBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|bodyId|] -> getBodyToGroundContactNormalOpt bodyId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetBodyToGroundContactTangentOptBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|bodyId|] -> getBodyToGroundContactTangentOpt bodyId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalIsBodyOnGroundBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|bodyId|] -> isBodyOnGround bodyId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateBodyBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|is2d; bodyId; bodyProperties|] -> createBody is2d bodyId bodyProperties world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateBodiesBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|is2d; bodySource; bodiesProperties|] -> createBodies is2d bodySource bodiesProperties world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalDestroyBodyBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|is2d; bodyId|] -> destroyBody is2d bodyId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalDestroyBodiesBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|is2d; bodyIds|] -> destroyBodies is2d bodyIds world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateJointBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|is2d; jointSource; jointProperties|] -> createJoint is2d jointSource jointProperties world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateJointsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|is2d; jointSource; jointsProperties|] -> createJoints is2d jointSource jointsProperties world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalDestroyJointBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|is2d; jointId|] -> destroyJoint is2d jointId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalDestroyJointsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|is2d; jointIds|] -> destroyJoints is2d jointIds world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetBodyEnabledBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|enabled; bodyId|] -> setBodyEnabled enabled bodyId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetBodyCenterBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|center; bodyId|] -> setBodyCenter center bodyId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetBodyRotationBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|rotation; bodyId|] -> setBodyRotation rotation bodyId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetBodyLinearVelocityBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|linearVelocity; bodyId|] -> setBodyLinearVelocity linearVelocity bodyId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalApplyBodyLinearImpulseBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|linearImpulse; offset; bodyId|] -> applyBodyLinearImpulse linearImpulse offset bodyId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetBodyAngularVelocityBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|angularVelocity; bodyId|] -> setBodyAngularVelocity angularVelocity bodyId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalApplyBodyAngularImpulseBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|angularImpulse; bodyId|] -> applyBodyAngularImpulse angularImpulse bodyId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalApplyBodyForceBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|force; offset; bodyId|] -> applyBodyForce force offset bodyId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalApplyBodyTorqueBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|torque; bodyId|] -> applyBodyTorque torque bodyId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetBodyObservableBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|observable; bodyId|] -> setBodyObservable observable bodyId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalIsMouseButtonDownBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|mouseButton|] -> isMouseButtonDown mouseButton world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetMousePositionBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getMousePosition world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetMousePosition2dScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getMousePosition2dScreen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetMousePostion2dWorldBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|absolute|] -> getMousePostion2dWorld absolute world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetMousePosition3dScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getMousePosition3dScreen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetMouseRay3dWorldBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|absolute|] -> getMouseRay3dWorld absolute world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalIsKeyboardKeyDownBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|key|] -> isKeyboardKeyDown key world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalIsKeyboardKeyUpBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|key|] -> isKeyboardKeyUp key world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalIsKeyboardAltDownBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> isKeyboardAltDown world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalIsKeyboardAltUpBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> isKeyboardAltUp world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalIsKeyboardCtrlDownBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> isKeyboardCtrlDown world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalIsKeyboardCtrlUpBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> isKeyboardCtrlUp world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalIsKeyboardShiftDownBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> isKeyboardShiftDown world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalIsKeyboardShiftUpBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> isKeyboardShiftUp world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalDestroyImmediateBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|simulant|] -> destroyImmediate simulant world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalDestroyBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|simulant|] -> destroy simulant world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryGetParentBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|simulant|] -> tryGetParent simulant world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetParentBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|simulant|] -> getParent simulant world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetChildrenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|simulant|] -> getChildren simulant world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetExistsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|simulant|] -> getExists simulant world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalIsSelectedBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|simulant|] -> isSelected simulant world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetEntitiesFlattened0Binding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getEntitiesFlattened0 world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetGroups0Binding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getGroups0 world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalWriteGameToFileBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|filePath|] -> writeGameToFile filePath world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalReadGameFromFileBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|filePath|] -> readGameFromFile filePath world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetScreensBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getScreens world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetScreenDissolveBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|dissolveDescriptor; songOpt; screen|] -> setScreenDissolve dissolveDescriptor songOpt screen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalDestroyScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|screen|] -> destroyScreen screen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|dispatcherName; nameOpt|] -> createScreen dispatcherName nameOpt world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateDissolveScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|dispatcherName; nameOpt; dissolveDescriptor; songOpt|] -> createDissolveScreen dispatcherName nameOpt dissolveDescriptor songOpt world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalWriteScreenToFileBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|filePath; screen|] -> writeScreenToFile filePath screen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalReadScreenFromFileBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|filePath; nameOpt|] -> readScreenFromFile filePath nameOpt world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetGroupsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|screen|] -> getGroups screen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateGroupBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|dispatcherName; nameOpt; screen|] -> createGroup dispatcherName nameOpt screen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalDestroyGroupBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|group|] -> destroyGroup group world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalDestroyGroupsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|groups|] -> destroyGroups groups world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalWriteGroupToFileBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|filePath; group|] -> writeGroupToFile filePath group world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalReadGroupFromFileBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|filePath; nameOpt; screen|] -> readGroupFromFile filePath nameOpt screen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetEntitiesFlattenedBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|group|] -> getEntitiesFlattened group world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetEntitiesSovereignBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|group|] -> getEntitiesSovereign group world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalDestroyEntityBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|entity|] -> destroyEntity entity world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalDestroyEntitiesBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|entities|] -> destroyEntities entities world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryPickEntity2dBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|position; entities|] -> tryPickEntity2d position entities world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryPickEntity3dBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|position; entities|] -> tryPickEntity3d position entities world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalWriteEntityToFileBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|filePath; enity|] -> writeEntityToFile filePath enity world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalReadEntityFromFileBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|filePath; nameOpt; group|] -> readEntityFromFile filePath nameOpt group world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateEntityBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|dispatcherName; overlayDescriptor; surnames; group|] -> createEntity dispatcherName overlayDescriptor surnames group world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalRenameEntityBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|source; destination|] -> renameEntity source destination world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTrySetEntityOverlayNameOptBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|overlayNameOpt; entity|] -> trySetEntityOverlayNameOpt overlayNameOpt entity world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTrySetEntityFacetNamesBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|facetNames; entity|] -> trySetEntityFacetNames facetNames entity world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetEyeCenter2dBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getEyeCenter2d world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetEyeCenter2dBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|value|] -> setEyeCenter2d value world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetEyeSize2dBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getEyeSize2d world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetEyeSize2dBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|value|] -> setEyeSize2d value world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetEyeBounds2dBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getEyeBounds2d world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetEyeCenter3dBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getEyeCenter3d world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetEyeCenter3dBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|value|] -> setEyeCenter3d value world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetEyeRotation3dBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getEyeRotation3d world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetEyeRotation3dBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|value|] -> setEyeRotation3d value world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetEyeFrustum3dEnclosedBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getEyeFrustum3dEnclosed world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetEyeFrustum3dExposedBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getEyeFrustum3dExposed world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetEyeFrustum3dImposterBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getEyeFrustum3dImposter world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetLightBox3dBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getLightBox3d world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetOmniScreenOptBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getOmniScreenOpt world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetOmniScreenOptBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|value|] -> setOmniScreenOpt value world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetOmniScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getOmniScreen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetOmniScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|value|] -> setOmniScreen value world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalConstrainEyeBounds2dBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|bounds|] -> constrainEyeBounds2d bounds world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetSelectedScreenOptBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getSelectedScreenOpt world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetSelectedScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getSelectedScreen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetSelectedScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|value|] -> setSelectedScreen value world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetDesiredScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getDesiredScreen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetDesiredScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|value|] -> setDesiredScreen value world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetScreenTransitionDestinationOptBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getScreenTransitionDestinationOpt world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetScreenTransitionDestinationOptBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|value|] -> setScreenTransitionDestinationOpt value world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetViewBounds2dAbsoluteBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getViewBounds2dAbsolute world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetPlayBounds2dAbsoluteBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getPlayBounds2dAbsolute world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetViewBounds2dBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getViewBounds2d world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetPlayBounds2dBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getPlayBounds2d world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalIsBoundsInView2dBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|bounds|] -> isBoundsInView2d bounds world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetPlayBounds3dBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getPlayBounds3d world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalIsBoundsInView3dBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|light; presence; bounds|] -> isBoundsInView3d light presence bounds world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalIsBoundsInPlay3dBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|bounds|] -> isBoundsInPlay3d bounds world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryGetTextureSizeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|assetTag|] -> tryGetTextureSize assetTag world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetTextureSizeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|assetTag|] -> getTextureSize assetTag world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryGetTextureSizeFBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|assetTag|] -> tryGetTextureSizeF assetTag world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetTextureSizeFBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|assetTag|] -> getTextureSizeF assetTag world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetImperativeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getImperative world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetAccompaniedBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getAccompanied world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetUnaccompaniedBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getUnaccompanied world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetCollectionConfigBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getCollectionConfig world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetLivenessBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getLiveness world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetAdvancingBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|advancing|] -> setAdvancing advancing world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetAdvancingBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getAdvancing world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetHaltedBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getHalted world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetUpdateTimeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getUpdateTime world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetClockDeltaBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getClockDelta world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetClockTimeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getClockTime world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetGameDeltaBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getGameDelta world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetGameTimeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getGameTime world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalExitBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> exit world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryGetWindowFlagsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> tryGetWindowFlags world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryGetWindowMinimizedBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> tryGetWindowMinimized world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryGetWindowMaximizedBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> tryGetWindowMaximized world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryGetWindowFullScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> tryGetWindowFullScreen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTrySetWindowFullScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|fullScreen|] -> trySetWindowFullScreen fullScreen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryGetWindowSizeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> tryGetWindowSize world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetWindowSizeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getWindowSize world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetViewportBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getViewport world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetViewportOffsetBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getViewportOffset world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryLoadSymbolPackageBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|implicitDelimiters; packageName|] -> tryLoadSymbolPackage implicitDelimiters packageName world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalUnloadSymbolPackageBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|packageName|] -> unloadSymbolPackage packageName world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryGetSymbolBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|assetTag; metadata|] -> tryGetSymbol assetTag metadata world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryGetSymbolsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|implicitDelimiters; assetTags|] -> tryGetSymbols implicitDelimiters assetTags world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalReloadSymbolsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> reloadSymbols world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetOverlaysBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getOverlays world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryGetRoutedOverlayNameOptBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|dispatcherName|] -> tryGetRoutedOverlayNameOpt dispatcherName world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetEventFilterBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getEventFilter world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetEventFilterBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|filter|] -> setEventFilter filter world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTrySetEditModeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|editMode|] -> trySetEditMode editMode world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryMakeEmitterBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|time; lifeTimeOpt; particleLifeTimeMaxOpt; particleRate; particleMax; emitterStyle|] -> tryMakeEmitter time lifeTimeOpt particleLifeTimeMaxOpt particleRate particleMax emitterStyle world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, ValueNone)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let tryGetBinding fnName =
        match WorldScripting.Bindings.TryGetValue fnName with
        | (true, binding) -> Some binding
        | (false, _) -> None

    let init () =
        let bindings =
            [
             ("resolve", { Fn = evalResolveBinding; Pars = [|"relation"|]; DocOpt = None })
             ("relate", { Fn = evalRelateBinding; Pars = [|"address"|]; DocOpt = None })
             ("selectScreen", { Fn = evalSelectScreenBinding; Pars = [|"transitionState"; "screen"|]; DocOpt = None })
             ("tryGetIsSelectedScreenIdling", { Fn = evalTryGetIsSelectedScreenIdlingBinding; Pars = [||]; DocOpt = None })
             ("tryGetIsSelectedScreenTransitioning", { Fn = evalTryGetIsSelectedScreenTransitioningBinding; Pars = [||]; DocOpt = None })
             ("isSelectedScreenIdling", { Fn = evalIsSelectedScreenIdlingBinding; Pars = [||]; DocOpt = None })
             ("isSelectedScreenTransitioning", { Fn = evalIsSelectedScreenTransitioningBinding; Pars = [||]; DocOpt = None })
             ("tryTransitionScreen", { Fn = evalTryTransitionScreenBinding; Pars = [|"destination"|]; DocOpt = None })
             ("transitionScreen", { Fn = evalTransitionScreenBinding; Pars = [|"destination"|]; DocOpt = None })
             ("setScreenSlide", { Fn = evalSetScreenSlideBinding; Pars = [|"slideDescriptor"; "destination"; "screen"|]; DocOpt = None })
             ("createDissolveScreenFromGroupFile6", { Fn = evalCreateDissolveScreenFromGroupFile6Binding; Pars = [|"dispatcherName"; "nameOpt"; "dissolveDescriptor"; "songOpt"; "groupFilePath"|]; DocOpt = None })
             ("createDissolveScreenFromGroupFile", { Fn = evalCreateDissolveScreenFromGroupFileBinding; Pars = [|"nameOpt"; "dissolveDescriptor"; "songOpt"; "groupFilePath"|]; DocOpt = None })
             ("createSlideScreen6", { Fn = evalCreateSlideScreen6Binding; Pars = [|"dispatcherName"; "nameOpt"; "slideDescriptor"; "destination"|]; DocOpt = None })
             ("createSlideScreen", { Fn = evalCreateSlideScreenBinding; Pars = [|"nameOpt"; "slideDescriptor"; "destination"|]; DocOpt = None })
             ("reloadExistingAssets", { Fn = evalReloadExistingAssetsBinding; Pars = [||]; DocOpt = None })
             ("tryReloadAssets", { Fn = evalTryReloadAssetsBinding; Pars = [||]; DocOpt = None })
             ("getCurrentSongOpt", { Fn = evalGetCurrentSongOptBinding; Pars = [||]; DocOpt = None })
             ("getCurrentSongPosition", { Fn = evalGetCurrentSongPositionBinding; Pars = [||]; DocOpt = None })
             ("getMasterAudioVolume", { Fn = evalGetMasterAudioVolumeBinding; Pars = [||]; DocOpt = None })
             ("getMasterSoundVolume", { Fn = evalGetMasterSoundVolumeBinding; Pars = [||]; DocOpt = None })
             ("getMasterSongVolume", { Fn = evalGetMasterSongVolumeBinding; Pars = [||]; DocOpt = None })
             ("setMasterAudioVolume", { Fn = evalSetMasterAudioVolumeBinding; Pars = [|"volume"|]; DocOpt = None })
             ("setMasterSoundVolume", { Fn = evalSetMasterSoundVolumeBinding; Pars = [|"volume"|]; DocOpt = None })
             ("setMasterSongVolume", { Fn = evalSetMasterSongVolumeBinding; Pars = [|"volume"|]; DocOpt = None })
             ("playSong", { Fn = evalPlaySongBinding; Pars = [|"fadeInTime"; "fadeOutTime"; "startTime"; "volume"; "song"|]; DocOpt = None })
             ("playSound", { Fn = evalPlaySoundBinding; Pars = [|"volume"; "sound"|]; DocOpt = None })
             ("fadeOutSong", { Fn = evalFadeOutSongBinding; Pars = [|"fadeOutTime"|]; DocOpt = None })
             ("stopSong", { Fn = evalStopSongBinding; Pars = [||]; DocOpt = None })
             ("loadAudioPackage", { Fn = evalLoadAudioPackageBinding; Pars = [|"packageName"|]; DocOpt = None })
             ("unloadAudioPackage", { Fn = evalUnloadAudioPackageBinding; Pars = [|"packageName"|]; DocOpt = None })
             ("reloadAudioAssets", { Fn = evalReloadAudioAssetsBinding; Pars = [||]; DocOpt = None })
             ("loadRenderPackage2d", { Fn = evalLoadRenderPackage2dBinding; Pars = [|"packageName"|]; DocOpt = None })
             ("unloadRenderPackage2d", { Fn = evalUnloadRenderPackage2dBinding; Pars = [|"packageName"|]; DocOpt = None })
             ("reloadRenderAssets2d", { Fn = evalReloadRenderAssets2dBinding; Pars = [||]; DocOpt = None })
             ("reloadRenderAssets3d", { Fn = evalReloadRenderAssets3dBinding; Pars = [||]; DocOpt = None })
             ("localizeBodyShape", { Fn = evalLocalizeBodyShapeBinding; Pars = [|"size"; "bodyShape"|]; DocOpt = None })
             ("getBodyExists", { Fn = evalGetBodyExistsBinding; Pars = [|"bodyId"|]; DocOpt = None })
             ("getBodyContactNormals", { Fn = evalGetBodyContactNormalsBinding; Pars = [|"bodyId"|]; DocOpt = None })
             ("getBodyLinearVelocity", { Fn = evalGetBodyLinearVelocityBinding; Pars = [|"bodyId"|]; DocOpt = None })
             ("getBodyToGroundContactNormals", { Fn = evalGetBodyToGroundContactNormalsBinding; Pars = [|"bodyId"|]; DocOpt = None })
             ("getBodyToGroundContactNormalOpt", { Fn = evalGetBodyToGroundContactNormalOptBinding; Pars = [|"bodyId"|]; DocOpt = None })
             ("getBodyToGroundContactTangentOpt", { Fn = evalGetBodyToGroundContactTangentOptBinding; Pars = [|"bodyId"|]; DocOpt = None })
             ("isBodyOnGround", { Fn = evalIsBodyOnGroundBinding; Pars = [|"bodyId"|]; DocOpt = None })
             ("createBody", { Fn = evalCreateBodyBinding; Pars = [|"is2d"; "bodyId"; "bodyProperties"|]; DocOpt = None })
             ("createBodies", { Fn = evalCreateBodiesBinding; Pars = [|"is2d"; "bodySource"; "bodiesProperties"|]; DocOpt = None })
             ("destroyBody", { Fn = evalDestroyBodyBinding; Pars = [|"is2d"; "bodyId"|]; DocOpt = None })
             ("destroyBodies", { Fn = evalDestroyBodiesBinding; Pars = [|"is2d"; "bodyIds"|]; DocOpt = None })
             ("createJoint", { Fn = evalCreateJointBinding; Pars = [|"is2d"; "jointSource"; "jointProperties"|]; DocOpt = None })
             ("createJoints", { Fn = evalCreateJointsBinding; Pars = [|"is2d"; "jointSource"; "jointsProperties"|]; DocOpt = None })
             ("destroyJoint", { Fn = evalDestroyJointBinding; Pars = [|"is2d"; "jointId"|]; DocOpt = None })
             ("destroyJoints", { Fn = evalDestroyJointsBinding; Pars = [|"is2d"; "jointIds"|]; DocOpt = None })
             ("setBodyEnabled", { Fn = evalSetBodyEnabledBinding; Pars = [|"enabled"; "bodyId"|]; DocOpt = None })
             ("setBodyCenter", { Fn = evalSetBodyCenterBinding; Pars = [|"center"; "bodyId"|]; DocOpt = None })
             ("setBodyRotation", { Fn = evalSetBodyRotationBinding; Pars = [|"rotation"; "bodyId"|]; DocOpt = None })
             ("setBodyLinearVelocity", { Fn = evalSetBodyLinearVelocityBinding; Pars = [|"linearVelocity"; "bodyId"|]; DocOpt = None })
             ("applyBodyLinearImpulse", { Fn = evalApplyBodyLinearImpulseBinding; Pars = [|"linearImpulse"; "offset"; "bodyId"|]; DocOpt = None })
             ("setBodyAngularVelocity", { Fn = evalSetBodyAngularVelocityBinding; Pars = [|"angularVelocity"; "bodyId"|]; DocOpt = None })
             ("applyBodyAngularImpulse", { Fn = evalApplyBodyAngularImpulseBinding; Pars = [|"angularImpulse"; "bodyId"|]; DocOpt = None })
             ("applyBodyForce", { Fn = evalApplyBodyForceBinding; Pars = [|"force"; "offset"; "bodyId"|]; DocOpt = None })
             ("applyBodyTorque", { Fn = evalApplyBodyTorqueBinding; Pars = [|"torque"; "bodyId"|]; DocOpt = None })
             ("setBodyObservable", { Fn = evalSetBodyObservableBinding; Pars = [|"observable"; "bodyId"|]; DocOpt = None })
             ("isMouseButtonDown", { Fn = evalIsMouseButtonDownBinding; Pars = [|"mouseButton"|]; DocOpt = None })
             ("getMousePosition", { Fn = evalGetMousePositionBinding; Pars = [||]; DocOpt = None })
             ("getMousePosition2dScreen", { Fn = evalGetMousePosition2dScreenBinding; Pars = [||]; DocOpt = None })
             ("getMousePostion2dWorld", { Fn = evalGetMousePostion2dWorldBinding; Pars = [|"absolute"|]; DocOpt = None })
             ("getMousePosition3dScreen", { Fn = evalGetMousePosition3dScreenBinding; Pars = [||]; DocOpt = None })
             ("getMouseRay3dWorld", { Fn = evalGetMouseRay3dWorldBinding; Pars = [|"absolute"|]; DocOpt = None })
             ("isKeyboardKeyDown", { Fn = evalIsKeyboardKeyDownBinding; Pars = [|"key"|]; DocOpt = None })
             ("isKeyboardKeyUp", { Fn = evalIsKeyboardKeyUpBinding; Pars = [|"key"|]; DocOpt = None })
             ("isKeyboardAltDown", { Fn = evalIsKeyboardAltDownBinding; Pars = [||]; DocOpt = None })
             ("isKeyboardAltUp", { Fn = evalIsKeyboardAltUpBinding; Pars = [||]; DocOpt = None })
             ("isKeyboardCtrlDown", { Fn = evalIsKeyboardCtrlDownBinding; Pars = [||]; DocOpt = None })
             ("isKeyboardCtrlUp", { Fn = evalIsKeyboardCtrlUpBinding; Pars = [||]; DocOpt = None })
             ("isKeyboardShiftDown", { Fn = evalIsKeyboardShiftDownBinding; Pars = [||]; DocOpt = None })
             ("isKeyboardShiftUp", { Fn = evalIsKeyboardShiftUpBinding; Pars = [||]; DocOpt = None })
             ("destroyImmediate", { Fn = evalDestroyImmediateBinding; Pars = [|"simulant"|]; DocOpt = None })
             ("destroy", { Fn = evalDestroyBinding; Pars = [|"simulant"|]; DocOpt = None })
             ("tryGetParent", { Fn = evalTryGetParentBinding; Pars = [|"simulant"|]; DocOpt = None })
             ("getParent", { Fn = evalGetParentBinding; Pars = [|"simulant"|]; DocOpt = None })
             ("getChildren", { Fn = evalGetChildrenBinding; Pars = [|"simulant"|]; DocOpt = None })
             ("getExists", { Fn = evalGetExistsBinding; Pars = [|"simulant"|]; DocOpt = None })
             ("isSelected", { Fn = evalIsSelectedBinding; Pars = [|"simulant"|]; DocOpt = None })
             ("getEntitiesFlattened0", { Fn = evalGetEntitiesFlattened0Binding; Pars = [||]; DocOpt = None })
             ("getGroups0", { Fn = evalGetGroups0Binding; Pars = [||]; DocOpt = None })
             ("writeGameToFile", { Fn = evalWriteGameToFileBinding; Pars = [|"filePath"|]; DocOpt = None })
             ("readGameFromFile", { Fn = evalReadGameFromFileBinding; Pars = [|"filePath"|]; DocOpt = None })
             ("getScreens", { Fn = evalGetScreensBinding; Pars = [||]; DocOpt = None })
             ("setScreenDissolve", { Fn = evalSetScreenDissolveBinding; Pars = [|"dissolveDescriptor"; "songOpt"; "screen"|]; DocOpt = None })
             ("destroyScreen", { Fn = evalDestroyScreenBinding; Pars = [|"screen"|]; DocOpt = None })
             ("createScreen", { Fn = evalCreateScreenBinding; Pars = [|"dispatcherName"; "nameOpt"|]; DocOpt = None })
             ("createDissolveScreen", { Fn = evalCreateDissolveScreenBinding; Pars = [|"dispatcherName"; "nameOpt"; "dissolveDescriptor"; "songOpt"|]; DocOpt = None })
             ("writeScreenToFile", { Fn = evalWriteScreenToFileBinding; Pars = [|"filePath"; "screen"|]; DocOpt = None })
             ("readScreenFromFile", { Fn = evalReadScreenFromFileBinding; Pars = [|"filePath"; "nameOpt"|]; DocOpt = None })
             ("getGroups", { Fn = evalGetGroupsBinding; Pars = [|"screen"|]; DocOpt = None })
             ("createGroup", { Fn = evalCreateGroupBinding; Pars = [|"dispatcherName"; "nameOpt"; "screen"|]; DocOpt = None })
             ("destroyGroup", { Fn = evalDestroyGroupBinding; Pars = [|"group"|]; DocOpt = None })
             ("destroyGroups", { Fn = evalDestroyGroupsBinding; Pars = [|"groups"|]; DocOpt = None })
             ("writeGroupToFile", { Fn = evalWriteGroupToFileBinding; Pars = [|"filePath"; "group"|]; DocOpt = None })
             ("readGroupFromFile", { Fn = evalReadGroupFromFileBinding; Pars = [|"filePath"; "nameOpt"; "screen"|]; DocOpt = None })
             ("getEntitiesFlattened", { Fn = evalGetEntitiesFlattenedBinding; Pars = [|"group"|]; DocOpt = None })
             ("getEntitiesSovereign", { Fn = evalGetEntitiesSovereignBinding; Pars = [|"group"|]; DocOpt = None })
             ("destroyEntity", { Fn = evalDestroyEntityBinding; Pars = [|"entity"|]; DocOpt = None })
             ("destroyEntities", { Fn = evalDestroyEntitiesBinding; Pars = [|"entities"|]; DocOpt = None })
             ("tryPickEntity2d", { Fn = evalTryPickEntity2dBinding; Pars = [|"position"; "entities"|]; DocOpt = None })
             ("tryPickEntity3d", { Fn = evalTryPickEntity3dBinding; Pars = [|"position"; "entities"|]; DocOpt = None })
             ("writeEntityToFile", { Fn = evalWriteEntityToFileBinding; Pars = [|"filePath"; "enity"|]; DocOpt = None })
             ("readEntityFromFile", { Fn = evalReadEntityFromFileBinding; Pars = [|"filePath"; "nameOpt"; "group"|]; DocOpt = None })
             ("createEntity", { Fn = evalCreateEntityBinding; Pars = [|"dispatcherName"; "overlayDescriptor"; "surnames"; "group"|]; DocOpt = None })
             ("renameEntity", { Fn = evalRenameEntityBinding; Pars = [|"source"; "destination"|]; DocOpt = None })
             ("trySetEntityOverlayNameOpt", { Fn = evalTrySetEntityOverlayNameOptBinding; Pars = [|"overlayNameOpt"; "entity"|]; DocOpt = None })
             ("trySetEntityFacetNames", { Fn = evalTrySetEntityFacetNamesBinding; Pars = [|"facetNames"; "entity"|]; DocOpt = None })
             ("getEyeCenter2d", { Fn = evalGetEyeCenter2dBinding; Pars = [||]; DocOpt = None })
             ("setEyeCenter2d", { Fn = evalSetEyeCenter2dBinding; Pars = [|"value"|]; DocOpt = None })
             ("getEyeSize2d", { Fn = evalGetEyeSize2dBinding; Pars = [||]; DocOpt = None })
             ("setEyeSize2d", { Fn = evalSetEyeSize2dBinding; Pars = [|"value"|]; DocOpt = None })
             ("getEyeBounds2d", { Fn = evalGetEyeBounds2dBinding; Pars = [||]; DocOpt = None })
             ("getEyeCenter3d", { Fn = evalGetEyeCenter3dBinding; Pars = [||]; DocOpt = None })
             ("setEyeCenter3d", { Fn = evalSetEyeCenter3dBinding; Pars = [|"value"|]; DocOpt = None })
             ("getEyeRotation3d", { Fn = evalGetEyeRotation3dBinding; Pars = [||]; DocOpt = None })
             ("setEyeRotation3d", { Fn = evalSetEyeRotation3dBinding; Pars = [|"value"|]; DocOpt = None })
             ("getEyeFrustum3dEnclosed", { Fn = evalGetEyeFrustum3dEnclosedBinding; Pars = [||]; DocOpt = None })
             ("getEyeFrustum3dExposed", { Fn = evalGetEyeFrustum3dExposedBinding; Pars = [||]; DocOpt = None })
             ("getEyeFrustum3dImposter", { Fn = evalGetEyeFrustum3dImposterBinding; Pars = [||]; DocOpt = None })
             ("getLightBox3d", { Fn = evalGetLightBox3dBinding; Pars = [||]; DocOpt = None })
             ("getOmniScreenOpt", { Fn = evalGetOmniScreenOptBinding; Pars = [||]; DocOpt = None })
             ("setOmniScreenOpt", { Fn = evalSetOmniScreenOptBinding; Pars = [|"value"|]; DocOpt = None })
             ("getOmniScreen", { Fn = evalGetOmniScreenBinding; Pars = [||]; DocOpt = None })
             ("setOmniScreen", { Fn = evalSetOmniScreenBinding; Pars = [|"value"|]; DocOpt = None })
             ("constrainEyeBounds2d", { Fn = evalConstrainEyeBounds2dBinding; Pars = [|"bounds"|]; DocOpt = None })
             ("getSelectedScreenOpt", { Fn = evalGetSelectedScreenOptBinding; Pars = [||]; DocOpt = None })
             ("getSelectedScreen", { Fn = evalGetSelectedScreenBinding; Pars = [||]; DocOpt = None })
             ("setSelectedScreen", { Fn = evalSetSelectedScreenBinding; Pars = [|"value"|]; DocOpt = None })
             ("getDesiredScreen", { Fn = evalGetDesiredScreenBinding; Pars = [||]; DocOpt = None })
             ("setDesiredScreen", { Fn = evalSetDesiredScreenBinding; Pars = [|"value"|]; DocOpt = None })
             ("getScreenTransitionDestinationOpt", { Fn = evalGetScreenTransitionDestinationOptBinding; Pars = [||]; DocOpt = None })
             ("setScreenTransitionDestinationOpt", { Fn = evalSetScreenTransitionDestinationOptBinding; Pars = [|"value"|]; DocOpt = None })
             ("getViewBounds2dAbsolute", { Fn = evalGetViewBounds2dAbsoluteBinding; Pars = [||]; DocOpt = None })
             ("getPlayBounds2dAbsolute", { Fn = evalGetPlayBounds2dAbsoluteBinding; Pars = [||]; DocOpt = None })
             ("getViewBounds2d", { Fn = evalGetViewBounds2dBinding; Pars = [||]; DocOpt = None })
             ("getPlayBounds2d", { Fn = evalGetPlayBounds2dBinding; Pars = [||]; DocOpt = None })
             ("isBoundsInView2d", { Fn = evalIsBoundsInView2dBinding; Pars = [|"bounds"|]; DocOpt = None })
             ("getPlayBounds3d", { Fn = evalGetPlayBounds3dBinding; Pars = [||]; DocOpt = None })
             ("isBoundsInView3d", { Fn = evalIsBoundsInView3dBinding; Pars = [|"light"; "presence"; "bounds"|]; DocOpt = None })
             ("isBoundsInPlay3d", { Fn = evalIsBoundsInPlay3dBinding; Pars = [|"bounds"|]; DocOpt = None })
             ("tryGetTextureSize", { Fn = evalTryGetTextureSizeBinding; Pars = [|"assetTag"|]; DocOpt = None })
             ("getTextureSize", { Fn = evalGetTextureSizeBinding; Pars = [|"assetTag"|]; DocOpt = None })
             ("tryGetTextureSizeF", { Fn = evalTryGetTextureSizeFBinding; Pars = [|"assetTag"|]; DocOpt = None })
             ("getTextureSizeF", { Fn = evalGetTextureSizeFBinding; Pars = [|"assetTag"|]; DocOpt = None })
             ("getImperative", { Fn = evalGetImperativeBinding; Pars = [||]; DocOpt = None })
             ("getAccompanied", { Fn = evalGetAccompaniedBinding; Pars = [||]; DocOpt = None })
             ("getUnaccompanied", { Fn = evalGetUnaccompaniedBinding; Pars = [||]; DocOpt = None })
             ("getCollectionConfig", { Fn = evalGetCollectionConfigBinding; Pars = [||]; DocOpt = None })
             ("getLiveness", { Fn = evalGetLivenessBinding; Pars = [||]; DocOpt = None })
             ("setAdvancing", { Fn = evalSetAdvancingBinding; Pars = [|"advancing"|]; DocOpt = None })
             ("getAdvancing", { Fn = evalGetAdvancingBinding; Pars = [||]; DocOpt = None })
             ("getHalted", { Fn = evalGetHaltedBinding; Pars = [||]; DocOpt = None })
             ("getUpdateTime", { Fn = evalGetUpdateTimeBinding; Pars = [||]; DocOpt = None })
             ("getClockDelta", { Fn = evalGetClockDeltaBinding; Pars = [||]; DocOpt = None })
             ("getClockTime", { Fn = evalGetClockTimeBinding; Pars = [||]; DocOpt = None })
             ("getGameDelta", { Fn = evalGetGameDeltaBinding; Pars = [||]; DocOpt = None })
             ("getGameTime", { Fn = evalGetGameTimeBinding; Pars = [||]; DocOpt = None })
             ("exit", { Fn = evalExitBinding; Pars = [||]; DocOpt = None })
             ("tryGetWindowFlags", { Fn = evalTryGetWindowFlagsBinding; Pars = [||]; DocOpt = None })
             ("tryGetWindowMinimized", { Fn = evalTryGetWindowMinimizedBinding; Pars = [||]; DocOpt = None })
             ("tryGetWindowMaximized", { Fn = evalTryGetWindowMaximizedBinding; Pars = [||]; DocOpt = None })
             ("tryGetWindowFullScreen", { Fn = evalTryGetWindowFullScreenBinding; Pars = [||]; DocOpt = None })
             ("trySetWindowFullScreen", { Fn = evalTrySetWindowFullScreenBinding; Pars = [|"fullScreen"|]; DocOpt = None })
             ("tryGetWindowSize", { Fn = evalTryGetWindowSizeBinding; Pars = [||]; DocOpt = None })
             ("getWindowSize", { Fn = evalGetWindowSizeBinding; Pars = [||]; DocOpt = None })
             ("getViewport", { Fn = evalGetViewportBinding; Pars = [||]; DocOpt = None })
             ("getViewportOffset", { Fn = evalGetViewportOffsetBinding; Pars = [||]; DocOpt = None })
             ("tryLoadSymbolPackage", { Fn = evalTryLoadSymbolPackageBinding; Pars = [|"implicitDelimiters"; "packageName"|]; DocOpt = None })
             ("unloadSymbolPackage", { Fn = evalUnloadSymbolPackageBinding; Pars = [|"packageName"|]; DocOpt = None })
             ("tryGetSymbol", { Fn = evalTryGetSymbolBinding; Pars = [|"assetTag"; "metadata"|]; DocOpt = None })
             ("tryGetSymbols", { Fn = evalTryGetSymbolsBinding; Pars = [|"implicitDelimiters"; "assetTags"|]; DocOpt = None })
             ("reloadSymbols", { Fn = evalReloadSymbolsBinding; Pars = [||]; DocOpt = None })
             ("getOverlays", { Fn = evalGetOverlaysBinding; Pars = [||]; DocOpt = None })
             ("tryGetRoutedOverlayNameOpt", { Fn = evalTryGetRoutedOverlayNameOptBinding; Pars = [|"dispatcherName"|]; DocOpt = None })
             ("getEventFilter", { Fn = evalGetEventFilterBinding; Pars = [||]; DocOpt = None })
             ("setEventFilter", { Fn = evalSetEventFilterBinding; Pars = [|"filter"|]; DocOpt = None })
             ("trySetEditMode", { Fn = evalTrySetEditModeBinding; Pars = [|"editMode"|]; DocOpt = None })
             ("tryMakeEmitter", { Fn = evalTryMakeEmitterBinding; Pars = [|"time"; "lifeTimeOpt"; "particleLifeTimeMaxOpt"; "particleRate"; "particleMax"; "emitterStyle"|]; DocOpt = None })
            ] |>
            dictPlus StringComparer.Ordinal
        WorldScripting.Bindings <- bindings
