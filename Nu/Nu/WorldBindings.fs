// Nu Game Engine.
// Copyright (C) Bryan Edds, 2013-2020.

//*********************************************************************************************//
//                                                                                             //
// NOTE: This code is GENERATED by 'GenerateWorldBindings.fsx'! Do NOT edit this code by hand! //
//                                                                                             //
//*********************************************************************************************//

namespace Nu
open System
open System.Numerics
open Prime
open Nu

[<RequireQualifiedAccess>]
module WorldBindings =

    let [<Literal>] BindingKeywords =
        "v2 v4 v2i v4i color get getAsStream set setAsStream update streamEvent stream bind self parent grandparent game toData monitor " +
        "resolve relate selectScreen tryGetIsSelectedScreenIdling tryGetIsSelectedScreenTransitioning " +
        "isSelectedScreenIdling isSelectedScreenTransitioning tryTransitionScreen transitionScreen " +
        "setScreenSplash createDissolveScreenFromGroupFile6 createDissolveScreenFromGroupFile createSplashScreen6 " +
        "createSplashScreen reloadExistingAssets tryReloadAssets getCurrentSongOpt " +
        "getCurrentSongPosition getMasterAudioVolume getMasterSoundVolume getMasterSongVolume " +
        "setMasterAudioVolume setMasterSoundVolume setMasterSongVolume playSong " +
        "playSong6 playSound playSound3 fadeOutSong " +
        "stopSong hintAudioPackageUse hintAudioPackageDisuse reloadAudioAssets " +
        "hintRenderPackageUse hintRenderPackageDisuse reloadRenderAssets bodyExists " +
        "getBodyContactNormals getBodyLinearVelocity getBodyToGroundContactNormals getBodyToGroundContactNormalOpt " +
        "getBodyToGroundContactTangentOpt isBodyOnGround createBody createBodies " +
        "destroyBody destroyBodies createJoint createJoints " +
        "destroyJoint destroyJoints setBodyEnabled setBodyPosition " +
        "setBodyRotation setBodyLinearVelocity applyBodyLinearImpulse setBodyAngularVelocity " +
        "applyBodyAngularImpulse applyBodyForce localizeBodyShape isMouseButtonDown " +
        "getMousePosition isKeyboardKeyDown expandContent destroyImmediate " +
        "destroy tryGetParent getParent getChildren " +
        "getExists isSelected ignorePropertyBindings getEntities0 " +
        "getGroups0 writeGameToFile readGameFromFile getScreens " +
        "setScreenDissolve destroyScreen createScreen createDissolveScreen " +
        "writeScreenToFile readScreenFromFile getGroups createGroup " +
        "destroyGroup destroyGroups writeGroupToFile readGroupFromFile " +
        "getEntitiesFlattened getEntities getEntitiesSovereign destroyEntity " +
        "destroyEntities tryPickEntity writeEntityToFile readEntityFromFile " +
        "createEntity renameEntity trySetEntityOverlayNameOpt trySetEntityFacetNames " +
        "getEyePosition setEyePosition getEyeSize getEyeMargin " +
        "setEyeSize getEyeBounds getOmniScreenOpt setOmniScreenOpt " +
        "getOmniScreen setOmniScreen getSelectedScreenOpt constrainEyeBounds " +
        "getSelectedScreen setSelectedScreen getViewBoundsRelative getViewBoundsAbsolute " +
        "getViewBounds isBoundsInView mouseToScreen mouseToWorld " +
        "mouseToEntity getImperative getStandAlone getCollectionConfig " +
        "getLiveness getUpdateRate setUpdateRate isAdvancing " +
        "getUpdateTime getClockDelta exit tryGetTextureSize " +
        "getTextureSize tryGetTextureSizeF getTextureSizeF reloadSymbols"

    let resolve relation world =
        let oldWorld = world
        try
            let relation =
                match ScriptingSystem.tryExport typeof<Relation<Object>> relation world with
                | Some value -> value :?> Relation<Object>
                | None -> failwith "Invalid argument type for 'relation'; expecting a value convertable to Relation`1."
            let result = World.resolveGeneralized relation world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Address<Object>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'resolve' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let relate address world =
        let oldWorld = world
        try
            let struct (address, world) =
                let context = World.getScriptContext world
                match World.evalInternal address world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Address must be either a String or Keyword."
            let result = World.relateGeneralized address world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Relation<Object>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'relate' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let selectScreen transitionState screen world =
        let oldWorld = world
        try
            let transitionState =
                match ScriptingSystem.tryExport typeof<TransitionState> transitionState world with
                | Some value -> value :?> TransitionState
                | None -> failwith "Invalid argument type for 'transitionState'; expecting a value convertable to TransitionState."
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.selectScreen transitionState screen world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'selectScreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let tryGetIsSelectedScreenIdling world =
        let oldWorld = world
        try
            let result = World.tryGetIsSelectedScreenIdling world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Boolean>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryGetIsSelectedScreenIdling' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let tryGetIsSelectedScreenTransitioning world =
        let oldWorld = world
        try
            let result = World.tryGetIsSelectedScreenTransitioning world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Boolean>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryGetIsSelectedScreenTransitioning' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let isSelectedScreenIdling world =
        let oldWorld = world
        try
            let result = World.isSelectedScreenIdling world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isSelectedScreenIdling' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let isSelectedScreenTransitioning world =
        let oldWorld = world
        try
            let result = World.isSelectedScreenTransitioning world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isSelectedScreenTransitioning' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let tryTransitionScreen destination world =
        let oldWorld = world
        try
            let struct (destination, world) =
                let context = World.getScriptContext world
                match World.evalInternal destination world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.tryTransitionScreen destination world
            let (value, world) = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryTransitionScreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let transitionScreen destination world =
        let oldWorld = world
        try
            let struct (destination, world) =
                let context = World.getScriptContext world
                match World.evalInternal destination world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.transitionScreen destination world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'transitionScreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setScreenSplash splashDescriptor destination screen world =
        let oldWorld = world
        try
            let splashDescriptor =
                match ScriptingSystem.tryExport typeof<SplashDescriptor> splashDescriptor world with
                | Some value -> value :?> SplashDescriptor
                | None -> failwith "Invalid argument type for 'splashDescriptor'; expecting a value convertable to SplashDescriptor."
            let struct (destination, world) =
                let context = World.getScriptContext world
                match World.evalInternal destination world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.setScreenSplash splashDescriptor destination screen world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setScreenSplash' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let createDissolveScreenFromGroupFile6 dispatcherName nameOpt dissolveDescriptor songOpt groupFilePath world =
        let oldWorld = world
        try
            let dispatcherName =
                match ScriptingSystem.tryExport typeof<String> dispatcherName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'dispatcherName'; expecting a value convertable to String."
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let dissolveDescriptor =
                match ScriptingSystem.tryExport typeof<DissolveDescriptor> dissolveDescriptor world with
                | Some value -> value :?> DissolveDescriptor
                | None -> failwith "Invalid argument type for 'dissolveDescriptor'; expecting a value convertable to DissolveDescriptor."
            let songOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<SongDescriptor>> songOpt world with
                | Some value -> value :?> FSharpOption<SongDescriptor>
                | None -> failwith "Invalid argument type for 'songOpt'; expecting a value convertable to FSharpOption`1."
            let groupFilePath =
                match ScriptingSystem.tryExport typeof<String> groupFilePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'groupFilePath'; expecting a value convertable to String."
            let result = World.createDissolveScreenFromGroupFile6 dispatcherName nameOpt dissolveDescriptor songOpt groupFilePath world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createDissolveScreenFromGroupFile6' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let createDissolveScreenFromGroupFile nameOpt dissolveDescriptor songOpt groupFilePath world =
        let oldWorld = world
        try
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let dissolveDescriptor =
                match ScriptingSystem.tryExport typeof<DissolveDescriptor> dissolveDescriptor world with
                | Some value -> value :?> DissolveDescriptor
                | None -> failwith "Invalid argument type for 'dissolveDescriptor'; expecting a value convertable to DissolveDescriptor."
            let songOpt =
                match ScriptingSystem.tryExport typeof<String> songOpt world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'songOpt'; expecting a value convertable to String."
            let groupFilePath =
                match ScriptingSystem.tryExport typeof<FSharpOption<SongDescriptor>> groupFilePath world with
                | Some value -> value :?> FSharpOption<SongDescriptor>
                | None -> failwith "Invalid argument type for 'groupFilePath'; expecting a value convertable to FSharpOption`1."
            let result = World.createDissolveScreenFromGroupFile nameOpt dissolveDescriptor songOpt groupFilePath world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createDissolveScreenFromGroupFile' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let createSplashScreen6 dispatcherName nameOpt splashDescriptor destination world =
        let oldWorld = world
        try
            let dispatcherName =
                match ScriptingSystem.tryExport typeof<String> dispatcherName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'dispatcherName'; expecting a value convertable to String."
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let splashDescriptor =
                match ScriptingSystem.tryExport typeof<SplashDescriptor> splashDescriptor world with
                | Some value -> value :?> SplashDescriptor
                | None -> failwith "Invalid argument type for 'splashDescriptor'; expecting a value convertable to SplashDescriptor."
            let struct (destination, world) =
                let context = World.getScriptContext world
                match World.evalInternal destination world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.createSplashScreen6 dispatcherName nameOpt splashDescriptor destination world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createSplashScreen6' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let createSplashScreen nameOpt splashDescriptor destination world =
        let oldWorld = world
        try
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let splashDescriptor =
                match ScriptingSystem.tryExport typeof<SplashDescriptor> splashDescriptor world with
                | Some value -> value :?> SplashDescriptor
                | None -> failwith "Invalid argument type for 'splashDescriptor'; expecting a value convertable to SplashDescriptor."
            let struct (destination, world) =
                let context = World.getScriptContext world
                match World.evalInternal destination world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.createSplashScreen nameOpt splashDescriptor destination world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createSplashScreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let reloadExistingAssets world =
        let oldWorld = world
        try
            let result = World.reloadExistingAssets world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'reloadExistingAssets' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let tryReloadAssets world =
        let oldWorld = world
        try
            let result = World.tryReloadAssets world
            let (value, world) = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryReloadAssets' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getCurrentSongOpt world =
        let oldWorld = world
        try
            let result = World.getCurrentSongOpt world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<SongDescriptor>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getCurrentSongOpt' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getCurrentSongPosition world =
        let oldWorld = world
        try
            let result = World.getCurrentSongPosition world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Double> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getCurrentSongPosition' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getMasterAudioVolume world =
        let oldWorld = world
        try
            let result = World.getMasterAudioVolume world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Single> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getMasterAudioVolume' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getMasterSoundVolume world =
        let oldWorld = world
        try
            let result = World.getMasterSoundVolume world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Single> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getMasterSoundVolume' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getMasterSongVolume world =
        let oldWorld = world
        try
            let result = World.getMasterSongVolume world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Single> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getMasterSongVolume' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setMasterAudioVolume volume world =
        let oldWorld = world
        try
            let volume =
                match ScriptingSystem.tryExport typeof<Single> volume world with
                | Some value -> value :?> Single
                | None -> failwith "Invalid argument type for 'volume'; expecting a value convertable to Single."
            let result = World.setMasterAudioVolume volume world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setMasterAudioVolume' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setMasterSoundVolume volume world =
        let oldWorld = world
        try
            let volume =
                match ScriptingSystem.tryExport typeof<Single> volume world with
                | Some value -> value :?> Single
                | None -> failwith "Invalid argument type for 'volume'; expecting a value convertable to Single."
            let result = World.setMasterSoundVolume volume world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setMasterSoundVolume' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setMasterSongVolume volume world =
        let oldWorld = world
        try
            let volume =
                match ScriptingSystem.tryExport typeof<Single> volume world with
                | Some value -> value :?> Single
                | None -> failwith "Invalid argument type for 'volume'; expecting a value convertable to Single."
            let result = World.setMasterSongVolume volume world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setMasterSongVolume' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let playSong timeToFadeInSongMs timeToFadeOutSongMs volume start song world =
        let oldWorld = world
        try
            let timeToFadeInSongMs =
                match ScriptingSystem.tryExport typeof<Int32> timeToFadeInSongMs world with
                | Some value -> value :?> Int32
                | None -> failwith "Invalid argument type for 'timeToFadeInSongMs'; expecting a value convertable to Int32."
            let timeToFadeOutSongMs =
                match ScriptingSystem.tryExport typeof<Int32> timeToFadeOutSongMs world with
                | Some value -> value :?> Int32
                | None -> failwith "Invalid argument type for 'timeToFadeOutSongMs'; expecting a value convertable to Int32."
            let volume =
                match ScriptingSystem.tryExport typeof<Single> volume world with
                | Some value -> value :?> Single
                | None -> failwith "Invalid argument type for 'volume'; expecting a value convertable to Single."
            let start =
                match ScriptingSystem.tryExport typeof<Double> start world with
                | Some value -> value :?> Double
                | None -> failwith "Invalid argument type for 'start'; expecting a value convertable to Double."
            let song =
                match ScriptingSystem.tryExport typeof<AssetTag<Song>> song world with
                | Some value -> value :?> AssetTag<Song>
                | None -> failwith "Invalid argument type for 'song'; expecting a value convertable to AssetTag`1."
            let result = World.playSong timeToFadeInSongMs timeToFadeOutSongMs volume start song world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'playSong' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let playSong6 timeToFadeInSongMs timeToFadeOutSongMs volume start songPackageName songAssetName world =
        let oldWorld = world
        try
            let timeToFadeInSongMs =
                match ScriptingSystem.tryExport typeof<Int32> timeToFadeInSongMs world with
                | Some value -> value :?> Int32
                | None -> failwith "Invalid argument type for 'timeToFadeInSongMs'; expecting a value convertable to Int32."
            let timeToFadeOutSongMs =
                match ScriptingSystem.tryExport typeof<Int32> timeToFadeOutSongMs world with
                | Some value -> value :?> Int32
                | None -> failwith "Invalid argument type for 'timeToFadeOutSongMs'; expecting a value convertable to Int32."
            let volume =
                match ScriptingSystem.tryExport typeof<Single> volume world with
                | Some value -> value :?> Single
                | None -> failwith "Invalid argument type for 'volume'; expecting a value convertable to Single."
            let start =
                match ScriptingSystem.tryExport typeof<Double> start world with
                | Some value -> value :?> Double
                | None -> failwith "Invalid argument type for 'start'; expecting a value convertable to Double."
            let songPackageName =
                match ScriptingSystem.tryExport typeof<String> songPackageName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'songPackageName'; expecting a value convertable to String."
            let songAssetName =
                match ScriptingSystem.tryExport typeof<String> songAssetName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'songAssetName'; expecting a value convertable to String."
            let result = World.playSong7 timeToFadeInSongMs timeToFadeOutSongMs volume start songPackageName songAssetName world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'playSong6' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let playSound volume sound world =
        let oldWorld = world
        try
            let volume =
                match ScriptingSystem.tryExport typeof<Single> volume world with
                | Some value -> value :?> Single
                | None -> failwith "Invalid argument type for 'volume'; expecting a value convertable to Single."
            let sound =
                match ScriptingSystem.tryExport typeof<AssetTag<Sound>> sound world with
                | Some value -> value :?> AssetTag<Sound>
                | None -> failwith "Invalid argument type for 'sound'; expecting a value convertable to AssetTag`1."
            let result = World.playSound volume sound world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'playSound' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let playSound3 volume soundPackageName soundAssetName world =
        let oldWorld = world
        try
            let volume =
                match ScriptingSystem.tryExport typeof<Single> volume world with
                | Some value -> value :?> Single
                | None -> failwith "Invalid argument type for 'volume'; expecting a value convertable to Single."
            let soundPackageName =
                match ScriptingSystem.tryExport typeof<String> soundPackageName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'soundPackageName'; expecting a value convertable to String."
            let soundAssetName =
                match ScriptingSystem.tryExport typeof<String> soundAssetName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'soundAssetName'; expecting a value convertable to String."
            let result = World.playSound4 volume soundPackageName soundAssetName world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'playSound3' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let fadeOutSong timeToFadeOutSongMs world =
        let oldWorld = world
        try
            let timeToFadeOutSongMs =
                match ScriptingSystem.tryExport typeof<Int32> timeToFadeOutSongMs world with
                | Some value -> value :?> Int32
                | None -> failwith "Invalid argument type for 'timeToFadeOutSongMs'; expecting a value convertable to Int32."
            let result = World.fadeOutSong timeToFadeOutSongMs world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'fadeOutSong' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let stopSong world =
        let oldWorld = world
        try
            let result = World.stopSong world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'stopSong' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let hintAudioPackageUse packageName world =
        let oldWorld = world
        try
            let packageName =
                match ScriptingSystem.tryExport typeof<String> packageName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'packageName'; expecting a value convertable to String."
            let result = World.hintAudioPackageUse packageName world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'hintAudioPackageUse' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let hintAudioPackageDisuse packageName world =
        let oldWorld = world
        try
            let packageName =
                match ScriptingSystem.tryExport typeof<String> packageName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'packageName'; expecting a value convertable to String."
            let result = World.hintAudioPackageDisuse packageName world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'hintAudioPackageDisuse' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let reloadAudioAssets world =
        let oldWorld = world
        try
            let result = World.reloadAudioAssets world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'reloadAudioAssets' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let isMouseButtonDown mouseButton world =
        let oldWorld = world
        try
            let mouseButton =
                match ScriptingSystem.tryExport typeof<MouseButton> mouseButton world with
                | Some value -> value :?> MouseButton
                | None -> failwith "Invalid argument type for 'mouseButton'; expecting a value convertable to MouseButton."
            let result = World.isMouseButtonDown mouseButton world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isMouseButtonDown' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getMousePosition world =
        let oldWorld = world
        try
            let result = World.getMousePosition world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector2> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getMousePosition' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let isKeyboardKeyDown key world =
        let oldWorld = world
        try
            let key =
                match ScriptingSystem.tryExport typeof<KeyboardKey> key world with
                | Some value -> value :?> KeyboardKey
                | None -> failwith "Invalid argument type for 'key'; expecting a value convertable to KeyboardKey."
            let result = World.isKeyboardKeyDown key world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isKeyboardKeyDown' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let expandContent setScreenSplash content origin owner parent world =
        let oldWorld = world
        try
            let setScreenSplash =
                match ScriptingSystem.tryExport typeof<FSharpFunc<SplashDescriptor, FSharpFunc<Screen, FSharpFunc<Screen, FSharpFunc<World, World>>>>> setScreenSplash world with
                | Some value -> value :?> FSharpFunc<SplashDescriptor, FSharpFunc<Screen, FSharpFunc<Screen, FSharpFunc<World, World>>>>
                | None -> failwith "Invalid argument type for 'setScreenSplash'; expecting a value convertable to FSharpFunc`2."
            let content =
                match ScriptingSystem.tryExport typeof<SimulantContent> content world with
                | Some value -> value :?> SimulantContent
                | None -> failwith "Invalid argument type for 'content'; expecting a value convertable to SimulantContent."
            let origin =
                match ScriptingSystem.tryExport typeof<ContentOrigin> origin world with
                | Some value -> value :?> ContentOrigin
                | None -> failwith "Invalid argument type for 'origin'; expecting a value convertable to ContentOrigin."
            let struct (owner, world) =
                let context = World.getScriptContext world
                match World.evalInternal owner world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.derive address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let struct (parent, world) =
                let context = World.getScriptContext world
                match World.evalInternal parent world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.derive address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.expandContent setScreenSplash content origin owner parent world
            let (value, world) = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Simulant>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'expandContent' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let destroyImmediate simulant world =
        let oldWorld = world
        try
            let struct (simulant, world) =
                let context = World.getScriptContext world
                match World.evalInternal simulant world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.derive address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.destroyImmediate simulant world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroyImmediate' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let destroy simulant world =
        let oldWorld = world
        try
            let struct (simulant, world) =
                let context = World.getScriptContext world
                match World.evalInternal simulant world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.derive address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.destroy simulant world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroy' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let tryGetParent simulant world =
        let oldWorld = world
        try
            let struct (simulant, world) =
                let context = World.getScriptContext world
                match World.evalInternal simulant world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.derive address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.tryGetParent simulant world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Simulant>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryGetParent' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getParent simulant world =
        let oldWorld = world
        try
            let struct (simulant, world) =
                let context = World.getScriptContext world
                match World.evalInternal simulant world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.derive address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.getParent simulant world
            let value = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getParent' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getChildren simulant world =
        let oldWorld = world
        try
            let struct (simulant, world) =
                let context = World.getScriptContext world
                match World.evalInternal simulant world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.derive address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.getChildren simulant world
            let value = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getChildren' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getExists simulant world =
        let oldWorld = world
        try
            let struct (simulant, world) =
                let context = World.getScriptContext world
                match World.evalInternal simulant world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.derive address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.getExists simulant world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getExists' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let isSelected simulant world =
        let oldWorld = world
        try
            let struct (simulant, world) =
                let context = World.getScriptContext world
                match World.evalInternal simulant world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.derive address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.isSelected simulant world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isSelected' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let ignorePropertyBindings simulant world =
        let oldWorld = world
        try
            let struct (simulant, world) =
                let context = World.getScriptContext world
                match World.evalInternal simulant world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.derive address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.ignorePropertyBindings simulant world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'ignorePropertyBindings' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getEntities0 world =
        let oldWorld = world
        try
            let result = World.getEntities1 world
            let value = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEntities0' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getGroups0 world =
        let oldWorld = world
        try
            let result = World.getGroups1 world
            let value = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getGroups0' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let writeGameToFile filePath world =
        let oldWorld = world
        try
            let filePath =
                match ScriptingSystem.tryExport typeof<String> filePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'filePath'; expecting a value convertable to String."
            let result = World.writeGameToFile filePath world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Void> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'writeGameToFile' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let readGameFromFile filePath world =
        let oldWorld = world
        try
            let filePath =
                match ScriptingSystem.tryExport typeof<String> filePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'filePath'; expecting a value convertable to String."
            let result = World.readGameFromFile filePath world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'readGameFromFile' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getScreens world =
        let oldWorld = world
        try
            let result = World.getScreens world
            let value = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getScreens' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setScreenDissolve dissolveDescriptor songOpt screen world =
        let oldWorld = world
        try
            let dissolveDescriptor =
                match ScriptingSystem.tryExport typeof<DissolveDescriptor> dissolveDescriptor world with
                | Some value -> value :?> DissolveDescriptor
                | None -> failwith "Invalid argument type for 'dissolveDescriptor'; expecting a value convertable to DissolveDescriptor."
            let songOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<SongDescriptor>> songOpt world with
                | Some value -> value :?> FSharpOption<SongDescriptor>
                | None -> failwith "Invalid argument type for 'songOpt'; expecting a value convertable to FSharpOption`1."
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.setScreenDissolve dissolveDescriptor songOpt screen world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setScreenDissolve' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let destroyScreen screen world =
        let oldWorld = world
        try
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.destroyScreen screen world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroyScreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let createScreen dispatcherName nameOpt world =
        let oldWorld = world
        try
            let dispatcherName =
                match ScriptingSystem.tryExport typeof<String> dispatcherName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'dispatcherName'; expecting a value convertable to String."
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let result = World.createScreen3 dispatcherName nameOpt world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createScreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let createDissolveScreen dispatcherName nameOpt dissolveDescriptor songOpt world =
        let oldWorld = world
        try
            let dispatcherName =
                match ScriptingSystem.tryExport typeof<String> dispatcherName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'dispatcherName'; expecting a value convertable to String."
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let dissolveDescriptor =
                match ScriptingSystem.tryExport typeof<DissolveDescriptor> dissolveDescriptor world with
                | Some value -> value :?> DissolveDescriptor
                | None -> failwith "Invalid argument type for 'dissolveDescriptor'; expecting a value convertable to DissolveDescriptor."
            let songOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<SongDescriptor>> songOpt world with
                | Some value -> value :?> FSharpOption<SongDescriptor>
                | None -> failwith "Invalid argument type for 'songOpt'; expecting a value convertable to FSharpOption`1."
            let result = World.createDissolveScreen5 dispatcherName nameOpt dissolveDescriptor songOpt world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createDissolveScreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let writeScreenToFile filePath screen world =
        let oldWorld = world
        try
            let filePath =
                match ScriptingSystem.tryExport typeof<String> filePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'filePath'; expecting a value convertable to String."
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.writeScreenToFile filePath screen world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Void> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'writeScreenToFile' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let readScreenFromFile filePath nameOpt world =
        let oldWorld = world
        try
            let filePath =
                match ScriptingSystem.tryExport typeof<String> filePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'filePath'; expecting a value convertable to String."
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let result = World.readScreenFromFile filePath nameOpt world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'readScreenFromFile' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getGroups screen world =
        let oldWorld = world
        try
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.getGroups screen world
            let value = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getGroups' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let createGroup dispatcherName nameOpt screen world =
        let oldWorld = world
        try
            let dispatcherName =
                match ScriptingSystem.tryExport typeof<String> dispatcherName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'dispatcherName'; expecting a value convertable to String."
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.createGroup4 dispatcherName nameOpt screen world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createGroup' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let destroyGroup group world =
        let oldWorld = world
        try
            let struct (group, world) =
                let context = World.getScriptContext world
                match World.evalInternal group world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Group address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.destroyGroup group world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroyGroup' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let destroyGroups groups world =
        let oldWorld = world
        try
            let struct (groups, world) =
                let context = World.getScriptContext world
                match World.evalInternal groups world with
                | struct (Scripting.List simulants, world) ->
                    List.fold (fun struct (simulants, world) simulant ->
                        match simulant with
                        | Scripting.String str
                        | Scripting.Keyword str ->
                            let relation = Relation.makeFromString str
                            let address = Relation.resolve context.SimulantAddress relation
                            struct (Group address :: simulants, world)
                        | Scripting.Violation (_, error, _) -> failwith error
                        | _ -> failwith "Relation must be either a String or Keyword.")
                        struct ([], world)
                        simulants
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Expecting a list of relations."
            let result = World.destroyGroups groups world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroyGroups' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let writeGroupToFile filePath group world =
        let oldWorld = world
        try
            let filePath =
                match ScriptingSystem.tryExport typeof<String> filePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'filePath'; expecting a value convertable to String."
            let struct (group, world) =
                let context = World.getScriptContext world
                match World.evalInternal group world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Group address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.writeGroupToFile filePath group world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Void> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'writeGroupToFile' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let readGroupFromFile filePath nameOpt screen world =
        let oldWorld = world
        try
            let filePath =
                match ScriptingSystem.tryExport typeof<String> filePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'filePath'; expecting a value convertable to String."
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.readGroupFromFile filePath nameOpt screen world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'readGroupFromFile' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getEntitiesFlattened group world =
        let oldWorld = world
        try
            let struct (group, world) =
                let context = World.getScriptContext world
                match World.evalInternal group world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Group address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.getEntitiesFlattened group world
            let value = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEntitiesFlattened' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getEntities group world =
        let oldWorld = world
        try
            let struct (group, world) =
                let context = World.getScriptContext world
                match World.evalInternal group world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Group address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.getEntities group world
            let value = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEntities' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getEntitiesSovereign group world =
        let oldWorld = world
        try
            let struct (group, world) =
                let context = World.getScriptContext world
                match World.evalInternal group world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Group address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.getEntitiesSovereign group world
            let value = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEntitiesSovereign' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let destroyEntity entity world =
        let oldWorld = world
        try
            let struct (entity, world) =
                let context = World.getScriptContext world
                match World.evalInternal entity world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Entity address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.destroyEntity entity world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroyEntity' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let destroyEntities entities world =
        let oldWorld = world
        try
            let struct (entities, world) =
                let context = World.getScriptContext world
                match World.evalInternal entities world with
                | struct (Scripting.List simulants, world) ->
                    List.fold (fun struct (simulants, world) simulant ->
                        match simulant with
                        | Scripting.String str
                        | Scripting.Keyword str ->
                            let relation = Relation.makeFromString str
                            let address = Relation.resolve context.SimulantAddress relation
                            struct (Entity address :: simulants, world)
                        | Scripting.Violation (_, error, _) -> failwith error
                        | _ -> failwith "Relation must be either a String or Keyword.")
                        struct ([], world)
                        simulants
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Expecting a list of relations."
            let result = World.destroyEntities entities world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroyEntities' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let tryPickEntity position entities world =
        let oldWorld = world
        try
            let position =
                match ScriptingSystem.tryExport typeof<Vector2> position world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'position'; expecting a value convertable to Vector2."
            let struct (entities, world) =
                let context = World.getScriptContext world
                match World.evalInternal entities world with
                | struct (Scripting.List simulants, world) ->
                    List.fold (fun struct (simulants, world) simulant ->
                        match simulant with
                        | Scripting.String str
                        | Scripting.Keyword str ->
                            let relation = Relation.makeFromString str
                            let address = Relation.resolve context.SimulantAddress relation
                            struct (Entity address :: simulants, world)
                        | Scripting.Violation (_, error, _) -> failwith error
                        | _ -> failwith "Relation must be either a String or Keyword.")
                        struct ([], world)
                        simulants
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Expecting a list of relations."
            let result = World.tryPickEntity position entities world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Entity>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryPickEntity' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let writeEntityToFile filePath enity world =
        let oldWorld = world
        try
            let filePath =
                match ScriptingSystem.tryExport typeof<String> filePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'filePath'; expecting a value convertable to String."
            let struct (enity, world) =
                let context = World.getScriptContext world
                match World.evalInternal enity world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Entity address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.writeEntityToFile filePath enity world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Void> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'writeEntityToFile' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let readEntityFromFile filePath nameOpt group world =
        let oldWorld = world
        try
            let filePath =
                match ScriptingSystem.tryExport typeof<String> filePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'filePath'; expecting a value convertable to String."
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let struct (group, world) =
                let context = World.getScriptContext world
                match World.evalInternal group world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.derive address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.readEntityFromFile filePath nameOpt group world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'readEntityFromFile' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let createEntity dispatcherName names overlayDescriptor group world =
        let oldWorld = world
        try
            let dispatcherName =
                match ScriptingSystem.tryExport typeof<String> dispatcherName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'dispatcherName'; expecting a value convertable to String."
            let names =
                match ScriptingSystem.tryExport typeof<FSharpOption<String[]>> names world with
                | Some value -> value :?> FSharpOption<String[]>
                | None -> failwith "Invalid argument type for 'names'; expecting a value convertable to FSharpOption`1."
            let overlayDescriptor =
                match ScriptingSystem.tryExport typeof<OverlayNameDescriptor> overlayDescriptor world with
                | Some value -> value :?> OverlayNameDescriptor
                | None -> failwith "Invalid argument type for 'overlayDescriptor'; expecting a value convertable to OverlayNameDescriptor."
            let struct (group, world) =
                let context = World.getScriptContext world
                match World.evalInternal group world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Group address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.createEntity5 dispatcherName names overlayDescriptor group world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createEntity' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let renameEntity source destination world =
        let oldWorld = world
        try
            let struct (source, world) =
                let context = World.getScriptContext world
                match World.evalInternal source world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Entity address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let struct (destination, world) =
                let context = World.getScriptContext world
                match World.evalInternal destination world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Entity address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.renameEntity source destination world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'renameEntity' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let trySetEntityOverlayNameOpt overlayNameOpt entity world =
        let oldWorld = world
        try
            let overlayNameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> overlayNameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'overlayNameOpt'; expecting a value convertable to FSharpOption`1."
            let struct (entity, world) =
                let context = World.getScriptContext world
                match World.evalInternal entity world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Entity address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.trySetEntityOverlayNameOptFromScript overlayNameOpt entity world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'trySetEntityOverlayNameOpt' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let trySetEntityFacetNames facetNames entity world =
        let oldWorld = world
        try
            let facetNames =
                match ScriptingSystem.tryExport typeof<FSharpSet<String>> facetNames world with
                | Some value -> value :?> FSharpSet<String>
                | None -> failwith "Invalid argument type for 'facetNames'; expecting a value convertable to FSharpSet`1."
            let struct (entity, world) =
                let context = World.getScriptContext world
                match World.evalInternal entity world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Entity address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.trySetEntityFacetNamesFromScript facetNames entity world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'trySetEntityFacetNames' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getEyePosition world =
        let oldWorld = world
        try
            let result = World.getEyePosition world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector2> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEyePosition' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getImperative world =
        let oldWorld = world
        try
            let result = World.getImperative world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getImperative' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getStandAlone world =
        let oldWorld = world
        try
            let result = World.getStandAlone world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getStandAlone' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getCollectionConfig world =
        let oldWorld = world
        try
            let result = World.getCollectionConfig world
            let value = result
            let value = ScriptingSystem.tryImport typeof<TConfig> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getCollectionConfig' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getLiveness world =
        let oldWorld = world
        try
            let result = World.getLiveness world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Liveness> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getLiveness' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getUpdateRate world =
        let oldWorld = world
        try
            let result = World.getUpdateRate world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Int64> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getUpdateRate' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setUpdateRate updateRate world =
        let oldWorld = world
        try
            let updateRate =
                match ScriptingSystem.tryExport typeof<Int64> updateRate world with
                | Some value -> value :?> Int64
                | None -> failwith "Invalid argument type for 'updateRate'; expecting a value convertable to Int64."
            let result = World.setUpdateRate updateRate world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setUpdateRate' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let isAdvancing world =
        let oldWorld = world
        try
            let result = World.isAdvancing world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isAdvancing' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getUpdateTime world =
        let oldWorld = world
        try
            let result = World.getUpdateTime world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Int64> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getUpdateTime' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getClockDelta world =
        let oldWorld = world
        try
            let result = World.getClockDelta world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Single> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getClockDelta' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let exit world =
        let oldWorld = world
        try
            let result = World.exit world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'exit' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let tryGetTextureSize assetTag world =
        let oldWorld = world
        try
            let assetTag =
                match ScriptingSystem.tryExport typeof<AssetTag<Image>> assetTag world with
                | Some value -> value :?> AssetTag<Image>
                | None -> failwith "Invalid argument type for 'assetTag'; expecting a value convertable to AssetTag`1."
            let result = World.tryGetTextureSize assetTag world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Vector2i>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryGetTextureSize' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getTextureSize assetTag world =
        let oldWorld = world
        try
            let assetTag =
                match ScriptingSystem.tryExport typeof<AssetTag<Image>> assetTag world with
                | Some value -> value :?> AssetTag<Image>
                | None -> failwith "Invalid argument type for 'assetTag'; expecting a value convertable to AssetTag`1."
            let result = World.getTextureSize assetTag world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector2i> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getTextureSize' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let tryGetTextureSizeF assetTag world =
        let oldWorld = world
        try
            let assetTag =
                match ScriptingSystem.tryExport typeof<AssetTag<Image>> assetTag world with
                | Some value -> value :?> AssetTag<Image>
                | None -> failwith "Invalid argument type for 'assetTag'; expecting a value convertable to AssetTag`1."
            let result = World.tryGetTextureSizeF assetTag world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Vector2>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryGetTextureSizeF' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getTextureSizeF assetTag world =
        let oldWorld = world
        try
            let assetTag =
                match ScriptingSystem.tryExport typeof<AssetTag<Image>> assetTag world with
                | Some value -> value :?> AssetTag<Image>
                | None -> failwith "Invalid argument type for 'assetTag'; expecting a value convertable to AssetTag`1."
            let result = World.getTextureSizeF assetTag world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector2> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getTextureSizeF' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let reloadSymbols world =
        let oldWorld = world
        try
            let result = World.reloadSymbols world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Void> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'reloadSymbols' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let evalResolveBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|relation|] -> resolve relation world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalRelateBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|address|] -> relate address world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSelectScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|transitionState; screen|] -> selectScreen transitionState screen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryGetIsSelectedScreenIdlingBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> tryGetIsSelectedScreenIdling world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryGetIsSelectedScreenTransitioningBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> tryGetIsSelectedScreenTransitioning world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalIsSelectedScreenIdlingBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> isSelectedScreenIdling world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalIsSelectedScreenTransitioningBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> isSelectedScreenTransitioning world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryTransitionScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|destination|] -> tryTransitionScreen destination world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTransitionScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|destination|] -> transitionScreen destination world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetScreenSplashBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|splashDescriptor; destination; screen|] -> setScreenSplash splashDescriptor destination screen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateDissolveScreenFromGroupFile6Binding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|dispatcherName; nameOpt; dissolveDescriptor; songOpt; groupFilePath|] -> createDissolveScreenFromGroupFile6 dispatcherName nameOpt dissolveDescriptor songOpt groupFilePath world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateDissolveScreenFromGroupFileBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|nameOpt; dissolveDescriptor; songOpt; groupFilePath|] -> createDissolveScreenFromGroupFile nameOpt dissolveDescriptor songOpt groupFilePath world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateSplashScreen6Binding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|dispatcherName; nameOpt; splashDescriptor; destination|] -> createSplashScreen6 dispatcherName nameOpt splashDescriptor destination world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateSplashScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|nameOpt; splashDescriptor; destination|] -> createSplashScreen nameOpt splashDescriptor destination world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalReloadExistingAssetsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> reloadExistingAssets world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryReloadAssetsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> tryReloadAssets world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetCurrentSongOptBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getCurrentSongOpt world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetCurrentSongPositionBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getCurrentSongPosition world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetMasterAudioVolumeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getMasterAudioVolume world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetMasterSoundVolumeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getMasterSoundVolume world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetMasterSongVolumeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getMasterSongVolume world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetMasterAudioVolumeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|volume|] -> setMasterAudioVolume volume world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetMasterSoundVolumeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|volume|] -> setMasterSoundVolume volume world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetMasterSongVolumeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|volume|] -> setMasterSongVolume volume world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalPlaySongBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|timeToFadeInSongMs; timeToFadeOutSongMs; volume; start; song|] -> playSong timeToFadeInSongMs timeToFadeOutSongMs volume start song world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalPlaySong6Binding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|timeToFadeInSongMs; timeToFadeOutSongMs; volume; start; songPackageName; songAssetName|] -> playSong6 timeToFadeInSongMs timeToFadeOutSongMs volume start songPackageName songAssetName world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalPlaySoundBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|volume; sound|] -> playSound volume sound world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalPlaySound3Binding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|volume; soundPackageName; soundAssetName|] -> playSound3 volume soundPackageName soundAssetName world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalFadeOutSongBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|timeToFadeOutSongMs|] -> fadeOutSong timeToFadeOutSongMs world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalStopSongBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> stopSong world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalHintAudioPackageUseBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|packageName|] -> hintAudioPackageUse packageName world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalHintAudioPackageDisuseBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|packageName|] -> hintAudioPackageDisuse packageName world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalReloadAudioAssetsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> reloadAudioAssets world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalIsMouseButtonDownBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|mouseButton|] -> isMouseButtonDown mouseButton world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetMousePositionBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getMousePosition world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalIsKeyboardKeyDownBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|key|] -> isKeyboardKeyDown key world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalExpandContentBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|setScreenSplash; content; origin; owner; parent|] -> expandContent setScreenSplash content origin owner parent world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalDestroyImmediateBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|simulant|] -> destroyImmediate simulant world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalDestroyBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|simulant|] -> destroy simulant world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryGetParentBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|simulant|] -> tryGetParent simulant world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetParentBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|simulant|] -> getParent simulant world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetChildrenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|simulant|] -> getChildren simulant world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetExistsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|simulant|] -> getExists simulant world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalIsSelectedBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|simulant|] -> isSelected simulant world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalIgnorePropertyBindingsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|simulant|] -> ignorePropertyBindings simulant world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetEntities0Binding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getEntities0 world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetGroups0Binding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getGroups0 world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalWriteGameToFileBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|filePath|] -> writeGameToFile filePath world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalReadGameFromFileBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|filePath|] -> readGameFromFile filePath world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetScreensBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getScreens world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetScreenDissolveBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|dissolveDescriptor; songOpt; screen|] -> setScreenDissolve dissolveDescriptor songOpt screen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalDestroyScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|screen|] -> destroyScreen screen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|dispatcherName; nameOpt|] -> createScreen dispatcherName nameOpt world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateDissolveScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|dispatcherName; nameOpt; dissolveDescriptor; songOpt|] -> createDissolveScreen dispatcherName nameOpt dissolveDescriptor songOpt world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalWriteScreenToFileBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|filePath; screen|] -> writeScreenToFile filePath screen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalReadScreenFromFileBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|filePath; nameOpt|] -> readScreenFromFile filePath nameOpt world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetGroupsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|screen|] -> getGroups screen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateGroupBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|dispatcherName; nameOpt; screen|] -> createGroup dispatcherName nameOpt screen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalDestroyGroupBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|group|] -> destroyGroup group world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalDestroyGroupsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|groups|] -> destroyGroups groups world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalWriteGroupToFileBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|filePath; group|] -> writeGroupToFile filePath group world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalReadGroupFromFileBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|filePath; nameOpt; screen|] -> readGroupFromFile filePath nameOpt screen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetEntitiesFlattenedBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|group|] -> getEntitiesFlattened group world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetEntitiesBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|group|] -> getEntities group world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetEntitiesSovereignBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|group|] -> getEntitiesSovereign group world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalDestroyEntityBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|entity|] -> destroyEntity entity world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalDestroyEntitiesBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|entities|] -> destroyEntities entities world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryPickEntityBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|position; entities|] -> tryPickEntity position entities world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalWriteEntityToFileBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|filePath; enity|] -> writeEntityToFile filePath enity world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalReadEntityFromFileBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|filePath; nameOpt; group|] -> readEntityFromFile filePath nameOpt group world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateEntityBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|dispatcherName; names; overlayDescriptor; group|] -> createEntity dispatcherName names overlayDescriptor group world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalRenameEntityBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|source; destination|] -> renameEntity source destination world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTrySetEntityOverlayNameOptBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|overlayNameOpt; entity|] -> trySetEntityOverlayNameOpt overlayNameOpt entity world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTrySetEntityFacetNamesBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|facetNames; entity|] -> trySetEntityFacetNames facetNames entity world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetEyePositionBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getEyePosition world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetImperativeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getImperative world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetStandAloneBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getStandAlone world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetCollectionConfigBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getCollectionConfig world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetLivenessBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getLiveness world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetUpdateRateBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getUpdateRate world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetUpdateRateBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|updateRate|] -> setUpdateRate updateRate world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalIsAdvancingBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> isAdvancing world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetUpdateTimeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getUpdateTime world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetClockDeltaBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getClockDelta world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalExitBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> exit world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryGetTextureSizeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|assetTag|] -> tryGetTextureSize assetTag world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetTextureSizeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|assetTag|] -> getTextureSize assetTag world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryGetTextureSizeFBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|assetTag|] -> tryGetTextureSizeF assetTag world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetTextureSizeFBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|assetTag|] -> getTextureSizeF assetTag world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalReloadSymbolsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> reloadSymbols world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let tryGetBinding fnName =
        match WorldScripting.Bindings.TryGetValue fnName with
        | (true, binding) -> Some binding
        | (false, _) -> None

    let initBindings () =
        let bindings =
            [
             ("resolve", { Fn = evalResolveBinding; Pars = [|"relation"|]; DocOpt = None })
             ("relate", { Fn = evalRelateBinding; Pars = [|"address"|]; DocOpt = None })
             ("selectScreen", { Fn = evalSelectScreenBinding; Pars = [|"transitionState"; "screen"|]; DocOpt = None })
             ("tryGetIsSelectedScreenIdling", { Fn = evalTryGetIsSelectedScreenIdlingBinding; Pars = [||]; DocOpt = None })
             ("tryGetIsSelectedScreenTransitioning", { Fn = evalTryGetIsSelectedScreenTransitioningBinding; Pars = [||]; DocOpt = None })
             ("isSelectedScreenIdling", { Fn = evalIsSelectedScreenIdlingBinding; Pars = [||]; DocOpt = None })
             ("isSelectedScreenTransitioning", { Fn = evalIsSelectedScreenTransitioningBinding; Pars = [||]; DocOpt = None })
             ("tryTransitionScreen", { Fn = evalTryTransitionScreenBinding; Pars = [|"destination"|]; DocOpt = None })
             ("transitionScreen", { Fn = evalTransitionScreenBinding; Pars = [|"destination"|]; DocOpt = None })
             ("setScreenSplash", { Fn = evalSetScreenSplashBinding; Pars = [|"splashDescriptor"; "destination"; "screen"|]; DocOpt = None })
             ("createDissolveScreenFromGroupFile6", { Fn = evalCreateDissolveScreenFromGroupFile6Binding; Pars = [|"dispatcherName"; "nameOpt"; "dissolveDescriptor"; "songOpt"; "groupFilePath"|]; DocOpt = None })
             ("createDissolveScreenFromGroupFile", { Fn = evalCreateDissolveScreenFromGroupFileBinding; Pars = [|"nameOpt"; "dissolveDescriptor"; "songOpt"; "groupFilePath"|]; DocOpt = None })
             ("createSplashScreen6", { Fn = evalCreateSplashScreen6Binding; Pars = [|"dispatcherName"; "nameOpt"; "splashDescriptor"; "destination"|]; DocOpt = None })
             ("createSplashScreen", { Fn = evalCreateSplashScreenBinding; Pars = [|"nameOpt"; "splashDescriptor"; "destination"|]; DocOpt = None })
             ("reloadExistingAssets", { Fn = evalReloadExistingAssetsBinding; Pars = [||]; DocOpt = None })
             ("tryReloadAssets", { Fn = evalTryReloadAssetsBinding; Pars = [||]; DocOpt = None })
             ("getCurrentSongOpt", { Fn = evalGetCurrentSongOptBinding; Pars = [||]; DocOpt = None })
             ("getCurrentSongPosition", { Fn = evalGetCurrentSongPositionBinding; Pars = [||]; DocOpt = None })
             ("getMasterAudioVolume", { Fn = evalGetMasterAudioVolumeBinding; Pars = [||]; DocOpt = None })
             ("getMasterSoundVolume", { Fn = evalGetMasterSoundVolumeBinding; Pars = [||]; DocOpt = None })
             ("getMasterSongVolume", { Fn = evalGetMasterSongVolumeBinding; Pars = [||]; DocOpt = None })
             ("setMasterAudioVolume", { Fn = evalSetMasterAudioVolumeBinding; Pars = [|"volume"|]; DocOpt = None })
             ("setMasterSoundVolume", { Fn = evalSetMasterSoundVolumeBinding; Pars = [|"volume"|]; DocOpt = None })
             ("setMasterSongVolume", { Fn = evalSetMasterSongVolumeBinding; Pars = [|"volume"|]; DocOpt = None })
             ("playSong", { Fn = evalPlaySongBinding; Pars = [|"timeToFadeInSongMs"; "timeToFadeOutSongMs"; "volume"; "start"; "song"|]; DocOpt = None })
             ("playSong6", { Fn = evalPlaySong6Binding; Pars = [|"timeToFadeInSongMs"; "timeToFadeOutSongMs"; "volume"; "start"; "songPackageName"; "songAssetName"|]; DocOpt = None })
             ("playSound", { Fn = evalPlaySoundBinding; Pars = [|"volume"; "sound"|]; DocOpt = None })
             ("playSound3", { Fn = evalPlaySound3Binding; Pars = [|"volume"; "soundPackageName"; "soundAssetName"|]; DocOpt = None })
             ("fadeOutSong", { Fn = evalFadeOutSongBinding; Pars = [|"timeToFadeOutSongMs"|]; DocOpt = None })
             ("stopSong", { Fn = evalStopSongBinding; Pars = [||]; DocOpt = None })
             ("hintAudioPackageUse", { Fn = evalHintAudioPackageUseBinding; Pars = [|"packageName"|]; DocOpt = None })
             ("hintAudioPackageDisuse", { Fn = evalHintAudioPackageDisuseBinding; Pars = [|"packageName"|]; DocOpt = None })
             ("reloadAudioAssets", { Fn = evalReloadAudioAssetsBinding; Pars = [||]; DocOpt = None })
             ("isMouseButtonDown", { Fn = evalIsMouseButtonDownBinding; Pars = [|"mouseButton"|]; DocOpt = None })
             ("getMousePosition", { Fn = evalGetMousePositionBinding; Pars = [||]; DocOpt = None })
             ("isKeyboardKeyDown", { Fn = evalIsKeyboardKeyDownBinding; Pars = [|"key"|]; DocOpt = None })
             ("expandContent", { Fn = evalExpandContentBinding; Pars = [|"setScreenSplash"; "content"; "origin"; "owner"; "parent"|]; DocOpt = None })
             ("destroyImmediate", { Fn = evalDestroyImmediateBinding; Pars = [|"simulant"|]; DocOpt = None })
             ("destroy", { Fn = evalDestroyBinding; Pars = [|"simulant"|]; DocOpt = None })
             ("tryGetParent", { Fn = evalTryGetParentBinding; Pars = [|"simulant"|]; DocOpt = None })
             ("getParent", { Fn = evalGetParentBinding; Pars = [|"simulant"|]; DocOpt = None })
             ("getChildren", { Fn = evalGetChildrenBinding; Pars = [|"simulant"|]; DocOpt = None })
             ("getExists", { Fn = evalGetExistsBinding; Pars = [|"simulant"|]; DocOpt = None })
             ("isSelected", { Fn = evalIsSelectedBinding; Pars = [|"simulant"|]; DocOpt = None })
             ("ignorePropertyBindings", { Fn = evalIgnorePropertyBindingsBinding; Pars = [|"simulant"|]; DocOpt = None })
             ("getEntities0", { Fn = evalGetEntities0Binding; Pars = [||]; DocOpt = None })
             ("getGroups0", { Fn = evalGetGroups0Binding; Pars = [||]; DocOpt = None })
             ("writeGameToFile", { Fn = evalWriteGameToFileBinding; Pars = [|"filePath"|]; DocOpt = None })
             ("readGameFromFile", { Fn = evalReadGameFromFileBinding; Pars = [|"filePath"|]; DocOpt = None })
             ("getScreens", { Fn = evalGetScreensBinding; Pars = [||]; DocOpt = None })
             ("setScreenDissolve", { Fn = evalSetScreenDissolveBinding; Pars = [|"dissolveDescriptor"; "songOpt"; "screen"|]; DocOpt = None })
             ("destroyScreen", { Fn = evalDestroyScreenBinding; Pars = [|"screen"|]; DocOpt = None })
             ("createScreen", { Fn = evalCreateScreenBinding; Pars = [|"dispatcherName"; "nameOpt"|]; DocOpt = None })
             ("createDissolveScreen", { Fn = evalCreateDissolveScreenBinding; Pars = [|"dispatcherName"; "nameOpt"; "dissolveDescriptor"; "songOpt"|]; DocOpt = None })
             ("writeScreenToFile", { Fn = evalWriteScreenToFileBinding; Pars = [|"filePath"; "screen"|]; DocOpt = None })
             ("readScreenFromFile", { Fn = evalReadScreenFromFileBinding; Pars = [|"filePath"; "nameOpt"|]; DocOpt = None })
             ("getGroups", { Fn = evalGetGroupsBinding; Pars = [|"screen"|]; DocOpt = None })
             ("createGroup", { Fn = evalCreateGroupBinding; Pars = [|"dispatcherName"; "nameOpt"; "screen"|]; DocOpt = None })
             ("destroyGroup", { Fn = evalDestroyGroupBinding; Pars = [|"group"|]; DocOpt = None })
             ("destroyGroups", { Fn = evalDestroyGroupsBinding; Pars = [|"groups"|]; DocOpt = None })
             ("writeGroupToFile", { Fn = evalWriteGroupToFileBinding; Pars = [|"filePath"; "group"|]; DocOpt = None })
             ("readGroupFromFile", { Fn = evalReadGroupFromFileBinding; Pars = [|"filePath"; "nameOpt"; "screen"|]; DocOpt = None })
             ("getEntitiesFlattened", { Fn = evalGetEntitiesFlattenedBinding; Pars = [|"group"|]; DocOpt = None })
             ("getEntities", { Fn = evalGetEntitiesBinding; Pars = [|"group"|]; DocOpt = None })
             ("getEntitiesSovereign", { Fn = evalGetEntitiesSovereignBinding; Pars = [|"group"|]; DocOpt = None })
             ("destroyEntity", { Fn = evalDestroyEntityBinding; Pars = [|"entity"|]; DocOpt = None })
             ("destroyEntities", { Fn = evalDestroyEntitiesBinding; Pars = [|"entities"|]; DocOpt = None })
             ("tryPickEntity", { Fn = evalTryPickEntityBinding; Pars = [|"position"; "entities"|]; DocOpt = None })
             ("writeEntityToFile", { Fn = evalWriteEntityToFileBinding; Pars = [|"filePath"; "enity"|]; DocOpt = None })
             ("readEntityFromFile", { Fn = evalReadEntityFromFileBinding; Pars = [|"filePath"; "nameOpt"; "group"|]; DocOpt = None })
             ("createEntity", { Fn = evalCreateEntityBinding; Pars = [|"dispatcherName"; "names"; "overlayDescriptor"; "group"|]; DocOpt = None })
             ("renameEntity", { Fn = evalRenameEntityBinding; Pars = [|"source"; "destination"|]; DocOpt = None })
             ("trySetEntityOverlayNameOpt", { Fn = evalTrySetEntityOverlayNameOptBinding; Pars = [|"overlayNameOpt"; "entity"|]; DocOpt = None })
             ("trySetEntityFacetNames", { Fn = evalTrySetEntityFacetNamesBinding; Pars = [|"facetNames"; "entity"|]; DocOpt = None })
             ("getEyePosition", { Fn = evalGetEyePositionBinding; Pars = [||]; DocOpt = None })
             ("getImperative", { Fn = evalGetImperativeBinding; Pars = [||]; DocOpt = None })
             ("getStandAlone", { Fn = evalGetStandAloneBinding; Pars = [||]; DocOpt = None })
             ("getCollectionConfig", { Fn = evalGetCollectionConfigBinding; Pars = [||]; DocOpt = None })
             ("getLiveness", { Fn = evalGetLivenessBinding; Pars = [||]; DocOpt = None })
             ("getUpdateRate", { Fn = evalGetUpdateRateBinding; Pars = [||]; DocOpt = None })
             ("setUpdateRate", { Fn = evalSetUpdateRateBinding; Pars = [|"updateRate"|]; DocOpt = None })
             ("isAdvancing", { Fn = evalIsAdvancingBinding; Pars = [||]; DocOpt = None })
             ("getUpdateTime", { Fn = evalGetUpdateTimeBinding; Pars = [||]; DocOpt = None })
             ("getClockDelta", { Fn = evalGetClockDeltaBinding; Pars = [||]; DocOpt = None })
             ("exit", { Fn = evalExitBinding; Pars = [||]; DocOpt = None })
             ("tryGetTextureSize", { Fn = evalTryGetTextureSizeBinding; Pars = [|"assetTag"|]; DocOpt = None })
             ("getTextureSize", { Fn = evalGetTextureSizeBinding; Pars = [|"assetTag"|]; DocOpt = None })
             ("tryGetTextureSizeF", { Fn = evalTryGetTextureSizeFBinding; Pars = [|"assetTag"|]; DocOpt = None })
             ("getTextureSizeF", { Fn = evalGetTextureSizeFBinding; Pars = [|"assetTag"|]; DocOpt = None })
             ("reloadSymbols", { Fn = evalReloadSymbolsBinding; Pars = [||]; DocOpt = None })
            ] |>
            dictPlus StringComparer.Ordinal
        WorldScripting.Bindings <- bindings
